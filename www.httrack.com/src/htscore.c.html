<!DOCTYPE html PUBLIC "-//IETF//DTD HTML 2.0//EN">
<HTML>

<!-- Mirrored from www.httrack.com/src/htscore.c.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 02 Jan 2023 20:31:40 GMT -->
<HEAD>
<TITLE>./htscore.c - HTTrack Website Copier</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#1F00FF" ALINK="#FF0000" VLINK="#9900DD">
<A NAME="top">
<A NAME="file1">
<H1>./htscore.c</H1>

<PRE>
<I><FONT COLOR="#B22222">/* ------------------------------------------------------------ */</FONT></I>
<I><FONT COLOR="#B22222">/*
HTTrack Website Copier, Offline Browser for Windows and Unix
Copyright (C) 1998-2015 Xavier Roche and other contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.

Important notes:

- We hereby ask people using this source NOT to use it in purpose of grabbing
emails addresses, or collecting any other private information on persons.
This would disgrace our work, and spoil the many hours we spent on it.

Please visit our Website: http://www.httrack.com
*/</FONT></I>

<I><FONT COLOR="#B22222">/* ------------------------------------------------------------ */</FONT></I>
<I><FONT COLOR="#B22222">/* File: Main source                                            */</FONT></I>
<I><FONT COLOR="#B22222">/* Author: Xavier Roche                                         */</FONT></I>
<I><FONT COLOR="#B22222">/* ------------------------------------------------------------ */</FONT></I>

<I><FONT COLOR="#B22222">/* Internal engine bytecode */</FONT></I>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">HTS_INTERNAL_BYTECODE</FONT>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;fcntl.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;ctype.h&gt;</FONT></B>

<I><FONT COLOR="#B22222">/* File defs */</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;htscore.h&quot;</FONT></B>

<I><FONT COLOR="#B22222">/* specific definitions */</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;htsbase.h&quot;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;htsnet.h&quot;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;htsbauth.h&quot;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;htsmd5.h&quot;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;htsindex.h&quot;</FONT></B>

<I><FONT COLOR="#B22222">/* external modules */</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;htsmodules.h&quot;</FONT></B>

<I><FONT COLOR="#B22222">// htswrap_add
</FONT></I>#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;htswrap.h&quot;</FONT></B>

<I><FONT COLOR="#B22222">// parser
</FONT></I>#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;htsparse.h&quot;</FONT></B>

<I><FONT COLOR="#B22222">/* Cache */</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;htszlib.h&quot;</FONT></B>

<I><FONT COLOR="#B22222">/* Charset handling */</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;htscharset.h&quot;</FONT></B>

<I><FONT COLOR="#B22222">/* Dynamic typed arrays */</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;htsarrays.h&quot;</FONT></B>

<I><FONT COLOR="#B22222">/* END specific definitions */</FONT></I>

<I><FONT COLOR="#B22222">/* external modules */</FONT></I>
<B><FONT COLOR="#228B22">extern</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">hts_parse_externals</FONT></B>(htsmoduleStruct * str);
<B><FONT COLOR="#228B22">extern</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">htspe_init</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>);

<I><FONT COLOR="#B22222">/* debug */</FONT></I>
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">DEBUG_SHOWTYPES</FONT>
<B><FONT COLOR="#228B22">char</FONT></B> REG[32768] = <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">NSDEBUG</FONT>
<B><FONT COLOR="#228B22">int</FONT></B> nsocDEBUG = 0;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">//
</FONT></I>#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">_CLRSCR</FONT> printf(<B><FONT COLOR="#BC8F8F">&quot;\33[m\33[2J&quot;</FONT></B>);
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">_GOTOXY</FONT></B>(X,Y) printf(<B><FONT COLOR="#BC8F8F">&quot;\33[&quot;</FONT></B> X <B><FONT COLOR="#BC8F8F">&quot;;&quot;</FONT></B> Y <B><FONT COLOR="#BC8F8F">&quot;f&quot;</FONT></B>);

#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">DEBUG_CHECKINT</FONT>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">_CHECKINT_FAIL</FONT></B>(a) printf(<B><FONT COLOR="#BC8F8F">&quot;\n%s\n&quot;</FONT></B>,a); fflush(stdout); abort();
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">_CHECKINT</FONT></B>(obj_ptr,message) \
   if (obj_ptr) {\
     if (( * ((char*) (obj_ptr)) != 0) || ( * ((char*) (((char*) (obj_ptr)) + sizeof(*(obj_ptr))-1)) != 0)) {\
       char msg[1100];\
       if (( * ((char*) (obj_ptr)) != 0) &amp;&amp; ( * ((char*) (((char*) (obj_ptr)) + sizeof(*(obj_ptr))-1)) != 0))\
         sprintf(msg,<B><FONT COLOR="#BC8F8F">&quot;* PANIC: Integrity error (structure crushed)  in: %s&quot;</FONT></B>,message);\
       else if ( * ((char*) (obj_ptr)) != 0)\
         sprintf(msg,<B><FONT COLOR="#BC8F8F">&quot;* PANIC: Integrity error (start of structure) in: %s&quot;</FONT></B>,message);\
       else\
         sprintf(msg,<B><FONT COLOR="#BC8F8F">&quot;* PANIC: Integrity error (end of structure)   in: %s&quot;</FONT></B>,message);\
       _CHECKINT_FAIL(msg);\
     }\
   } else {\
     char msg[1100];\
     sprintf(msg,<B><FONT COLOR="#BC8F8F">&quot;* PANIC: NULL pointer in: %s&quot;</FONT></B>,message);\
     _CHECKINT_FAIL(msg);\
   }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">DEBUG_HASH</FONT>
  <I><FONT COLOR="#B22222">// longest hash chain?
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> longest_hash[3] = { 0, 0, 0 }, hashnumber = 0;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">// Début de httpmirror, routines annexes
</FONT></I>
<I><FONT COLOR="#B22222">// au cas où nous devons quitter rapidement xhttpmirror (plus de mémoire, etc)
</FONT></I><I><FONT COLOR="#B22222">// note: partir de liens_max.. vers 0.. sinon erreur de violation de mémoire: les liens suivants
</FONT></I><I><FONT COLOR="#B22222">// ne sont plus à nous.. agh! [dur celui-là]
</FONT></I>#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">HTMLCHECK_UNINIT</FONT> { \
hts_log_print(opt, LOG_INFO, <B><FONT COLOR="#BC8F8F">&quot;engine: end&quot;</FONT></B>); \
RUN_CALLBACK0(opt, end); \
}

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">XH_extuninit</FONT> do { \
  HTMLCHECK_UNINIT \
  hts_record_free(opt); \
  if (filters &amp;&amp; filters[0]) { \
  freet(filters[0]); filters[0]=NULL; \
  } \
  if (filters) { \
  freet(filters); filters=NULL; \
  } \
  back_delete_all(opt,&amp;cache,sback); \
  back_free(&amp;sback); \
  checkrobots_free(&amp;robots);\
  if (cache.use) { freet(cache.use); cache.use=NULL; } \
  if (cache.dat) { fclose(cache.dat); cache.dat=NULL; }  \
  if (cache.ndx) { fclose(cache.ndx); cache.ndx=NULL; } \
  if (cache.zipOutput) { \
    zipClose(cache.zipOutput, <B><FONT COLOR="#BC8F8F">&quot;Created by HTTrack Website Copier/&quot;</FONT></B>HTTRACK_VERSION); \
    cache.zipOutput = NULL; \
  } \
  if (cache.zipInput) { \
    unzClose(cache.zipInput); \
    cache.zipInput = NULL; \
  } \
  if (cache.olddat) { fclose(cache.olddat); cache.olddat=NULL; } \
  if (cache.lst) { fclose(cache.lst); cache.lst=opt-&gt;state.strc.lst=NULL; } \
  if (cache.txt) { fclose(cache.txt); cache.txt=NULL; } \
  if (opt-&gt;log != NULL) fflush(opt-&gt;log); \
  if (makestat_fp) { fclose(makestat_fp); makestat_fp=NULL; } \
  if (maketrack_fp){ fclose(maketrack_fp); maketrack_fp=NULL; } \
  if (opt-&gt;accept_cookie) cookie_save(opt-&gt;cookie,fconcat(OPT_GET_BUFF(opt),OPT_GET_BUFF_SIZE(opt),StringBuff(opt-&gt;path_log),<B><FONT COLOR="#BC8F8F">&quot;cookies.txt&quot;</FONT></B>)); \
  if (makeindex_fp) { fclose(makeindex_fp); makeindex_fp=NULL; } \
  if (cache_hashtable) { coucal_delete(&amp;cache_hashtable); } \
  if (cache_tests)     { coucal_delete(&amp;cache_tests); } \
  if (template_header) { freet(template_header); template_header=NULL; } \
  if (template_body)   { freet(template_body); template_body=NULL; } \
  if (template_footer) { freet(template_footer); template_footer=NULL; } \
  hash_free(&amp;hash); \
  clearCallbacks(&amp;opt-&gt;state.callbacks); \
  <I><FONT COLOR="#B22222">/*structcheck_init(-1);*/</FONT></I> \
} while(0)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">XH_uninit</FONT> do { XH_extuninit; if (r.adr) { freet(r.adr); r.adr=NULL; } } while(0)

<B><FONT COLOR="#228B22">struct</FONT></B> lien_buffers {
  <I><FONT COLOR="#B22222">/* Main array of pointers. 
     This is the real &quot;lien_url **liens&quot; pointer base. */</FONT></I>
  TypedArray(lien_url*) ptr;
  <I><FONT COLOR="#B22222">/* String pool, chunked. */</FONT></I>
  <B><FONT COLOR="#228B22">char</FONT></B> *string_buffer;
  size_t string_buffer_size;
  size_t string_buffer_capa;
  TypedArray(<B><FONT COLOR="#228B22">char</FONT></B>*) string_buffers;
  <I><FONT COLOR="#B22222">/* Structure list, chunked. */</FONT></I>
  lien_url *lien_buffer;
  size_t lien_buffer_size;
  size_t lien_buffer_capa;
  TypedArray(lien_url*) lien_buffers;
};

<I><FONT COLOR="#B22222">// duplicate a string, or return NULL upon error (out-of-memory)
</FONT></I><B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>* <B><FONT COLOR="#0000FF">hts_record_link_strdup_</FONT></B>(httrackp *opt, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *s) {
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> size_t block_capa = 32768;
  lien_buffers *<B><FONT COLOR="#228B22">const</FONT></B> liensbuf = opt-&gt;liensbuf;
  <B><FONT COLOR="#228B22">const</FONT></B> size_t len = strlen(s) + 1;  <I><FONT COLOR="#B22222">/* including terminating \0 */</FONT></I>
  <B><FONT COLOR="#228B22">char</FONT></B> *s_dup;

  assertf(liensbuf != NULL);
  assertf(len &lt; block_capa);

  <I><FONT COLOR="#B22222">// not enough capacity ? then create a new chunk
</FONT></I>  <B><FONT COLOR="#A020F0">if</FONT></B> (len + liensbuf-&gt;string_buffer_size &gt; liensbuf-&gt;string_buffer_capa) {
    <I><FONT COLOR="#B22222">// backup current block pointer for later free
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B> (liensbuf-&gt;string_buffer != NULL) {
      TypedArrayAdd(liensbuf-&gt;string_buffers, liensbuf-&gt;string_buffer);
      liensbuf-&gt;string_buffer = NULL;
      liensbuf-&gt;string_buffer_size = 0;
    }

    <I><FONT COLOR="#B22222">// Double capacity for each new chained block
</FONT></I>    liensbuf-&gt;string_buffer_capa = 
      liensbuf-&gt;string_buffer_capa &lt; block_capa 
      ? block_capa : liensbuf-&gt;string_buffer_capa * 2;

    liensbuf-&gt;string_buffer = malloct(liensbuf-&gt;string_buffer_capa);
    <B><FONT COLOR="#A020F0">if</FONT></B> (liensbuf-&gt;string_buffer == NULL) {
      hts_record_assert_memory_failed(liensbuf-&gt;string_buffer_capa);
    }
    liensbuf-&gt;string_buffer_size = 0;

    hts_log_print(opt, LOG_DEBUG,
      <B><FONT COLOR="#BC8F8F">&quot;reallocated %d new bytes of strings room&quot;</FONT></B>,
      (<B><FONT COLOR="#228B22">int</FONT></B>) liensbuf-&gt;string_buffer_capa);
  }

  assertf(len + liensbuf-&gt;string_buffer_size &lt;= liensbuf-&gt;string_buffer_capa);
  s_dup = &amp;liensbuf-&gt;string_buffer[liensbuf-&gt;string_buffer_size];
  memcpy(s_dup, s, len);
  liensbuf-&gt;string_buffer_size += len;
  
  <B><FONT COLOR="#A020F0">return</FONT></B> s_dup;
}

<B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>* <B><FONT COLOR="#0000FF">hts_record_link_strdup</FONT></B>(httrackp *opt, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *s) {
  assertf(opt != NULL);
  assertf(s != NULL);
  <B><FONT COLOR="#A020F0">return</FONT></B> hts_record_link_strdup_(opt, s);
}

size_t <B><FONT COLOR="#0000FF">hts_record_link_latest</FONT></B>(httrackp *opt) {
  lien_buffers *<B><FONT COLOR="#228B22">const</FONT></B> liensbuf = opt-&gt;liensbuf;

  assertf(TypedArraySize(liensbuf-&gt;ptr) != 0);
  <B><FONT COLOR="#A020F0">return</FONT></B> TypedArraySize(liensbuf-&gt;ptr) - 1;
}

<I><FONT COLOR="#B22222">// returns a new zeroed lien_url entry, 
</FONT></I><I><FONT COLOR="#B22222">// or (size_t) -1 upon error (out-of-memory)
</FONT></I><I><FONT COLOR="#B22222">// the returned index is the osset within opt-&gt;liens[]
</FONT></I><B><FONT COLOR="#228B22">static</FONT></B> size_t <B><FONT COLOR="#0000FF">hts_record_link_alloc</FONT></B>(httrackp *opt) {
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> size_t block_capa = 256;
  lien_buffers *<B><FONT COLOR="#228B22">const</FONT></B> liensbuf = opt-&gt;liensbuf;
  lien_url *link;

  assertf(opt != NULL);
  assertf(liensbuf != NULL);

  <I><FONT COLOR="#B22222">// Limit the number of links
</FONT></I>  <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;maxlink &gt; 0 &amp;&amp; TypedArraySize(liensbuf-&gt;ptr) &gt;= opt-&gt;maxlink) {
    <B><FONT COLOR="#A020F0">return</FONT></B> (size_t) -1;
  }

  <I><FONT COLOR="#B22222">// Create a new chunk of lien_url[]
</FONT></I>  <I><FONT COLOR="#B22222">// There are references to item pointers, so we can not just realloc()
</FONT></I>  <B><FONT COLOR="#A020F0">if</FONT></B> (liensbuf-&gt;lien_buffer_size == liensbuf-&gt;lien_buffer_capa) {
    size_t capa_bytes;

    <B><FONT COLOR="#A020F0">if</FONT></B> (liensbuf-&gt;lien_buffer != NULL) {
      TypedArrayAdd(liensbuf-&gt;lien_buffers, liensbuf-&gt;lien_buffer);
      liensbuf-&gt;lien_buffer_size = 0;
    }

    <I><FONT COLOR="#B22222">// Double capacity for each new chained block
</FONT></I>    liensbuf-&gt;lien_buffer_capa = 
      liensbuf-&gt;lien_buffer_capa &lt; block_capa 
      ? block_capa : liensbuf-&gt;lien_buffer_capa * 2;

    capa_bytes = liensbuf-&gt;lien_buffer_capa*<B><FONT COLOR="#A020F0">sizeof</FONT></B>(*liensbuf-&gt;lien_buffer);
    liensbuf-&gt;lien_buffer = (lien_url*) malloct(capa_bytes);
    <B><FONT COLOR="#A020F0">if</FONT></B> (liensbuf-&gt;lien_buffer == NULL) {
      hts_record_assert_memory_failed(capa_bytes);
    }
    liensbuf-&gt;lien_buffer_size = 0;

    hts_log_print(opt, LOG_DEBUG, <B><FONT COLOR="#BC8F8F">&quot;reallocated %d new link placeholders&quot;</FONT></B>,
      (<B><FONT COLOR="#228B22">int</FONT></B>) liensbuf-&gt;lien_buffer_capa);
  }

  <I><FONT COLOR="#B22222">// Take next lien_url item
</FONT></I>  assertf(liensbuf-&gt;lien_buffer_size &lt; liensbuf-&gt;lien_buffer_capa);
  link = &amp;liensbuf-&gt;lien_buffer[liensbuf-&gt;lien_buffer_size++];
  memset(link, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(*link));

  <I><FONT COLOR="#B22222">// Add new lien_url pointer to the array of links
</FONT></I>  TypedArrayAdd(liensbuf-&gt;ptr, link);

  <I><FONT COLOR="#B22222">// Ensure we have a guard NULL
</FONT></I>  TypedArrayAdd(liensbuf-&gt;ptr, NULL);
  TypedArraySize(liensbuf-&gt;ptr)--;

  <I><FONT COLOR="#B22222">// Update pointer as it may have changed,
</FONT></I>  <I><FONT COLOR="#B22222">// and update heap top index
</FONT></I>  opt-&gt;liens = TypedArrayElts(liensbuf-&gt;ptr);
  assertf(TypedArraySize(liensbuf-&gt;ptr) != 0);
  assertf(TypedArraySize(liensbuf-&gt;ptr) &lt; ( (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>) -1 ) / 2);
  opt-&gt;lien_tot = (<B><FONT COLOR="#228B22">int</FONT></B>) TypedArraySize(liensbuf-&gt;ptr);

  <I><FONT COLOR="#B22222">// return tail
</FONT></I>  <B><FONT COLOR="#A020F0">return</FONT></B> hts_record_link_latest(opt);
}

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">hts_record_init</FONT></B>(httrackp *opt) {
  <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;liensbuf == NULL) {
    opt-&gt;liensbuf = calloct(<B><FONT COLOR="#A020F0">sizeof</FONT></B>(*opt-&gt;liensbuf), 1);
    <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;liensbuf == NULL) {
      hts_record_assert_memory_failed(<B><FONT COLOR="#A020F0">sizeof</FONT></B>(*opt-&gt;liensbuf));
    }
  }
}

<I><FONT COLOR="#B22222">// wipe records
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">hts_record_free</FONT></B>(httrackp *opt) {
  lien_buffers *<B><FONT COLOR="#228B22">const</FONT></B> liensbuf = opt-&gt;liensbuf;

  <B><FONT COLOR="#A020F0">if</FONT></B> (liensbuf != NULL) {
    size_t i;

    TypedArrayFree(liensbuf-&gt;ptr);

    <B><FONT COLOR="#A020F0">if</FONT></B> (liensbuf-&gt;string_buffer != NULL) {
      freet(liensbuf-&gt;string_buffer);
      liensbuf-&gt;string_buffer = NULL;
      liensbuf-&gt;string_buffer_size = 0;
      liensbuf-&gt;string_buffer_capa = 0;
    }

    <B><FONT COLOR="#A020F0">for</FONT></B>(i = 0 ; i &lt; TypedArraySize(liensbuf-&gt;string_buffers) ; i++) {
      freet(TypedArrayNth(liensbuf-&gt;string_buffers, i));
      TypedArrayNth(liensbuf-&gt;string_buffers, i) = NULL;
    }
    TypedArrayFree(liensbuf-&gt;string_buffers);

    <B><FONT COLOR="#A020F0">if</FONT></B> (liensbuf-&gt;lien_buffer != NULL) {
      freet(liensbuf-&gt;lien_buffer);
      liensbuf-&gt;lien_buffer = NULL;
    }

    <B><FONT COLOR="#A020F0">for</FONT></B>(i = 0 ; i &lt; TypedArraySize(liensbuf-&gt;lien_buffers) ; i++) {
      freet(TypedArrayNth(liensbuf-&gt;lien_buffers, i));
      TypedArrayNth(liensbuf-&gt;lien_buffers, i) = NULL;
    }
    TypedArrayFree(liensbuf-&gt;lien_buffers);

    freet(opt-&gt;liensbuf);
    opt-&gt;liensbuf = NULL;
  }

  opt-&gt;liens = NULL;  <I><FONT COLOR="#B22222">// no longer defined
</FONT></I>}

<I><FONT COLOR="#B22222">// adds a new link and returns a non-zero value upon success
</FONT></I><B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">hts_record_link_</FONT></B>(httrackp * opt,
                            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *address, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *file, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *save,
                            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *ref_address, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *ref_file,
                            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *codebase) {
  <I><FONT COLOR="#B22222">// create a new entry
</FONT></I>  <B><FONT COLOR="#228B22">const</FONT></B> size_t lien_tot = hts_record_link_alloc(opt);
  lien_url*<B><FONT COLOR="#228B22">const</FONT></B> link = lien_tot != (size_t) -1 ? opt-&gt;liens[lien_tot] : NULL;
  <B><FONT COLOR="#A020F0">if</FONT></B> (link == NULL) {
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
  }

  <I><FONT COLOR="#B22222">// record string fields
</FONT></I>  <B><FONT COLOR="#A020F0">if</FONT></B> ( (link-&gt;adr = hts_record_link_strdup(opt, address)) == NULL
    || (link-&gt;fil = hts_record_link_strdup(opt, file)) == NULL
    || (link-&gt;sav = hts_record_link_strdup(opt, save)) == NULL
    || (link-&gt;former_adr = hts_record_link_strdup(opt, ref_address)) == NULL
    || (link-&gt;former_fil = hts_record_link_strdup(opt, ref_file)) == NULL
    ) {
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
  }

  <I><FONT COLOR="#B22222">// record codebase for java classes
</FONT></I>  <B><FONT COLOR="#A020F0">if</FONT></B> (codebase != NULL) {
    <B><FONT COLOR="#228B22">const</FONT></B> size_t len = strlen(file);
    <B><FONT COLOR="#A020F0">if</FONT></B> (len &gt; 6 &amp;&amp; strncmp(&amp;file[len - 6], <B><FONT COLOR="#BC8F8F">&quot;.class&quot;</FONT></B>, 6) == 0) {
      <B><FONT COLOR="#A020F0">if</FONT></B> ((link-&gt;cod = hts_record_link_strdup(opt, codebase)) == NULL) {
        <B><FONT COLOR="#A020F0">return</FONT></B> 0;
      }
    }
  }

  <I><FONT COLOR="#B22222">// add entry in the hashtables
</FONT></I>  hash_write(opt-&gt;hash, lien_tot);

  <I><FONT COLOR="#B22222">// success
</FONT></I>  <B><FONT COLOR="#A020F0">return</FONT></B> 1;
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">hts_record_link</FONT></B>(httrackp * opt,
                    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *address, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *file, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *save,
                    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *ref_address, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *ref_file,
                    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *codebase) {
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> success = 
    hts_record_link_(opt, address, file, save, ref_address, ref_file, codebase);
  <B><FONT COLOR="#A020F0">if</FONT></B> (!success) {
    hts_log_print(opt, LOG_PANIC, <B><FONT COLOR="#BC8F8F">&quot;Too many links (links=%ld, limit=%ld)&quot;</FONT></B>, 
                  (<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>) heap_top_index(), (<B><FONT COLOR="#228B22">long</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>) opt-&gt;maxlink);
    hts_log_print(opt, LOG_INFO,
      <B><FONT COLOR="#BC8F8F">&quot;To avoid that: use #L option for more links (example: -#L1000000, or -#L0 to disable)&quot;</FONT></B>);
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> success;
}

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">hts_invalidate_link</FONT></B>(httrackp * opt, <B><FONT COLOR="#228B22">int</FONT></B> lpos) {
  <I><FONT COLOR="#B22222">/* devalidate entry  */</FONT></I>
  opt-&gt;liens[lpos]-&gt;pass2 = -1;
}


#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">HT_INDEX_END</FONT> do { \
if (!makeindex_done) { \
if (makeindex_fp) { \
  char BIGSTK tempo[1024]; \
  if (makeindex_links == 1) { \
    char BIGSTK link_escaped[HTS_URLMAXSIZE*2]; \
    escape_uri_utf(makeindex_firstlink, link_escaped, sizeof(link_escaped)); \
    sprintf(tempo,<B><FONT COLOR="#BC8F8F">&quot;&lt;meta HTTP-EQUIV=\&quot;Refresh\&quot; CONTENT=\&quot;0; URL=%s\&quot;&gt;&quot;</FONT></B>CRLF, link_escaped); \
  } else \
    tempo[0]=<B><FONT COLOR="#BC8F8F">'\0'</FONT></B>; \
    hts_template_format(makeindex_fp,template_footer, \
    <B><FONT COLOR="#BC8F8F">&quot;&lt;!-- Mirror and index made by HTTrack Website Copier/&quot;</FONT></B>HTTRACK_VERSION<B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>HTTRACK_AFF_AUTHORS<B><FONT COLOR="#BC8F8F">&quot; --&gt;&quot;</FONT></B>, \
    tempo, <I><FONT COLOR="#B22222">/* EOF */</FONT></I> NULL \
    ); \
  fflush(makeindex_fp); \
  fclose(makeindex_fp);  <I><FONT COLOR="#B22222">/* à ne pas oublier sinon on passe une nuit blanche */</FONT></I>  \
  makeindex_fp=NULL; \
  usercommand(opt,0,NULL,fconcat(OPT_GET_BUFF(opt),OPT_GET_BUFF_SIZE(opt),StringBuff(opt-&gt;path_html_utf8),<B><FONT COLOR="#BC8F8F">&quot;index.html&quot;</FONT></B>),<B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>,<B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>);  \
} \
} \
makeindex_done=1;    <I><FONT COLOR="#B22222">/* ok c'est fait */</FONT></I>  \
} while(0)

<I><FONT COLOR="#B22222">/* does it look like XML ? (SVG et al.) */</FONT></I>
<B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">look_like_xml</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *s) {
  <B><FONT COLOR="#A020F0">return</FONT></B> strncmp(s, <B><FONT COLOR="#BC8F8F">&quot;&lt;?xml&quot;</FONT></B>, 5) == 0
    || strncmp(s, <B><FONT COLOR="#BC8F8F">&quot;&lt;!-- &quot;</FONT></B>, 5) == 0
    || strncmp(s, <B><FONT COLOR="#BC8F8F">&quot;&lt;svg &quot;</FONT></B>, 5) == 0
    ;
}

<I><FONT COLOR="#B22222">// Début de httpmirror, robot
</FONT></I><I><FONT COLOR="#B22222">// url1 peut être multiple
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">httpmirror</FONT></B>(<B><FONT COLOR="#228B22">char</FONT></B> *url1, httrackp * opt) {
  <B><FONT COLOR="#228B22">char</FONT></B> *primary = NULL;         <I><FONT COLOR="#B22222">// première page, contenant les liens à scanner
</FONT></I>  hash_struct hash;             <I><FONT COLOR="#B22222">// système de hachage, accélère la recherche dans les liens
</FONT></I>  hash_struct *<B><FONT COLOR="#228B22">const</FONT></B> hashptr = &amp;hash;
  t_cookie BIGSTK cookie;       <I><FONT COLOR="#B22222">// gestion des cookies
</FONT></I>
  <I><FONT COLOR="#B22222">//char* tab_alloc=NULL;
</FONT></I>  <B><FONT COLOR="#228B22">int</FONT></B> ptr;                      <I><FONT COLOR="#B22222">// pointeur actuel sur les liens
</FONT></I>
  <I><FONT COLOR="#B22222">//
</FONT></I>  <B><FONT COLOR="#228B22">int</FONT></B> numero_passe = 0;         <I><FONT COLOR="#B22222">// deux passes pour html puis images
</FONT></I>  struct_back *sback = NULL;
  htsblk BIGSTK r;              <I><FONT COLOR="#B22222">// retour de certaines fonctions
</FONT></I>
  <I><FONT COLOR="#B22222">// pour les stats, nombre de fichiers &amp; octets écrits
</FONT></I>  LLint stat_fragment = 0;      <I><FONT COLOR="#B22222">// pour la fragmentation
</FONT></I>
  <I><FONT COLOR="#B22222">//TStamp istat_timestart;   // départ pour calcul instantanné
</FONT></I>  <I><FONT COLOR="#B22222">//
</FONT></I>  TStamp last_info_shell = 0;
  <B><FONT COLOR="#228B22">int</FONT></B> info_shell = 0;

  <I><FONT COLOR="#B22222">// filtres
</FONT></I>  <B><FONT COLOR="#228B22">char</FONT></B> **filters = NULL;

  <I><FONT COLOR="#B22222">//int filter_max=0;
</FONT></I>  <B><FONT COLOR="#228B22">int</FONT></B> filptr = 0;

  <I><FONT COLOR="#B22222">//
</FONT></I>  <B><FONT COLOR="#228B22">int</FONT></B> makeindex_done = 0;       <I><FONT COLOR="#B22222">// lorsque l'index sera fait
</FONT></I>  FILE *makeindex_fp = NULL;
  <B><FONT COLOR="#228B22">int</FONT></B> makeindex_links = 0;
  <B><FONT COLOR="#228B22">char</FONT></B> BIGSTK makeindex_firstlink[HTS_URLMAXSIZE * 2];

  <I><FONT COLOR="#B22222">// statistiques (mode #Z)
</FONT></I>  FILE *makestat_fp = NULL;     <I><FONT COLOR="#B22222">// fichier de stats taux transfert
</FONT></I>  FILE *maketrack_fp = NULL;    <I><FONT COLOR="#B22222">// idem pour le tracking
</FONT></I>  TStamp makestat_time = 0;     <I><FONT COLOR="#B22222">// attente (secondes)
</FONT></I>  LLint makestat_total = 0;     <I><FONT COLOR="#B22222">// repère du nombre d'octets transférés depuis denrière stat
</FONT></I>  <B><FONT COLOR="#228B22">int</FONT></B> makestat_lnk = 0;         <I><FONT COLOR="#B22222">// idem, pour le nombre de liens
</FONT></I>
  <I><FONT COLOR="#B22222">//
</FONT></I>  <B><FONT COLOR="#228B22">char</FONT></B> BIGSTK codebase[HTS_URLMAXSIZE * 2];     <I><FONT COLOR="#B22222">// base pour applet java
</FONT></I>  <B><FONT COLOR="#228B22">char</FONT></B> BIGSTK base[HTS_URLMAXSIZE * 2]; <I><FONT COLOR="#B22222">// base pour les autres fichiers
</FONT></I>
  <I><FONT COLOR="#B22222">//
</FONT></I>  cache_back BIGSTK cache;
  robots_wizard BIGSTK robots;  <I><FONT COLOR="#B22222">// gestion robots.txt
</FONT></I>  coucal cache_hashtable = NULL;
  coucal cache_tests = NULL;

  <I><FONT COLOR="#B22222">//
</FONT></I>  <B><FONT COLOR="#228B22">char</FONT></B> *template_header = NULL, *template_body = NULL, *template_footer = NULL;

  <I><FONT COLOR="#B22222">//
</FONT></I>  codebase[0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
  base[0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
  <I><FONT COLOR="#B22222">//
</FONT></I>  cookie.auth.next = NULL;
  cookie.auth.auth[0] = cookie.auth.prefix[0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
  <I><FONT COLOR="#B22222">//
</FONT></I>
  <I><FONT COLOR="#B22222">// noter heure actuelle de départ en secondes
</FONT></I>  memset(&amp;HTS_STAT, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(HTS_STAT));
  HTS_STAT.stat_timestart = time_local();
  <I><FONT COLOR="#B22222">//istat_timestart=stat_timestart;
</FONT></I>  HTS_STAT.istat_timestart[0] = HTS_STAT.istat_timestart[1] = mtime_local();
  <I><FONT COLOR="#B22222">/* reset stats */</FONT></I>
  HTS_STAT.HTS_TOTAL_RECV = 0;
  HTS_STAT.istat_bytes[0] = HTS_STAT.istat_bytes[1] = 0;
  <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;shell) {
    last_info_shell = HTS_STAT.stat_timestart;
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> ((opt-&gt;makestat) || (opt-&gt;maketrack)) {
    makestat_time = HTS_STAT.stat_timestart;
  }
  <I><FONT COLOR="#B22222">// init external modules
</FONT></I>  htspe_init();

  <I><FONT COLOR="#B22222">// initialiser cookie
</FONT></I>  <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;accept_cookie) {
    opt-&gt;cookie = &amp;cookie;
    cookie.max_len = 30000;     <I><FONT COLOR="#B22222">// max len
</FONT></I>    strcpybuff(cookie.data, <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>);
    <I><FONT COLOR="#B22222">// Charger cookies.txt par défaut ou cookies.txt du miroir
</FONT></I>    cookie_load(opt-&gt;cookie, StringBuff(opt-&gt;path_log), <B><FONT COLOR="#BC8F8F">&quot;cookies.txt&quot;</FONT></B>);
    cookie_load(opt-&gt;cookie, <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;cookies.txt&quot;</FONT></B>);
  } <B><FONT COLOR="#A020F0">else</FONT></B>
    opt-&gt;cookie = NULL;

  <I><FONT COLOR="#B22222">// initialiser exit_xh
</FONT></I>  opt-&gt;state.exit_xh = 0;       <I><FONT COLOR="#B22222">// sortir prématurément (var globale)
</FONT></I>
  <I><FONT COLOR="#B22222">// initialiser usercommand
</FONT></I>  usercommand(opt, opt-&gt;sys_com_exec, StringBuff(opt-&gt;sys_com), <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>);

  <I><FONT COLOR="#B22222">// initialiser structcheck
</FONT></I>  <I><FONT COLOR="#B22222">// structcheck_init(1);
</FONT></I>
  <I><FONT COLOR="#B22222">// initialiser verif_backblue
</FONT></I>  verif_backblue(opt, NULL);
  verif_external(opt, 0, 0);
  verif_external(opt, 1, 0);

  <I><FONT COLOR="#B22222">// et templates html
</FONT></I>  template_header =
    readfile_or(fconcat
                (OPT_GET_BUFF(opt), OPT_GET_BUFF_SIZE(opt), StringBuff(opt-&gt;path_bin),
                 <B><FONT COLOR="#BC8F8F">&quot;templates/index-header.html&quot;</FONT></B>), HTS_INDEX_HEADER);
  template_body =
    readfile_or(fconcat
                (OPT_GET_BUFF(opt), OPT_GET_BUFF_SIZE(opt), StringBuff(opt-&gt;path_bin),
                 <B><FONT COLOR="#BC8F8F">&quot;templates/index-body.html&quot;</FONT></B>), HTS_INDEX_BODY);
  template_footer =
    readfile_or(fconcat
                (OPT_GET_BUFF(opt), OPT_GET_BUFF_SIZE(opt), StringBuff(opt-&gt;path_bin),
                 <B><FONT COLOR="#BC8F8F">&quot;templates/index-footer.html&quot;</FONT></B>), HTS_INDEX_FOOTER);

  <I><FONT COLOR="#B22222">// initialiser mimedefs
</FONT></I>  <I><FONT COLOR="#B22222">//get_userhttptype(opt,1,StringBuff(opt-&gt;mimedefs),NULL);
</FONT></I>
  <I><FONT COLOR="#B22222">// Initialiser indexation
</FONT></I>  <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;kindex)
    index_init(StringBuff(opt-&gt;path_html));

  <I><FONT COLOR="#B22222">// effacer bloc cache
</FONT></I>  memset(&amp;cache, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(cache_back));
  cache.type = opt-&gt;cache;      <I><FONT COLOR="#B22222">// cache?
</FONT></I>  cache.errlog = cache.log = opt-&gt;log;  <I><FONT COLOR="#B22222">// err log?
</FONT></I>  cache.ptr_ant = cache.ptr_last = 0;   <I><FONT COLOR="#B22222">// pointeur pour anticiper
</FONT></I>
  <I><FONT COLOR="#B22222">// initialiser hash cache
</FONT></I>  cache_hashtable = coucal_new(0);
  cache_tests = coucal_new(0);
  <B><FONT COLOR="#A020F0">if</FONT></B> (cache_hashtable == NULL || cache_tests == NULL) {
    printf(<B><FONT COLOR="#BC8F8F">&quot;PANIC! : Not enough memory [%d]\n&quot;</FONT></B>, __LINE__);
    filters[0] = NULL;          <I><FONT COLOR="#B22222">// uniquement a cause du warning de XH_extuninit
</FONT></I>    XH_extuninit;
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
  }
  hts_set_hash_handler(cache_hashtable, opt);
  hts_set_hash_handler(cache_tests, opt);
  coucal_set_name(cache_hashtable, <B><FONT COLOR="#BC8F8F">&quot;cache_hashtable&quot;</FONT></B>);
  coucal_set_name(cache_tests, <B><FONT COLOR="#BC8F8F">&quot;cache_tests&quot;</FONT></B>);
  coucal_value_is_malloc(cache_tests, 1);      <I><FONT COLOR="#B22222">/* malloc */</FONT></I>
  cache.hashtable = (<B><FONT COLOR="#228B22">void</FONT></B> *) cache_hashtable;   <I><FONT COLOR="#B22222">/* copy backcache hash */</FONT></I>
  cache.cached_tests = (<B><FONT COLOR="#228B22">void</FONT></B> *) cache_tests;    <I><FONT COLOR="#B22222">/* copy of cache_tests */</FONT></I>

  <I><FONT COLOR="#B22222">// robots.txt
</FONT></I>  strcpybuff(robots.adr, <B><FONT COLOR="#BC8F8F">&quot;!&quot;</FONT></B>);  <I><FONT COLOR="#B22222">// dummy
</FONT></I>  robots.token[0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
  robots.next = NULL;           <I><FONT COLOR="#B22222">// suivant
</FONT></I>  opt-&gt;robotsptr = &amp;robots;

  <I><FONT COLOR="#B22222">// effacer filters
</FONT></I>  opt-&gt;maxfilter = maximum(opt-&gt;maxfilter, 128);
  <B><FONT COLOR="#A020F0">if</FONT></B> (filters_init(&amp;filters, opt-&gt;maxfilter, 0) == 0) {
    printf(<B><FONT COLOR="#BC8F8F">&quot;PANIC! : Not enough memory [%d]\n&quot;</FONT></B>, __LINE__);
    XH_extuninit;
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
  }
  opt-&gt;filters.filters = &amp;filters;
  <I><FONT COLOR="#B22222">//
</FONT></I>  opt-&gt;filters.filptr = &amp;filptr;
  <I><FONT COLOR="#B22222">//opt-&gt;filters.filter_max=&amp;filter_max;
</FONT></I>
  <I><FONT COLOR="#B22222">// hash table
</FONT></I>  opt-&gt;hash = &amp;hash;

  <I><FONT COLOR="#B22222">// initialize link heap
</FONT></I>  hts_record_init(opt);

  <I><FONT COLOR="#B22222">// initialiser ptr et lien_tot
</FONT></I>  ptr = 0;

  <I><FONT COLOR="#B22222">// initialiser hachage
</FONT></I>  hash_init(opt, &amp;hash, opt-&gt;urlhack);
  <I><FONT COLOR="#B22222">// note: we need a cast because of the const
</FONT></I>  hash.liens = (<B><FONT COLOR="#228B22">const</FONT></B> lien_url *<B><FONT COLOR="#228B22">const</FONT></B>*<B><FONT COLOR="#228B22">const</FONT></B>*) &amp;opt-&gt;liens;

  <I><FONT COLOR="#B22222">// copier adresse(s) dans liste des adresses
</FONT></I>  {
    <B><FONT COLOR="#228B22">char</FONT></B> *a = url1;
    <B><FONT COLOR="#228B22">int</FONT></B> primary_len = 8192;

    <B><FONT COLOR="#A020F0">if</FONT></B> (StringNotEmpty(opt-&gt;filelist)) {
      primary_len += max(0, fsize(StringBuff(opt-&gt;filelist)) * 2);
    }
    primary_len += (<B><FONT COLOR="#228B22">int</FONT></B>) strlen(url1) * 2;

    <I><FONT COLOR="#B22222">// création de la première page, qui contient les liens de base à scanner
</FONT></I>    <I><FONT COLOR="#B22222">// c'est plus propre et plus logique que d'entrer à la main les liens dans la pile
</FONT></I>    <I><FONT COLOR="#B22222">// on bénéficie ainsi des vérifications et des tests du robot pour les liens &quot;primaires&quot;
</FONT></I>    primary = (<B><FONT COLOR="#228B22">char</FONT></B> *) malloct(primary_len);
    <B><FONT COLOR="#A020F0">if</FONT></B> (primary) {
      primary[0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
    } <B><FONT COLOR="#A020F0">else</FONT></B> {
      printf(<B><FONT COLOR="#BC8F8F">&quot;PANIC! : Not enough memory [%d]\n&quot;</FONT></B>, __LINE__);
      XH_extuninit;
      <B><FONT COLOR="#A020F0">return</FONT></B> 0;
    }

    <B><FONT COLOR="#A020F0">while</FONT></B>(*a) {
      <B><FONT COLOR="#228B22">int</FONT></B> i;
      <B><FONT COLOR="#228B22">int</FONT></B> joker = 0;

      <I><FONT COLOR="#B22222">// vérifier qu'il n'y a pas de * dans l'url
</FONT></I>      <B><FONT COLOR="#A020F0">if</FONT></B> (*a == <B><FONT COLOR="#BC8F8F">'+'</FONT></B>)
        joker = 1;
      <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (*a == <B><FONT COLOR="#BC8F8F">'-'</FONT></B>)
        joker = 1;

      <B><FONT COLOR="#A020F0">if</FONT></B> (joker) {              <I><FONT COLOR="#B22222">// joker ou filters
</FONT></I>        <I><FONT COLOR="#B22222">//char* p;
</FONT></I>        <B><FONT COLOR="#228B22">char</FONT></B> BIGSTK tempo[HTS_URLMAXSIZE * 2];
        <B><FONT COLOR="#228B22">int</FONT></B> type;
        <B><FONT COLOR="#228B22">int</FONT></B> plus = 0;

        <I><FONT COLOR="#B22222">// noter joker (dans b)
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (*a == <B><FONT COLOR="#BC8F8F">'+'</FONT></B>) {        <I><FONT COLOR="#B22222">// champ +
</FONT></I>          type = 1;
          plus = 1;
          a++;
        } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (*a == <B><FONT COLOR="#BC8F8F">'-'</FONT></B>) { <I><FONT COLOR="#B22222">// champ forbidden[]
</FONT></I>          type = 0;
          a++;
        } <B><FONT COLOR="#A020F0">else</FONT></B> {                <I><FONT COLOR="#B22222">// champ + avec joker sans doute
</FONT></I>          type = 1;
        }

        <I><FONT COLOR="#B22222">// recopier prochaine chaine (+ ou -)
</FONT></I>        i = 0;
        <B><FONT COLOR="#A020F0">while</FONT></B>((*a != 0) &amp;&amp; (!isspace((<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>) *a))) {
          tempo[i++] = *a;
          a++;
        }
        tempo[i++] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
        <B><FONT COLOR="#A020F0">while</FONT></B>(isspace((<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>) *a)) {
          a++;
        }

        <I><FONT COLOR="#B22222">// sauter les + sans rien après..
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (strnotempty(tempo)) {
          <B><FONT COLOR="#A020F0">if</FONT></B> ((plus == 0) &amp;&amp; (type == 1)) {     <I><FONT COLOR="#B22222">// implicite: *www.edf.fr par exemple
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B> (tempo[strlen(tempo) - 1] != <B><FONT COLOR="#BC8F8F">'*'</FONT></B>) {
              strcatbuff(tempo, <B><FONT COLOR="#BC8F8F">&quot;*&quot;</FONT></B>);   <I><FONT COLOR="#B22222">// ajouter un *
</FONT></I>            }
          }
          <B><FONT COLOR="#A020F0">if</FONT></B> (type)
            strcpybuff(filters[filptr], <B><FONT COLOR="#BC8F8F">&quot;+&quot;</FONT></B>);
          <B><FONT COLOR="#A020F0">else</FONT></B>
            strcpybuff(filters[filptr], <B><FONT COLOR="#BC8F8F">&quot;-&quot;</FONT></B>);
          strcatbuff(filters[filptr], tempo);
          filptr++;

          <I><FONT COLOR="#B22222">/* sanity check */</FONT></I>
          <B><FONT COLOR="#A020F0">if</FONT></B> (filptr + 1 &gt;= opt-&gt;maxfilter) {
            opt-&gt;maxfilter += HTS_FILTERSINC;
            <B><FONT COLOR="#A020F0">if</FONT></B> (filters_init(&amp;filters, opt-&gt;maxfilter, HTS_FILTERSINC) == 0) {
              printf(<B><FONT COLOR="#BC8F8F">&quot;PANIC! : Too many filters : &gt;%d [%d]\n&quot;</FONT></B>, filptr,
                     __LINE__);
              hts_log_print(opt, LOG_PANIC,
                            <B><FONT COLOR="#BC8F8F">&quot;Too many filters, giving up..(&gt;%d)&quot;</FONT></B>, filptr);
              hts_log_print(opt, LOG_NOTICE,
                            <B><FONT COLOR="#BC8F8F">&quot;To avoid that: use #F option for more filters (example: -#F5000)&quot;</FONT></B>);
              XH_extuninit;
              <B><FONT COLOR="#A020F0">return</FONT></B> 0;
            }
            <I><FONT COLOR="#B22222">//opt-&gt;filters.filters=filters;
</FONT></I>          }

        }

      } <B><FONT COLOR="#A020F0">else</FONT></B> {                  <I><FONT COLOR="#B22222">// adresse normale
</FONT></I>        <B><FONT COLOR="#228B22">char</FONT></B> BIGSTK url[HTS_URLMAXSIZE * 2];

        <I><FONT COLOR="#B22222">// prochaine adresse
</FONT></I>        i = 0;
        <B><FONT COLOR="#A020F0">while</FONT></B>((*a != 0) &amp;&amp; (!isspace((<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>) *a))) {
          url[i++] = *a;
          a++;
        }
        <B><FONT COLOR="#A020F0">while</FONT></B>(isspace((<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>) *a)) {
          a++;
        }
        url[i++] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;

        <I><FONT COLOR="#B22222">//strcatbuff(primary,&quot;&lt;PRIMARY=\&quot;&quot;);
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (strstr(url, <B><FONT COLOR="#BC8F8F">&quot;:/&quot;</FONT></B>) == NULL)
          strcatbuff(primary, <B><FONT COLOR="#BC8F8F">&quot;http://&quot;</FONT></B>);
        strcatbuff(primary, url);
        <I><FONT COLOR="#B22222">//strcatbuff(primary,&quot;\&quot;&gt;&quot;);
</FONT></I>        strcatbuff(primary, <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>);
      }
    }                           <I><FONT COLOR="#B22222">// while
</FONT></I>
    <I><FONT COLOR="#B22222">/* load URL file list */</FONT></I>
    <I><FONT COLOR="#B22222">/* OPTIMIZED for fast load */</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B> (StringNotEmpty(opt-&gt;filelist)) {
      <B><FONT COLOR="#228B22">char</FONT></B> *filelist_buff = NULL;
      <B><FONT COLOR="#228B22">const</FONT></B> size_t filelist_sz = off_t_to_size_t(fsize(StringBuff(opt-&gt;filelist)));

      <B><FONT COLOR="#A020F0">if</FONT></B> (filelist_sz != (size_t) -1) {
        FILE *fp = fopen(StringBuff(opt-&gt;filelist), <B><FONT COLOR="#BC8F8F">&quot;rb&quot;</FONT></B>);

        <B><FONT COLOR="#A020F0">if</FONT></B> (fp) {
          filelist_buff = malloct(filelist_sz + 1);
          <B><FONT COLOR="#A020F0">if</FONT></B> (filelist_buff) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (fread(filelist_buff, 1, filelist_sz, fp) != filelist_sz) {
              freet(filelist_buff);
              filelist_buff = NULL;
            } <B><FONT COLOR="#A020F0">else</FONT></B> {
              *(filelist_buff + filelist_sz) = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
            }
          }
          fclose(fp);
        }
      }

      <B><FONT COLOR="#A020F0">if</FONT></B> (filelist_buff) {
        <B><FONT COLOR="#228B22">int</FONT></B> filelist_ptr = 0;
        <B><FONT COLOR="#228B22">int</FONT></B> n = 0;
        <B><FONT COLOR="#228B22">char</FONT></B> BIGSTK line[HTS_URLMAXSIZE * 2];
        <B><FONT COLOR="#228B22">char</FONT></B> *primary_ptr = primary + strlen(primary);

        <B><FONT COLOR="#A020F0">while</FONT></B>(filelist_ptr &lt; filelist_sz) {
          <B><FONT COLOR="#228B22">int</FONT></B> count =
            binput(filelist_buff + filelist_ptr, line, HTS_URLMAXSIZE);
          filelist_ptr += count;
          <B><FONT COLOR="#A020F0">if</FONT></B> (count &amp;&amp; line[0]) {
            n++;
            <B><FONT COLOR="#A020F0">if</FONT></B> (strstr(line, <B><FONT COLOR="#BC8F8F">&quot;:/&quot;</FONT></B>) == NULL) {
              strcpybuff(primary_ptr, <B><FONT COLOR="#BC8F8F">&quot;http://&quot;</FONT></B>);
              primary_ptr += strlen(primary_ptr);
            }
            strcpybuff(primary_ptr, line);
            primary_ptr += strlen(primary_ptr);
            strcpybuff(primary_ptr, <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>);
            primary_ptr += 1;
          }
        }
        <I><FONT COLOR="#B22222">// fclose(fp);
</FONT></I>        hts_log_print(opt, LOG_NOTICE, <B><FONT COLOR="#BC8F8F">&quot;%d links added from %s&quot;</FONT></B>, n,
                      StringBuff(opt-&gt;filelist));

        <I><FONT COLOR="#B22222">// Free buffer
</FONT></I>        freet(filelist_buff);
      } <B><FONT COLOR="#A020F0">else</FONT></B> {
        hts_log_print(opt, LOG_ERROR, <B><FONT COLOR="#BC8F8F">&quot;Could not include URL list: %s&quot;</FONT></B>,
                      StringBuff(opt-&gt;filelist));
      }
    }

    <I><FONT COLOR="#B22222">// lien primaire
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B> (!hts_record_link(opt, <B><FONT COLOR="#BC8F8F">&quot;primary&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;/primary&quot;</FONT></B>,
                        fslash(OPT_GET_BUFF(opt), OPT_GET_BUFF_SIZE(opt),
                        fconcat(OPT_GET_BUFF(opt), OPT_GET_BUFF_SIZE(opt),
                        StringBuff(opt-&gt;path_html_utf8), <B><FONT COLOR="#BC8F8F">&quot;index.html&quot;</FONT></B>)),
                        <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>, NULL)) {
      XH_extuninit;             <I><FONT COLOR="#B22222">// désallocation mémoire &amp; buffers
</FONT></I>      <B><FONT COLOR="#A020F0">return</FONT></B> 0;
    }
    heap_top()-&gt;testmode = 0;      <I><FONT COLOR="#B22222">// pas mode test
</FONT></I>    heap_top()-&gt;link_import = 0;   <I><FONT COLOR="#B22222">// pas mode import
</FONT></I>    heap_top()-&gt;depth = opt-&gt;depth + 1;    <I><FONT COLOR="#B22222">// lien de priorité maximale
</FONT></I>    heap_top()-&gt;pass2 = 0; <I><FONT COLOR="#B22222">// 1ère passe
</FONT></I>    heap_top()-&gt;retry = opt-&gt;retry;        <I><FONT COLOR="#B22222">// lien de priorité maximale
</FONT></I>    heap_top()-&gt;premier = heap_top_index();        <I><FONT COLOR="#B22222">// premier lien, objet-père=objet              
</FONT></I>    heap_top()-&gt;precedent = heap_top_index();      <I><FONT COLOR="#B22222">// lien précédent
</FONT></I>
    <I><FONT COLOR="#B22222">// Initialiser cache
</FONT></I>    {
      opt-&gt;state._hts_in_html_parsing = 4;
      <B><FONT COLOR="#A020F0">if</FONT></B> (!RUN_CALLBACK7(opt, loop, NULL, 0, 0, 0, opt-&gt;lien_tot, 0, NULL)) {
        opt-&gt;state.exit_xh = 1; <I><FONT COLOR="#B22222">// exit requested
</FONT></I>      }
      cache_init(&amp;cache, opt);
      opt-&gt;state._hts_in_html_parsing = 0;
    }

  }

#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">BDEBUG</FONT>==3
  {
    <B><FONT COLOR="#228B22">int</FONT></B> i;

    <B><FONT COLOR="#A020F0">for</FONT></B>(i = 0; i &lt; lien_tot; i++) {
      printf(<B><FONT COLOR="#BC8F8F">&quot;%d&gt;%s%s as %s\n&quot;</FONT></B>, i, heap(i)-&gt;adr, heap(i)-&gt;fil, heap(i)-&gt;sav);
    }
    <B><FONT COLOR="#A020F0">for</FONT></B>(i = 0; i &lt; filptr; i++) {
      printf(<B><FONT COLOR="#BC8F8F">&quot;%d&gt;filters=%s\n&quot;</FONT></B>, i, filters[i]);
    }
  }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

  <I><FONT COLOR="#B22222">// backing
</FONT></I>  <I><FONT COLOR="#B22222">//soc_max=opt-&gt;maxsoc;
</FONT></I>  <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;maxsoc &gt; 0) {
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">BDEBUG</FONT>==2
    _CLRSCR;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    <I><FONT COLOR="#B22222">// Nombre de fichiers HTML pouvant être présents en mémoire de manière simultannée
</FONT></I>    <I><FONT COLOR="#B22222">// On prévoit large: les fichiers HTML ne prennent que peu de place en mémoire, et les
</FONT></I>    <I><FONT COLOR="#B22222">// fichiers non html sont sauvés en direct sur disque.
</FONT></I>    <I><FONT COLOR="#B22222">// --&gt; 1024 entrées + 32 entrées par socket en supplément
</FONT></I>    sback = back_new(opt, opt-&gt;maxsoc * 32 + 1024);
    <B><FONT COLOR="#A020F0">if</FONT></B> (sback == NULL) {
      hts_log_print(opt, LOG_PANIC,
                    <B><FONT COLOR="#BC8F8F">&quot;Not enough memory, can not allocate %d bytes&quot;</FONT></B>,
                    (<B><FONT COLOR="#228B22">int</FONT></B>) ((opt-&gt;maxsoc + 1) * <B><FONT COLOR="#A020F0">sizeof</FONT></B>(lien_back)));
      <B><FONT COLOR="#A020F0">return</FONT></B> 0;
    }
  }
  <I><FONT COLOR="#B22222">// statistiques
</FONT></I>  <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;makestat) {
    makestat_fp =
      fopen(fconcat
            (OPT_GET_BUFF(opt), OPT_GET_BUFF_SIZE(opt), StringBuff(opt-&gt;path_log), <B><FONT COLOR="#BC8F8F">&quot;hts-stats.txt&quot;</FONT></B>),
            <B><FONT COLOR="#BC8F8F">&quot;wb&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">if</FONT></B> (makestat_fp != NULL) {
      fprintf(makestat_fp, <B><FONT COLOR="#BC8F8F">&quot;HTTrack statistics report, every minutes&quot;</FONT></B> LF LF);
      fflush(makestat_fp);
    }
  }
  <I><FONT COLOR="#B22222">// tracking -- débuggage
</FONT></I>  <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;maketrack) {
    maketrack_fp =
      fopen(fconcat
            (OPT_GET_BUFF(opt), OPT_GET_BUFF_SIZE(opt), StringBuff(opt-&gt;path_log), <B><FONT COLOR="#BC8F8F">&quot;hts-track.txt&quot;</FONT></B>),
            <B><FONT COLOR="#BC8F8F">&quot;wb&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">if</FONT></B> (maketrack_fp != NULL) {
      fprintf(maketrack_fp, <B><FONT COLOR="#BC8F8F">&quot;HTTrack tracking report, every minutes&quot;</FONT></B> LF LF);
      fflush(maketrack_fp);
    }
  }
  <I><FONT COLOR="#B22222">// on n'a pas de liens!! (exemple: httrack www.* impossible sans départ..)
</FONT></I>  <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;lien_tot &lt;= 0) {
    hts_log_print(opt, LOG_ERROR,
                  <B><FONT COLOR="#BC8F8F">&quot;You MUST specify at least one complete URL, and not only wildcards!&quot;</FONT></B>);
  }

  <I><FONT COLOR="#B22222">/* Send options to callback functions */</FONT></I>
  RUN_CALLBACK0(opt, chopt);

  <I><FONT COLOR="#B22222">// attendre une certaine heure..
</FONT></I>  <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;waittime &gt; 0) {
    <B><FONT COLOR="#228B22">int</FONT></B> rollover = 0;
    <B><FONT COLOR="#228B22">int</FONT></B> ok = 0;

    {
      TStamp tl = 0;
      time_t tt;
      <B><FONT COLOR="#228B22">struct</FONT></B> tm *A;

      tt = time(NULL);
      A = localtime(&amp;tt);
      tl += A-&gt;tm_sec;
      tl += A-&gt;tm_min * 60;
      tl += A-&gt;tm_hour * 60 * 60;
      <B><FONT COLOR="#A020F0">if</FONT></B> (tl &gt; opt-&gt;waittime)   <I><FONT COLOR="#B22222">// attendre minuit
</FONT></I>        rollover = 1;
    }

    <I><FONT COLOR="#B22222">// attendre..
</FONT></I>    opt-&gt;state._hts_in_html_parsing = 5;
    <B><FONT COLOR="#A020F0">do</FONT></B> {
      TStamp tl = 0;
      time_t tt;
      <B><FONT COLOR="#228B22">struct</FONT></B> tm *A;

      tt = time(NULL);
      A = localtime(&amp;tt);
      tl += A-&gt;tm_sec;
      tl += A-&gt;tm_min * 60;
      tl += A-&gt;tm_hour * 60 * 60;

      <B><FONT COLOR="#A020F0">if</FONT></B> (rollover) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (tl &lt;= opt-&gt;waittime)
          rollover = 0;         <I><FONT COLOR="#B22222">// attendre heure
</FONT></I>      } <B><FONT COLOR="#A020F0">else</FONT></B> {
        <B><FONT COLOR="#A020F0">if</FONT></B> (tl &gt; opt-&gt;waittime)
          ok = 1;               <I><FONT COLOR="#B22222">// ok!
</FONT></I>      }

      {
        <B><FONT COLOR="#228B22">int</FONT></B> r;

        <B><FONT COLOR="#A020F0">if</FONT></B> (rollover)
          r =
            RUN_CALLBACK7(opt, loop, sback-&gt;lnk, sback-&gt;count, 0, 0, opt-&gt;lien_tot,
                          (<B><FONT COLOR="#228B22">int</FONT></B>) (opt-&gt;waittime - tl + 24 * 3600), NULL);
        <B><FONT COLOR="#A020F0">else</FONT></B>
          r =
            RUN_CALLBACK7(opt, loop, sback-&gt;lnk, sback-&gt;count, 0, 0, opt-&gt;lien_tot,
                          (<B><FONT COLOR="#228B22">int</FONT></B>) (opt-&gt;waittime - tl), NULL);
        <B><FONT COLOR="#A020F0">if</FONT></B> (!r) {
          opt-&gt;state.exit_xh = 1;       <I><FONT COLOR="#B22222">// exit requested
</FONT></I>          ok = 1;
        } <B><FONT COLOR="#A020F0">else</FONT></B>
          Sleep(100);
      }

    } <B><FONT COLOR="#A020F0">while</FONT></B>(!ok);
    opt-&gt;state._hts_in_html_parsing = 0;

    <I><FONT COLOR="#B22222">// note: recopie de plus haut
</FONT></I>    <I><FONT COLOR="#B22222">// noter heure actuelle de départ en secondes
</FONT></I>    HTS_STAT.stat_timestart = time_local();
    <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;shell) {
      last_info_shell = HTS_STAT.stat_timestart;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> ((opt-&gt;makestat) || (opt-&gt;maketrack)) {
      makestat_time = HTS_STAT.stat_timestart;
    }

  }
  <I><FONT COLOR="#B22222">/* Info for wrappers */</FONT></I>
  hts_log_print(opt, LOG_INFO, <B><FONT COLOR="#BC8F8F">&quot;engine: start&quot;</FONT></B>);
  <B><FONT COLOR="#A020F0">if</FONT></B> (!RUN_CALLBACK0(opt, start)) {
    XH_extuninit;
    <B><FONT COLOR="#A020F0">return</FONT></B> 1;
  }
  <I><FONT COLOR="#B22222">// ------------------------------------------------------------
</FONT></I>
  <I><FONT COLOR="#B22222">// ------------------------------------------------------------
</FONT></I>  <I><FONT COLOR="#B22222">// Boucle générale de parcours des liens
</FONT></I>  <I><FONT COLOR="#B22222">// ------------------------------------------------------------
</FONT></I>  <B><FONT COLOR="#A020F0">do</FONT></B> {
    <B><FONT COLOR="#228B22">int</FONT></B> error = 0;              <I><FONT COLOR="#B22222">// si error alors sauter
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> store_errpage = 0;      <I><FONT COLOR="#B22222">// c'est une erreur mais on enregistre le html
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> is_binary = 0;          <I><FONT COLOR="#B22222">// is a binary file
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> is_loaded_from_file = 0;        <I><FONT COLOR="#B22222">// has been loaded from a file (implies is_write=1)
</FONT></I>    <B><FONT COLOR="#228B22">char</FONT></B> BIGSTK loc[HTS_URLMAXSIZE * 2];        <I><FONT COLOR="#B22222">// adresse de relocation
</FONT></I>
    <I><FONT COLOR="#B22222">// Ici on charge le fichier (html, gif..) en mémoire
</FONT></I>    <I><FONT COLOR="#B22222">// Les HTMLs sont traités (si leur priorité est suffisante)
</FONT></I>
    <I><FONT COLOR="#B22222">// effacer r
</FONT></I>    hts_init_htsblk(&amp;r);
    <I><FONT COLOR="#B22222">//memset(&amp;r, 0, sizeof(htsblk)); r.soc=INVALID_SOCKET;
</FONT></I>    r.location = loc;           <I><FONT COLOR="#B22222">// en cas d'erreur 3xx (moved)
</FONT></I>    <I><FONT COLOR="#B22222">// recopier proxy
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B> ((r.req.proxy.active = opt-&gt;proxy.active)) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (StringBuff(opt-&gt;proxy.bindhost) != NULL)
        r.req.proxy.bindhost = StringBuff(opt-&gt;proxy.bindhost);
      <B><FONT COLOR="#A020F0">if</FONT></B> (StringBuff(opt-&gt;proxy.name) != NULL)
        r.req.proxy.name = StringBuff(opt-&gt;proxy.name);
      r.req.proxy.port = opt-&gt;proxy.port;
    }
    <I><FONT COLOR="#B22222">// et user-agent
</FONT></I>    r.req.user_agent = StringBuff(opt-&gt;user_agent);
    r.req.referer = StringBuff(opt-&gt;referer);
    r.req.from = StringBuff(opt-&gt;from);
    r.req.lang_iso = StringBuff(opt-&gt;lang_iso);
    r.req.accept = StringBuff(opt-&gt;accept);
    r.req.headers = StringBuff(opt-&gt;headers);
    r.req.user_agent_send = opt-&gt;user_agent_send;

    <B><FONT COLOR="#A020F0">if</FONT></B> (!error) {

      <I><FONT COLOR="#B22222">// Skip empty/invalid/done in background
</FONT></I>      <B><FONT COLOR="#A020F0">if</FONT></B> (heap(ptr)) {
        <B><FONT COLOR="#A020F0">while</FONT></B>(ptr &lt; opt-&gt;lien_tot
              &amp;&amp; (heap(ptr))
              &amp;&amp; ((((urladr() != NULL) ? (urladr()) : (<B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>))[0] == <B><FONT COLOR="#BC8F8F">'!'</FONT></B>)
                  || (((urlfil() != NULL) ? (urlfil()) : (<B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>))[0] == <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>)
                  || ((heap(ptr)-&gt;pass2 == -1))
              )
          ) {                   <I><FONT COLOR="#B22222">// sauter si lien annulé (ou fil vide)
</FONT></I>          <B><FONT COLOR="#A020F0">if</FONT></B> (heap(ptr) != NULL &amp;&amp; heap(ptr)-&gt;pass2 == -1) {
            hts_log_print(opt, LOG_DEBUG, <B><FONT COLOR="#BC8F8F">&quot;link #%d is ready, skipping: %s%s..&quot;</FONT></B>,
                          ptr, ((urladr() != NULL) ? (urladr()) : (<B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>)),
                          ((urlfil() != NULL) ? (urlfil()) : (<B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>)));
          } <B><FONT COLOR="#A020F0">else</FONT></B> {
            hts_log_print(opt, LOG_DEBUG,
                          <B><FONT COLOR="#BC8F8F">&quot;link #%d seems ready, skipping: %s%s..&quot;</FONT></B>, ptr,
                          ((urladr() != NULL) ? (urladr()) : (<B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>)),
                          ((urlfil() != NULL) ? (urlfil()) : (<B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>)));
          }
          <I><FONT COLOR="#B22222">// remove from stats
</FONT></I>          <B><FONT COLOR="#A020F0">if</FONT></B> (heap(ptr)-&gt;pass2 == -1) {
            HTS_STAT.stat_background--;
          }
          ptr++;
        }
        <I><FONT COLOR="#B22222">// We're done!
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (ptr == opt-&gt;lien_tot) {
          <B><FONT COLOR="#A020F0">goto</FONT></B> <B><FONT COLOR="#5F9EA0">jump_if_done</FONT></B>;
        }
      }
      <B><FONT COLOR="#A020F0">if</FONT></B> (heap(ptr) != NULL) { <I><FONT COLOR="#B22222">// on a qq chose à récupérer?
</FONT></I>
        hts_log_print(opt, LOG_DEBUG, <B><FONT COLOR="#BC8F8F">&quot;Wait get: %s%s&quot;</FONT></B>, urladr(), urlfil());
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">DEBUG_ROBOTS</FONT>
        <B><FONT COLOR="#A020F0">if</FONT></B> (strcmp(urlfil(), <B><FONT COLOR="#BC8F8F">&quot;/robots.txt&quot;</FONT></B>) == 0) {
          printf(<B><FONT COLOR="#BC8F8F">&quot;robots.txt detected\n&quot;</FONT></B>);
        }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
        <I><FONT COLOR="#B22222">// ------------------------------------------------------------
</FONT></I>        <I><FONT COLOR="#B22222">// DEBUT --RECUPERATION LIEN---
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (ptr == 0) {         <I><FONT COLOR="#B22222">// premier lien à parcourir: lien primaire construit avant
</FONT></I>          r.adr = primary;
          primary = NULL;
          r.statuscode = HTTP_OK;
          r.size = strlen(r.adr);
          r.soc = INVALID_SOCKET;
          strcpybuff(r.contenttype, <B><FONT COLOR="#BC8F8F">&quot;text/html&quot;</FONT></B>);
          <I><FONT COLOR="#B22222">/*} else if (opt-&gt;maxsoc&lt;=0) {   // fichiers 1 à 1 en attente (pas de backing)
             // charger le fichier en mémoire tout bêtement
             r=xhttpget(urladr(),urlfil());
             //
           */</FONT></I>
        } <B><FONT COLOR="#A020F0">else</FONT></B> {                <I><FONT COLOR="#B22222">// backing, multiples sockets
</FONT></I>          <I><FONT COLOR="#B22222">/*
           **************************************
           Get the next link, waiting for other files, handling external callbacks
           */</FONT></I>
          {
            <B><FONT COLOR="#228B22">char</FONT></B> BIGSTK buff_err_msg[1024];
            htsmoduleStruct BIGSTK str;
            htsmoduleStructExtended BIGSTK stre;

            buff_err_msg[0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
            memset(&amp;str, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(str));
            memset(&amp;stre, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(stre));
            <I><FONT COLOR="#B22222">/* */</FONT></I>
            str.err_msg = buff_err_msg;
            str.filename = savename();
            str.mime = r.contenttype;
            str.url_host = urladr();
            str.url_file = urlfil();
            str.size = (<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>) r.size;
            <I><FONT COLOR="#B22222">/* */</FONT></I>
            str.addLink = htsAddLink;
            <I><FONT COLOR="#B22222">/* */</FONT></I>
            str.opt = opt;
            str.sback = sback;
            str.cache = &amp;cache;
            str.hashptr = hashptr;
            str.numero_passe = numero_passe;
            <I><FONT COLOR="#B22222">/* */</FONT></I>
            str.ptr_ = &amp;ptr;
            <I><FONT COLOR="#B22222">/* */</FONT></I>
            str.page_charset_ = NULL;
            <I><FONT COLOR="#B22222">/* */</FONT></I>
            <I><FONT COLOR="#B22222">/* */</FONT></I>
            stre.r_ = &amp;r;
            <I><FONT COLOR="#B22222">/* */</FONT></I>
            stre.error_ = &amp;error;
            stre.exit_xh_ = &amp;opt-&gt;state.exit_xh;
            stre.store_errpage_ = &amp;store_errpage;
            <I><FONT COLOR="#B22222">/* */</FONT></I>
            stre.base = base;
            stre.codebase = codebase;
            <I><FONT COLOR="#B22222">/* */</FONT></I>
            stre.filters_ = &amp;filters;
            stre.filptr_ = &amp;filptr;
            stre.robots_ = &amp;robots;
            stre.hash_ = &amp;hash;
            <I><FONT COLOR="#B22222">/* */</FONT></I>
            stre.makeindex_done_ = &amp;makeindex_done;
            stre.makeindex_fp_ = &amp;makeindex_fp;
            stre.makeindex_links_ = &amp;makeindex_links;
            stre.makeindex_firstlink_ = makeindex_firstlink;
            <I><FONT COLOR="#B22222">/* */</FONT></I>
            stre.template_header_ = template_header;
            stre.template_body_ = template_body;
            stre.template_footer_ = template_footer;
            <I><FONT COLOR="#B22222">/* */</FONT></I>
            stre.stat_fragment_ = &amp;stat_fragment;
            stre.makestat_time = makestat_time;
            stre.makestat_fp = makestat_fp;
            stre.makestat_total_ = &amp;makestat_total;
            stre.makestat_lnk_ = &amp;makestat_lnk;
            stre.maketrack_fp = maketrack_fp;
            <I><FONT COLOR="#B22222">/* FUNCTION DEPENDANT */</FONT></I>
            stre.loc_ = loc;
            stre.last_info_shell_ = &amp;last_info_shell;
            stre.info_shell_ = &amp;info_shell;

            <I><FONT COLOR="#B22222">/* Parse */</FONT></I>
            <B><FONT COLOR="#A020F0">switch</FONT></B> (hts_mirror_wait_for_next_file(&amp;str, &amp;stre)) {
            <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">-1</FONT></B>:
              XH_uninit;
              <B><FONT COLOR="#A020F0">return</FONT></B> -1;
              <B><FONT COLOR="#A020F0">break</FONT></B>;
            <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">2</FONT></B>:
              <I><FONT COLOR="#B22222">// Jump to 'continue'
</FONT></I>              <I><FONT COLOR="#B22222">// This is one of the very very rare cases where goto
</FONT></I>              <I><FONT COLOR="#B22222">// is acceptable
</FONT></I>              <I><FONT COLOR="#B22222">// A supplemental flag and if( ) { } would be really messy
</FONT></I>              <B><FONT COLOR="#A020F0">goto</FONT></B> <B><FONT COLOR="#5F9EA0">jump_if_done</FONT></B>;
            }

          }

        }
        <I><FONT COLOR="#B22222">// FIN --RECUPERATION LIEN--- 
</FONT></I>        <I><FONT COLOR="#B22222">// ------------------------------------------------------------
</FONT></I>
      } <B><FONT COLOR="#A020F0">else</FONT></B> {                  <I><FONT COLOR="#B22222">// lien vide..
</FONT></I>        hts_log_print(opt, LOG_WARNING, <B><FONT COLOR="#BC8F8F">&quot;Warning, link #%d empty&quot;</FONT></B>, ptr);
        error = 1;
        <B><FONT COLOR="#A020F0">goto</FONT></B> <B><FONT COLOR="#5F9EA0">jump_if_done</FONT></B>;
      }                         <I><FONT COLOR="#B22222">// test si url existe (non vide!)
</FONT></I>
      <I><FONT COLOR="#B22222">// ---tester taille a posteriori---
</FONT></I>      <I><FONT COLOR="#B22222">// tester r.adr
</FONT></I>      <B><FONT COLOR="#A020F0">if</FONT></B> (!error) {
        <I><FONT COLOR="#B22222">// erreur, pas de fichier chargé:
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> ((!r.adr) &amp;&amp; (r.is_write == 0)
            &amp;&amp; (r.statuscode != 301)
            &amp;&amp; (r.statuscode != 302)
            &amp;&amp; (r.statuscode != 303)
            &amp;&amp; (r.statuscode != 307)
            &amp;&amp; (r.statuscode != 412)
            &amp;&amp; (r.statuscode != 416)
          ) {
          <I><FONT COLOR="#B22222">// error=1;
</FONT></I>
          <I><FONT COLOR="#B22222">// peut être que le fichier était trop gros?
</FONT></I>          <B><FONT COLOR="#A020F0">if</FONT></B> ((istoobig
               (opt, r.totalsize, opt-&gt;maxfile_html, opt-&gt;maxfile_nonhtml,
                r.contenttype))
              ||
              (istoobig
               (opt, r.totalsize, opt-&gt;maxfile_html, opt-&gt;maxfile_nonhtml,
                r.contenttype))) {
            error = 0;
            hts_log_print(opt, LOG_WARNING,
                          <B><FONT COLOR="#BC8F8F">&quot;Big file cancelled according to user's preferences: %s%s&quot;</FONT></B>,
                          urladr(), urlfil());
          }
          <I><FONT COLOR="#B22222">// // // error=1;    // ne pas traiter la suite -- euhh si finalement..
</FONT></I>        }
      }
      <I><FONT COLOR="#B22222">// ---fin tester taille a posteriori---    
</FONT></I>
      <I><FONT COLOR="#B22222">// -------------------- 
</FONT></I>      <I><FONT COLOR="#B22222">// BOGUS MIME TYPE HACK
</FONT></I>      <I><FONT COLOR="#B22222">// Check if we have a bogus MIME type
</FONT></I>      <I><FONT COLOR="#B22222">// example: 
</FONT></I>      <I><FONT COLOR="#B22222">// Content-type=&quot;text/html&quot;
</FONT></I>      <I><FONT COLOR="#B22222">// and 
</FONT></I>      <I><FONT COLOR="#B22222">// Content-disposition=&quot;foo.jpg&quot;
</FONT></I>      <I><FONT COLOR="#B22222">// --------------------
</FONT></I>      <B><FONT COLOR="#A020F0">if</FONT></B> (!error) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (r.statuscode == HTTP_OK) {  <I><FONT COLOR="#B22222">// OK (ou 304 en backing)
</FONT></I>          <B><FONT COLOR="#A020F0">if</FONT></B> (r.adr) {          <I><FONT COLOR="#B22222">// Written file
</FONT></I>            <I><FONT COLOR="#B22222">// Buggy SVG (Smiling Spectre)
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B> (strcmp(r.contenttype, <B><FONT COLOR="#BC8F8F">&quot;image/svg+xml&quot;</FONT></B>) == 0 &amp;&amp; !look_like_xml(r.adr)) {
              <I><FONT COLOR="#B22222">// patch it
</FONT></I>              strcpybuff(r.contenttype, <B><FONT COLOR="#BC8F8F">&quot;application/octet-stream&quot;</FONT></B>);
              is_binary = 1;
            }
            <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> ((is_hypertext_mime(opt, r.contenttype, urlfil()))
                <I><FONT COLOR="#B22222">/* Is HTML or Js, .. */</FONT></I>
                <I><FONT COLOR="#B22222">/* NO - real media is real media, not HTML */</FONT></I>
                <I><FONT COLOR="#B22222">/*|| (may_be_hypertext_mime(r.contenttype, urlfil()) &amp;&amp; (r.adr) ) */</FONT></I>
                <I><FONT COLOR="#B22222">/* Is real media, .. */</FONT></I>
              ) {
              <B><FONT COLOR="#A020F0">if</FONT></B> (strnotempty(r.cdispo)) {      <I><FONT COLOR="#B22222">// Content-disposition set!
</FONT></I>                <B><FONT COLOR="#A020F0">if</FONT></B> (ishtml(opt, savename()) == 0) {       <I><FONT COLOR="#B22222">// Non HTML!!
</FONT></I>                  <I><FONT COLOR="#B22222">// patch it!
</FONT></I>                  strcpybuff(r.contenttype, <B><FONT COLOR="#BC8F8F">&quot;application/octet-stream&quot;</FONT></B>);
                }
              }
            }
          }
        }

        <I><FONT COLOR="#B22222">/* Load file if necessary and decode. */</FONT></I>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">LOAD_IN_MEMORY_IF_NECESSARY</FONT></B>() do { \
        if (  \
          may_be_hypertext_mime(opt,r.contenttype, urlfil())   <I><FONT COLOR="#B22222">/* Is HTML or Js, .. */</FONT></I> \
          &amp;&amp; (heap(ptr)-&gt;depth&gt;0)            <I><FONT COLOR="#B22222">/* Depth &gt; 0 (recurse depth) */</FONT></I> \
          &amp;&amp; (r.adr==NULL)        <I><FONT COLOR="#B22222">/* HTML Data exists */</FONT></I> \
          &amp;&amp; (!store_errpage)     <I><FONT COLOR="#B22222">/* Not an html error page */</FONT></I> \
          &amp;&amp; (savename()[0]!=<B><FONT COLOR="#BC8F8F">'\0'</FONT></B>)  <I><FONT COLOR="#B22222">/* Output filename exists */</FONT></I> \
          )  \
        { \
          is_loaded_from_file = 1; \
          r.adr = readfile2(savename(), &amp;r.size); \
          if (r.adr != NULL) { \
            hts_log_print(opt, LOG_INFO, <B><FONT COLOR="#BC8F8F">&quot;File successfully loaded for parsing: %s%s (%d bytes)&quot;</FONT></B>,urladr(),urlfil(),(int)r.size); \
          } else { \
            hts_log_print(opt, LOG_ERROR, <B><FONT COLOR="#BC8F8F">&quot;File could not be loaded for parsing: %s%s&quot;</FONT></B>,urladr(),urlfil()); \
          } \
        } \
} while(0)
        <I><FONT COLOR="#B22222">/* Load file and decode if necessary, before content-binary check. (3.43) */</FONT></I>
        LOAD_IN_MEMORY_IF_NECESSARY();

        <I><FONT COLOR="#B22222">// ------------------------------------
</FONT></I>        <I><FONT COLOR="#B22222">// BOGUS MIME TYPE HACK II (the revenge)
</FONT></I>        <I><FONT COLOR="#B22222">// Check if we have a bogus MIME type
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (HTTP_IS_OK(r.statuscode) &amp;&amp; (is_hypertext_mime(opt, r.contenttype, urlfil())  <I><FONT COLOR="#B22222">/* Is HTML or Js, .. */</FONT></I>
                                         ||may_be_hypertext_mime(opt, r.contenttype, urlfil()))   <I><FONT COLOR="#B22222">/* Is real media, .. */</FONT></I>
          ) {

          <I><FONT COLOR="#B22222">/* Convert charset to UTF-8 - NOT! (what about links ? remote server side will have troubles with converted names) */</FONT></I>
          <I><FONT COLOR="#B22222">//if (r.adr != NULL &amp;&amp; r.size != 0 &amp;&amp; opt-&gt;convert_utf8) {
</FONT></I>          <I><FONT COLOR="#B22222">//  char *charset;
</FONT></I>          <I><FONT COLOR="#B22222">//  char *pos;
</FONT></I>          <I><FONT COLOR="#B22222">//  if (r.charset[0] != '\0') {
</FONT></I>          <I><FONT COLOR="#B22222">//    charset = strdup(r.charset);
</FONT></I>          <I><FONT COLOR="#B22222">//  } else {
</FONT></I>          <I><FONT COLOR="#B22222">//    charset = hts_getCharsetFromMeta(r.adr, r.size);
</FONT></I>          <I><FONT COLOR="#B22222">//  }
</FONT></I>          <I><FONT COLOR="#B22222">//  if (charset != NULL) {
</FONT></I>          <I><FONT COLOR="#B22222">//    char *const utf8 = hts_convertStringToUTF8(r.adr, r.size, charset);
</FONT></I>          <I><FONT COLOR="#B22222">//    /* Use new buffer */
</FONT></I>          <I><FONT COLOR="#B22222">//    if (utf8 != NULL) {
</FONT></I>          <I><FONT COLOR="#B22222">//      freet(r.adr);
</FONT></I>          <I><FONT COLOR="#B22222">//      r.size = strlen(utf8);
</FONT></I>          <I><FONT COLOR="#B22222">//      r.adr = utf8;
</FONT></I>          <I><FONT COLOR="#B22222">//      /* New UTF-8 charset */
</FONT></I>          <I><FONT COLOR="#B22222">//      r.charset[0] = '\0';
</FONT></I>          <I><FONT COLOR="#B22222">//      strcpy(r.charset, &quot;utf-8&quot;);
</FONT></I>          <I><FONT COLOR="#B22222">//    }
</FONT></I>          <I><FONT COLOR="#B22222">//    /* Free charset */
</FONT></I>          <I><FONT COLOR="#B22222">//    free(charset);
</FONT></I>          <I><FONT COLOR="#B22222">//  }
</FONT></I>          <I><FONT COLOR="#B22222">//}
</FONT></I>
          <I><FONT COLOR="#B22222">/* Check bogus chars */</FONT></I>
          <B><FONT COLOR="#A020F0">if</FONT></B> ((r.adr) &amp;&amp; (r.size)) {
            <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> map[256];
            <B><FONT COLOR="#228B22">int</FONT></B> i;
            <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> nspec = 0;

            map_characters((<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *) r.adr, (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>) r.size,
                           &amp;map[0]);
            <B><FONT COLOR="#A020F0">for</FONT></B>(i = 1; i &lt; 32; i++) {   <I><FONT COLOR="#B22222">//  null chars ignored..
</FONT></I>              <B><FONT COLOR="#A020F0">if</FONT></B> (!is_realspace(i)
                  &amp;&amp; i != 27    <I><FONT COLOR="#B22222">/* Damn you ISO2022-xx! */</FONT></I>
                ) {
                nspec += map[i];
              }
            }
            <I><FONT COLOR="#B22222">/* On-the-fly UCS2 to UTF-8 conversion (note: UCS2 should never be used on the net) */</FONT></I>
            <B><FONT COLOR="#A020F0">if</FONT></B> (map[0] &gt; r.size / 10 &amp;&amp; r.size % 2 == 0
                &amp;&amp;
                ((((<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>) r.adr[0]) == 0xff
                  &amp;&amp; ((<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>) r.adr[1]) == 0xfe)
                 || (((<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>) r.adr[0]) == 0xfe
                     &amp;&amp; ((<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>) r.adr[1]) == 0xff)
                )
              ) {
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">CH_ADD</FONT></B>(c) do {															\
	if (new_offs + 1 &gt; new_capa) {										\
		new_capa *= 2;																	\
		new_adr = (unsigned char*) realloct(new_adr,    \
		                                    new_capa); 	\
		assertf(new_adr != NULL);												\
	}																									\
	new_adr[new_offs++] = (unsigned char) (c);        \
} while(0)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">CH_ADD_RNG1</FONT></B>(c, r, o) do {                   \
	CH_ADD( (c) / (r) + (o) );                        \
	c = (c) % (r);                                    \
} while(0)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">CH_ADD_RNG0</FONT></B>(c, o) do {                      \
	CH_ADD_RNG1(c, 1, o); 	 													\
} while(0)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">CH_ADD_RNG2</FONT></B>(c, r, r2, o) do {               \
	CH_ADD_RNG1(c, (r) * (r2), o);	 									\
} while(0)
              <B><FONT COLOR="#228B22">int</FONT></B> new_capa = (<B><FONT COLOR="#228B22">int</FONT></B>) (r.size / 2 + 1);
              <B><FONT COLOR="#228B22">int</FONT></B> new_offs = 0;
              <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *prev_adr = (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *) r.adr;
              <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *new_adr = (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *) malloct(new_capa);
              <B><FONT COLOR="#228B22">int</FONT></B> i;
              <B><FONT COLOR="#228B22">int</FONT></B> swap = (((<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>) r.adr[0]) == 0xff);

              assertf(new_adr != NULL);
              <I><FONT COLOR="#B22222">/* 
                 See http://www.unicode.org/reports/tr28/tr28-3.html#conformance 
                 U+0000..U+007F 00..7F       
                 U+0080..U+07FF C2..DF  80..BF      
                 U+0800..U+0FFF E0      A0..BF  80..BF    
                 U+1000..U+CFFF E1..EC  80..BF  80..BF    
                 U+D000..U+D7FF ED      80..9F  80..BF    
                 U+D800..U+DFFF
                 U+E000..U+FFFF EE..EF  80..BF  80..BF    
               */</FONT></I>
              <B><FONT COLOR="#A020F0">for</FONT></B>(i = 0; i &lt; r.size / 2; i++) {
                <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">short</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> unic = 0;

                <B><FONT COLOR="#A020F0">if</FONT></B> (swap)
                  unic = prev_adr[i * 2] + (prev_adr[i * 2 + 1] &lt;&lt; 8);
                <B><FONT COLOR="#A020F0">else</FONT></B>
                  unic = (prev_adr[i * 2] &lt;&lt; 8) + prev_adr[i * 2 + 1];
                <B><FONT COLOR="#A020F0">if</FONT></B> (unic &lt;= 0x7F) {
                  <I><FONT COLOR="#B22222">/* U+0000..U+007F 00..7F      */</FONT></I>
                  CH_ADD_RNG0(unic, 0x00);
                } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (unic &lt;= 0x07FF) {
                  <I><FONT COLOR="#B22222">/* U+0080..U+07FF C2..DF  80..BF */</FONT></I>
                  unic -= 0x0080;
                  CH_ADD_RNG1(unic, 0xbf - 0x80 + 1, 0xc2);
                  CH_ADD_RNG0(unic, 0x80);
                } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (unic &lt;= 0x0FFF) {
                  <I><FONT COLOR="#B22222">/* U+0800..U+0FFF E0      A0..BF  80..BF */</FONT></I>
                  unic -= 0x0800;
                  CH_ADD_RNG2(unic, 0xbf - 0x80 + 1, 0xbf - 0xa0 + 1, 0xe0);
                  CH_ADD_RNG1(unic, 0xbf - 0x80 + 1, 0xa0);
                  CH_ADD_RNG0(unic, 0x80);
                } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (unic &lt;= 0xCFFF) {
                  <I><FONT COLOR="#B22222">/* U+1000..U+CFFF E1..EC  80..BF  80..BF */</FONT></I>
                  unic -= 0x1000;
                  CH_ADD_RNG2(unic, 0xbf - 0x80 + 1, 0xbf - 0x80 + 1, 0xe1);
                  CH_ADD_RNG1(unic, 0xbf - 0x80 + 1, 0x80);
                  CH_ADD_RNG0(unic, 0x80);
                } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (unic &lt;= 0xD7FF) {
                  <I><FONT COLOR="#B22222">/* U+D000..U+D7FF ED      80..9F  80..BF */</FONT></I>
                  unic -= 0xD000;
                  CH_ADD_RNG2(unic, 0xbf - 0x80 + 1, 0x9f - 0x80 + 1, 0xed);
                  CH_ADD_RNG1(unic, 0xbf - 0x80 + 1, 0x80);
                  CH_ADD_RNG0(unic, 0x80);
                } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (unic &lt;= 0xDFFF) {
                  <I><FONT COLOR="#B22222">/* U+D800..U+DFFF */</FONT></I>
                  CH_ADD(<B><FONT COLOR="#BC8F8F">'?'</FONT></B>);
                  <I><FONT COLOR="#B22222">/* ill-formed */</FONT></I>
                } <B><FONT COLOR="#A020F0">else</FONT></B> {        <I><FONT COLOR="#B22222">/* if (unic &lt;= 0xFFFF) */</FONT></I>

                  <I><FONT COLOR="#B22222">/* U+E000..U+FFFF EE..EF  80..BF  80..BF */</FONT></I>
                  unic -= 0xE000;
                  CH_ADD_RNG2(unic, 0xbf - 0x80 + 1, 0xbf - 0x80 + 1, 0xee);
                  CH_ADD_RNG1(unic, 0xbf - 0x80 + 1, 0x80);
                  CH_ADD_RNG0(unic, 0x80);
                }
              }
              hts_log_print(opt, LOG_WARNING,
                            <B><FONT COLOR="#BC8F8F">&quot;File %s%s converted from UCS2 to UTF-8 (old size: %d bytes, new size: %d bytes)&quot;</FONT></B>,
                            urladr(), urlfil(), (<B><FONT COLOR="#228B22">int</FONT></B>) r.size, new_offs);
              freet(r.adr);
              r.adr = NULL;
              r.size = new_offs;
              CH_ADD(0);
              r.adr = (<B><FONT COLOR="#228B22">char</FONT></B> *) new_adr;
#<B><FONT COLOR="#5F9EA0">undef</FONT></B> <FONT COLOR="#B8860B">CH_ADD</FONT>
#<B><FONT COLOR="#5F9EA0">undef</FONT></B> <FONT COLOR="#B8860B">CH_ADD_RNG0</FONT>
#<B><FONT COLOR="#5F9EA0">undef</FONT></B> <FONT COLOR="#B8860B">CH_ADD_RNG1</FONT>
#<B><FONT COLOR="#5F9EA0">undef</FONT></B> <FONT COLOR="#B8860B">CH_ADD_RNG2</FONT>
            } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> ((nspec &gt; r.size / 100) &amp;&amp; (nspec &gt; 10)) {        <I><FONT COLOR="#B22222">// too many special characters
</FONT></I>              is_binary = 1;
              strcpybuff(r.contenttype, <B><FONT COLOR="#BC8F8F">&quot;application/octet-stream&quot;</FONT></B>);
              hts_log_print(opt, LOG_WARNING,
                            <B><FONT COLOR="#BC8F8F">&quot;File not parsed, looks like binary: %s%s&quot;</FONT></B>, urladr(),
                            urlfil());
            }

            <I><FONT COLOR="#B22222">/* This hack allows you to avoid problems with parsing '\0' characters  */</FONT></I>
            <B><FONT COLOR="#A020F0">if</FONT></B> (!is_binary) {
              <B><FONT COLOR="#A020F0">for</FONT></B>(i = 0; i &lt; r.size; i++) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (r.adr[i] == <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>)
                  r.adr[i] = <B><FONT COLOR="#BC8F8F">' '</FONT></B>;
              }
            }

          }

        }
      }
      <I><FONT COLOR="#B22222">// MOVED IN back_finalize()
</FONT></I>      <I><FONT COLOR="#B22222">//
</FONT></I>      <I><FONT COLOR="#B22222">// -------------------- 
</FONT></I>      <I><FONT COLOR="#B22222">// REAL MEDIA HACK
</FONT></I>      <I><FONT COLOR="#B22222">// Check if we have to load locally the file
</FONT></I>      <I><FONT COLOR="#B22222">// --------------------
</FONT></I>      <I><FONT COLOR="#B22222">//if (!error) {
</FONT></I>      <I><FONT COLOR="#B22222">//  if (r.statuscode == HTTP_OK) {    // OK (ou 304 en backing)
</FONT></I>      <I><FONT COLOR="#B22222">//    if (r.adr==NULL) {    // Written file
</FONT></I>      <I><FONT COLOR="#B22222">//      if (may_be_hypertext_mime(r.contenttype, urlfil())) {   // to parse!
</FONT></I>      <I><FONT COLOR="#B22222">//        LLint sz;
</FONT></I>      <I><FONT COLOR="#B22222">//        sz=fsize_utf8(savename());
</FONT></I>      <I><FONT COLOR="#B22222">//        if (sz&gt;0) {   // ok, exists!
</FONT></I>      <I><FONT COLOR="#B22222">//          if (sz &lt; 8192) {   // ok, small file --&gt; to parse!
</FONT></I>      <I><FONT COLOR="#B22222">//            FILE* fp=FOPEN(savename(),&quot;rb&quot;);
</FONT></I>      <I><FONT COLOR="#B22222">//            if (fp) {
</FONT></I>      <I><FONT COLOR="#B22222">//              r.adr=malloct(sz + 1);
</FONT></I>      <I><FONT COLOR="#B22222">//              if (r.adr) {
</FONT></I>      <I><FONT COLOR="#B22222">//                if (fread(r.adr,1,sz,fp) == sz) {
</FONT></I>      <I><FONT COLOR="#B22222">//                  r.size=sz;
</FONT></I>      <I><FONT COLOR="#B22222">//                                                r.adr[sz] = '\0';
</FONT></I>      <I><FONT COLOR="#B22222">//                                                r.is_write = 0;
</FONT></I>      <I><FONT COLOR="#B22222">//                } else {
</FONT></I>      <I><FONT COLOR="#B22222">//                  freet(r.adr);
</FONT></I>      <I><FONT COLOR="#B22222">//                  r.size=0;
</FONT></I>      <I><FONT COLOR="#B22222">//                  r.adr = NULL;
</FONT></I>      <I><FONT COLOR="#B22222">//                  r.statuscode=STATUSCODE_INVALID;
</FONT></I>      <I><FONT COLOR="#B22222">//                  strcpybuff(r.msg, &quot;.RAM read error&quot;);
</FONT></I>      <I><FONT COLOR="#B22222">//                }
</FONT></I>      <I><FONT COLOR="#B22222">//                fclose(fp);
</FONT></I>      <I><FONT COLOR="#B22222">//                fp=NULL;
</FONT></I>      <I><FONT COLOR="#B22222">//                // remove (temporary) file!
</FONT></I>      <I><FONT COLOR="#B22222">//                remove(savename());
</FONT></I>      <I><FONT COLOR="#B22222">//              }
</FONT></I>      <I><FONT COLOR="#B22222">//              if (fp)
</FONT></I>      <I><FONT COLOR="#B22222">//                fclose(fp);
</FONT></I>      <I><FONT COLOR="#B22222">//            }
</FONT></I>      <I><FONT COLOR="#B22222">//          }
</FONT></I>      <I><FONT COLOR="#B22222">//        }
</FONT></I>      <I><FONT COLOR="#B22222">//      }
</FONT></I>      <I><FONT COLOR="#B22222">//    }
</FONT></I>      <I><FONT COLOR="#B22222">//  }
</FONT></I>      <I><FONT COLOR="#B22222">//}
</FONT></I>      <I><FONT COLOR="#B22222">// EN OF REAL MEDIA HACK
</FONT></I>
      <I><FONT COLOR="#B22222">// ---stockage en cache---
</FONT></I>      <I><FONT COLOR="#B22222">// stocker dans le cache?
</FONT></I>      <I><FONT COLOR="#B22222">/*
         if (!error) {
         if (ptr&gt;0) {
         if (heap(ptr)) {
         xxcache_mayadd(opt,&amp;cache,&amp;r,urladr(),urlfil(),savename());
         } else
         error=1;
         }
         }
       */</FONT></I>
      <I><FONT COLOR="#B22222">// ---fin stockage en cache---
</FONT></I>
      <I><FONT COLOR="#B22222">/*
       **************************************
       Check &quot;Moved permanently&quot; and other similar errors, retrying URLs if necessary and handling
       redirect pages.
       */</FONT></I>
      <B><FONT COLOR="#A020F0">if</FONT></B> (!error) {
        <B><FONT COLOR="#228B22">char</FONT></B> BIGSTK buff_err_msg[1024];
        htsmoduleStruct BIGSTK str;
        htsmoduleStructExtended BIGSTK stre;

        buff_err_msg[0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
        memset(&amp;str, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(str));
        memset(&amp;stre, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(stre));
        <I><FONT COLOR="#B22222">/* */</FONT></I>
        str.err_msg = buff_err_msg;
        str.filename = savename();
        str.mime = r.contenttype;
        str.url_host = urladr();
        str.url_file = urlfil();
        str.size = (<B><FONT COLOR="#228B22">int</FONT></B>) r.size;
        <I><FONT COLOR="#B22222">/* */</FONT></I>
        str.addLink = htsAddLink;
        <I><FONT COLOR="#B22222">/* */</FONT></I>
        str.opt = opt;
        str.sback = sback;
        str.cache = &amp;cache;
        str.hashptr = hashptr;
        str.numero_passe = numero_passe;
        <I><FONT COLOR="#B22222">/* */</FONT></I>
        str.ptr_ = &amp;ptr;
        <I><FONT COLOR="#B22222">/* */</FONT></I>
        str.page_charset_ = NULL;
        <I><FONT COLOR="#B22222">/* */</FONT></I>
        <I><FONT COLOR="#B22222">/* */</FONT></I>
        stre.r_ = &amp;r;
        <I><FONT COLOR="#B22222">/* */</FONT></I>
        stre.error_ = &amp;error;
        stre.exit_xh_ = &amp;opt-&gt;state.exit_xh;
        stre.store_errpage_ = &amp;store_errpage;
        <I><FONT COLOR="#B22222">/* */</FONT></I>
        stre.base = base;
        stre.codebase = codebase;
        <I><FONT COLOR="#B22222">/* */</FONT></I>
        stre.filters_ = &amp;filters;
        stre.filptr_ = &amp;filptr;
        stre.robots_ = &amp;robots;
        stre.hash_ = &amp;hash;
        <I><FONT COLOR="#B22222">/* */</FONT></I>
        stre.makeindex_done_ = &amp;makeindex_done;
        stre.makeindex_fp_ = &amp;makeindex_fp;
        stre.makeindex_links_ = &amp;makeindex_links;
        stre.makeindex_firstlink_ = makeindex_firstlink;
        <I><FONT COLOR="#B22222">/* */</FONT></I>
        stre.template_header_ = template_header;
        stre.template_body_ = template_body;
        stre.template_footer_ = template_footer;
        <I><FONT COLOR="#B22222">/* */</FONT></I>
        stre.stat_fragment_ = &amp;stat_fragment;
        stre.makestat_time = makestat_time;
        stre.makestat_fp = makestat_fp;
        stre.makestat_total_ = &amp;makestat_total;
        stre.makestat_lnk_ = &amp;makestat_lnk;
        stre.maketrack_fp = maketrack_fp;

        <I><FONT COLOR="#B22222">/* Parse */</FONT></I>
        <B><FONT COLOR="#A020F0">if</FONT></B> (hts_mirror_check_moved(&amp;str, &amp;stre) != 0) {
          XH_uninit;
          <B><FONT COLOR="#A020F0">return</FONT></B> -1;
        }

      }

    }                           <I><FONT COLOR="#B22222">// if !error
</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B> (!error) {
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">DEBUG_SHOWTYPES</FONT>
      <B><FONT COLOR="#A020F0">if</FONT></B> (strstr(REG, r.contenttype) == NULL) {
        strcatbuff(REG, r.contenttype);
        strcatbuff(REG, <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>);
        printf(<B><FONT COLOR="#BC8F8F">&quot;%s\n&quot;</FONT></B>, r.contenttype);
        io_flush;
      }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

      <I><FONT COLOR="#B22222">/* Load file and decode if necessary, after redirect check. */</FONT></I>
      LOAD_IN_MEMORY_IF_NECESSARY();

      <I><FONT COLOR="#B22222">// ------------------------------------------------------
</FONT></I>      <I><FONT COLOR="#B22222">// ok, fichier chargé localement
</FONT></I>      <I><FONT COLOR="#B22222">// ------------------------------------------------------
</FONT></I>
      <I><FONT COLOR="#B22222">// Vérificateur d'intégrité
</FONT></I>#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">DEBUG_CHECKINT</FONT>
      {
        <B><FONT COLOR="#228B22">int</FONT></B> i;

        <B><FONT COLOR="#A020F0">for</FONT></B>(i = 0; i &lt; sback-&gt;count; i++) {
          <B><FONT COLOR="#228B22">char</FONT></B> si[256];

          sprintf(si, <B><FONT COLOR="#BC8F8F">&quot;Test global après back_wait, index %d&quot;</FONT></B>, i);
          _CHECKINT(&amp;back[i], si)
        }
      }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

      <I><FONT COLOR="#B22222">/* info: updated */</FONT></I>
      <I><FONT COLOR="#B22222">/*
         if (ptr&gt;0) {
         // &quot;mis à jour&quot;
         if ((!r.notmodified) &amp;&amp; (opt-&gt;is_update) &amp;&amp; (!store_errpage)) {    // page modifiée
         if (strnotempty(savename())) {
         HTS_STAT.stat_updated_files++;
         //if ((opt-&gt;debug&gt;0) &amp;&amp; (opt-&gt;log!=NULL)) {
         hts_log_print(opt, LOG_INFO, &quot;File updated: %s%s&quot;,urladr(),urlfil());
         }
         } else {
         if (!store_errpage) {
         hts_log_print(opt, LOG_INFO, &quot;File recorded: %s%s&quot;,urladr(),urlfil());
         }
         }
         }
       */</FONT></I>

      <I><FONT COLOR="#B22222">// ------------------------------------------------------
</FONT></I>      <I><FONT COLOR="#B22222">// traitement (parsing)
</FONT></I>      <I><FONT COLOR="#B22222">// ------------------------------------------------------
</FONT></I>
      <I><FONT COLOR="#B22222">// traiter
</FONT></I>      <B><FONT COLOR="#A020F0">if</FONT></B> (!is_binary &amp;&amp; ((is_hypertext_mime(opt, r.contenttype, urlfil()))        <I><FONT COLOR="#B22222">/* Is HTML or Js, .. */</FONT></I>
                         ||(may_be_hypertext_mime(opt, r.contenttype, urlfil()) &amp;&amp; r.adr != NULL) <I><FONT COLOR="#B22222">/* Is real media, .. */</FONT></I>
          )
          &amp;&amp; (heap(ptr)-&gt;depth &gt; 0)    <I><FONT COLOR="#B22222">/* Depth &gt; 0 (recurse depth) */</FONT></I>
          &amp;&amp;(r.adr != NULL)     <I><FONT COLOR="#B22222">/* HTML Data exists */</FONT></I>
          &amp;&amp;(r.size &gt; 0)        <I><FONT COLOR="#B22222">/* And not empty */</FONT></I>
          &amp;&amp;(!store_errpage)    <I><FONT COLOR="#B22222">/* Not an html error page */</FONT></I>
          &amp;&amp;(savename()[0] != <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>)       <I><FONT COLOR="#B22222">/* Output filename exists */</FONT></I>
        ) {                     <I><FONT COLOR="#B22222">// ne traiter que le html si autorisé
</FONT></I>        <I><FONT COLOR="#B22222">// -- -- -- --
</FONT></I>        <I><FONT COLOR="#B22222">// Parsing HTML
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (!error) {
          <B><FONT COLOR="#228B22">char</FONT></B> page_charset[32];

          <I><FONT COLOR="#B22222">/* Remove file if being processed */</FONT></I>
          <B><FONT COLOR="#A020F0">if</FONT></B> (is_loaded_from_file) {
            (<B><FONT COLOR="#228B22">void</FONT></B>) unlink(fconv(OPT_GET_BUFF(opt), OPT_GET_BUFF_SIZE(opt), savename()));
            is_loaded_from_file = 0;
          }

          <I><FONT COLOR="#B22222">/* Detect charset to convert links into proper UTF8 filenames */</FONT></I>
          page_charset[0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
          <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;convert_utf8) {
            <I><FONT COLOR="#B22222">/* HTTP charset is prioritary over meta */</FONT></I>
            <B><FONT COLOR="#A020F0">if</FONT></B> (r.charset[0] != <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>) {
              <B><FONT COLOR="#A020F0">if</FONT></B> (strlen(r.charset) &lt; <B><FONT COLOR="#A020F0">sizeof</FONT></B>(page_charset)) {
                strcpy(page_charset, r.charset);
              }
            }
            <I><FONT COLOR="#B22222">/* Attempt to find a meta charset */</FONT></I>
            <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (is_html_mime_type(r.contenttype)) {
              <B><FONT COLOR="#228B22">char</FONT></B> *<B><FONT COLOR="#228B22">const</FONT></B> charset = hts_getCharsetFromMeta(r.adr, r.size);

              <B><FONT COLOR="#A020F0">if</FONT></B> (charset != NULL &amp;&amp; strlen(charset) &lt; <B><FONT COLOR="#A020F0">sizeof</FONT></B>(page_charset)) {
                strcpy(page_charset, charset);
              }
              <B><FONT COLOR="#A020F0">if</FONT></B> (charset != NULL)
                free(charset);
            }
            <I><FONT COLOR="#B22222">/* Could not detect charset: could it be UTF-8 ? */</FONT></I>
            <I><FONT COLOR="#B22222">/* No, we can not do that: browsers do not do it 
               (and it would break links). */</FONT></I>
            <I><FONT COLOR="#B22222">//if (page_charset[0] == '\0') {
</FONT></I>            <I><FONT COLOR="#B22222">//  if (is_unicode_utf8(r.adr, r.size)) {
</FONT></I>            <I><FONT COLOR="#B22222">//    strcpy(page_charset, &quot;utf-8&quot;);
</FONT></I>            <I><FONT COLOR="#B22222">//  }
</FONT></I>            <I><FONT COLOR="#B22222">//}
</FONT></I>            <I><FONT COLOR="#B22222">/* Could not detect charset */</FONT></I>
            <B><FONT COLOR="#A020F0">if</FONT></B> (page_charset[0] == <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>) {
              hts_log_print(opt, LOG_INFO,
                            <B><FONT COLOR="#BC8F8F">&quot;Warning: could not detect encoding for: %s%s&quot;</FONT></B>,
                            urladr(), urlfil());
              <I><FONT COLOR="#B22222">/* Fallback to ISO-8859-1 (~== identity) ; accents will look weird */</FONT></I>
              strcpy(page_charset, <B><FONT COLOR="#BC8F8F">&quot;iso-8859-1&quot;</FONT></B>);
            }
          }

          <I><FONT COLOR="#B22222">/* Info for wrappers */</FONT></I>
          hts_log_print(opt, LOG_INFO, <B><FONT COLOR="#BC8F8F">&quot;engine: check-html: %s%s&quot;</FONT></B>, urladr(),
                        urlfil());
          {
            <B><FONT COLOR="#228B22">char</FONT></B> BIGSTK buff_err_msg[1024];
            htsmoduleStruct BIGSTK str;
            htsmoduleStructExtended BIGSTK stre;

            buff_err_msg[0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
            memset(&amp;str, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(str));
            memset(&amp;stre, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(stre));
            <I><FONT COLOR="#B22222">/* */</FONT></I>
            str.err_msg = buff_err_msg;
            str.filename = savename();
            str.mime = r.contenttype;
            str.url_host = urladr();
            str.url_file = urlfil();
            str.size = (<B><FONT COLOR="#228B22">int</FONT></B>) r.size;
            <I><FONT COLOR="#B22222">/* */</FONT></I>
            str.addLink = htsAddLink;
            <I><FONT COLOR="#B22222">/* */</FONT></I>
            str.opt = opt;
            str.sback = sback;
            str.cache = &amp;cache;
            str.hashptr = hashptr;
            str.numero_passe = numero_passe;
            <I><FONT COLOR="#B22222">/* */</FONT></I>
            str.ptr_ = &amp;ptr;
            <I><FONT COLOR="#B22222">/* */</FONT></I>
            str.page_charset_ = page_charset[0] != <B><FONT COLOR="#BC8F8F">'\0'</FONT></B> ? page_charset : NULL;
            <I><FONT COLOR="#B22222">/* */</FONT></I>
            <I><FONT COLOR="#B22222">/* */</FONT></I>
            stre.r_ = &amp;r;
            <I><FONT COLOR="#B22222">/* */</FONT></I>
            stre.error_ = &amp;error;
            stre.exit_xh_ = &amp;opt-&gt;state.exit_xh;
            stre.store_errpage_ = &amp;store_errpage;
            <I><FONT COLOR="#B22222">/* */</FONT></I>
            stre.base = base;
            stre.codebase = codebase;
            <I><FONT COLOR="#B22222">/* */</FONT></I>
            stre.filters_ = &amp;filters;
            stre.filptr_ = &amp;filptr;
            stre.robots_ = &amp;robots;
            stre.hash_ = &amp;hash;
            <I><FONT COLOR="#B22222">/* */</FONT></I>
            stre.makeindex_done_ = &amp;makeindex_done;
            stre.makeindex_fp_ = &amp;makeindex_fp;
            stre.makeindex_links_ = &amp;makeindex_links;
            stre.makeindex_firstlink_ = makeindex_firstlink;
            <I><FONT COLOR="#B22222">/* */</FONT></I>
            stre.template_header_ = template_header;
            stre.template_body_ = template_body;
            stre.template_footer_ = template_footer;
            <I><FONT COLOR="#B22222">/* */</FONT></I>
            stre.stat_fragment_ = &amp;stat_fragment;
            stre.makestat_time = makestat_time;
            stre.makestat_fp = makestat_fp;
            stre.makestat_total_ = &amp;makestat_total;
            stre.makestat_lnk_ = &amp;makestat_lnk;
            stre.maketrack_fp = maketrack_fp;

            <I><FONT COLOR="#B22222">/* Parse */</FONT></I>
            <B><FONT COLOR="#A020F0">if</FONT></B> (htsparse(&amp;str, &amp;stre) != 0) {
              XH_uninit;
              <B><FONT COLOR="#A020F0">return</FONT></B> -1;
            }

            <I><FONT COLOR="#B22222">// I'll have to segment this part
</FONT></I><I><FONT COLOR="#B22222">// #include &quot;htsparse.c&quot;
</FONT></I>
          }
        }
        <I><FONT COLOR="#B22222">// Fin parsing HTML
</FONT></I>        <I><FONT COLOR="#B22222">// -- -- -- --
</FONT></I>
      }                         <I><FONT COLOR="#B22222">// si text/html
</FONT></I>      <I><FONT COLOR="#B22222">// -- -- --
</FONT></I>      <B><FONT COLOR="#A020F0">else</FONT></B> {                    <I><FONT COLOR="#B22222">// sauver fichier quelconque
</FONT></I>        <I><FONT COLOR="#B22222">// -- -- --
</FONT></I>        <I><FONT COLOR="#B22222">// sauver fichier
</FONT></I>
        <I><FONT COLOR="#B22222">/* En cas d'erreur, vérifier que fichier d'erreur existe */</FONT></I>
        <B><FONT COLOR="#A020F0">if</FONT></B> (strnotempty(savename()) == 0) {       <I><FONT COLOR="#B22222">// chemin de sauvegarde existant
</FONT></I>          <B><FONT COLOR="#A020F0">if</FONT></B> (strcmp(urlfil(), <B><FONT COLOR="#BC8F8F">&quot;/robots.txt&quot;</FONT></B>) == 0) {     <I><FONT COLOR="#B22222">// pas robots.txt
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B> (store_errpage) {        <I><FONT COLOR="#B22222">// c'est une page d'erreur
</FONT></I>              <B><FONT COLOR="#228B22">int</FONT></B> create_html_warning = 0;
              <B><FONT COLOR="#228B22">int</FONT></B> create_gif_warning = 0;

              <B><FONT COLOR="#A020F0">switch</FONT></B> (ishtml(opt, urlfil())) {    <I><FONT COLOR="#B22222">/* pas fichier html */</FONT></I>
              <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0</FONT></B>:          <I><FONT COLOR="#B22222">/* non html */</FONT></I>
                {
                  <B><FONT COLOR="#228B22">char</FONT></B> buff[256];

                  guess_httptype(opt, buff, urlfil());
                  <B><FONT COLOR="#A020F0">if</FONT></B> (strcmp(buff, <B><FONT COLOR="#BC8F8F">&quot;image/gif&quot;</FONT></B>) == 0)
                    create_gif_warning = 1;
                }
                <B><FONT COLOR="#A020F0">break</FONT></B>;
              <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">1</FONT></B>:          <I><FONT COLOR="#B22222">/* html */</FONT></I>
                <B><FONT COLOR="#A020F0">if</FONT></B> (!r.adr) {
                }
                <B><FONT COLOR="#A020F0">break</FONT></B>;
              <B><FONT COLOR="#5F9EA0">default</FONT></B>:         <I><FONT COLOR="#B22222">/* don't know.. */</FONT></I>
                <B><FONT COLOR="#A020F0">break</FONT></B>;
              }
              <I><FONT COLOR="#B22222">/* Créer message d'erreur ? */</FONT></I>
              <B><FONT COLOR="#A020F0">if</FONT></B> (create_html_warning) {
                <B><FONT COLOR="#228B22">char</FONT></B> *adr =
                  (<B><FONT COLOR="#228B22">char</FONT></B> *) malloct(strlen(HTS_DATA_ERROR_HTML) + 1100);
                hts_log_print(opt, LOG_INFO, <B><FONT COLOR="#BC8F8F">&quot;Creating HTML warning file (%s)&quot;</FONT></B>,
                              r.msg);
                <B><FONT COLOR="#A020F0">if</FONT></B> (adr) {
                  <B><FONT COLOR="#A020F0">if</FONT></B> (r.adr) {
                    freet(r.adr);
                    r.adr = NULL;
                  }
                  sprintf(adr, HTS_DATA_ERROR_HTML, r.msg);
                  r.adr = adr;
                }
              } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (create_gif_warning) {
                <B><FONT COLOR="#228B22">char</FONT></B> *adr = (<B><FONT COLOR="#228B22">char</FONT></B> *) malloct(HTS_DATA_UNKNOWN_GIF_LEN);

                hts_log_print(opt, LOG_INFO, <B><FONT COLOR="#BC8F8F">&quot;Creating GIF dummy file (%s)&quot;</FONT></B>,
                              r.msg);
                <B><FONT COLOR="#A020F0">if</FONT></B> (r.adr) {
                  freet(r.adr);
                  r.adr = NULL;
                }
                memcpy(adr, HTS_DATA_UNKNOWN_GIF, HTS_DATA_UNKNOWN_GIF_LEN);
                r.adr = adr;
              }
            }
          }
        }

        <B><FONT COLOR="#A020F0">if</FONT></B> (strnotempty(savename()) == 0) {       <I><FONT COLOR="#B22222">// pas de chemin de sauvegarde
</FONT></I>          <B><FONT COLOR="#A020F0">if</FONT></B> (strcmp(urlfil(), <B><FONT COLOR="#BC8F8F">&quot;/robots.txt&quot;</FONT></B>) == 0) {     <I><FONT COLOR="#B22222">// robots.txt
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B> (r.adr) {
              <B><FONT COLOR="#228B22">int</FONT></B> bptr = 0;
              <B><FONT COLOR="#228B22">char</FONT></B> BIGSTK line[1024];
              <B><FONT COLOR="#228B22">char</FONT></B> BIGSTK buff[8192];
              <B><FONT COLOR="#228B22">char</FONT></B> BIGSTK infobuff[8192];
              <B><FONT COLOR="#228B22">int</FONT></B> record = 0;

              line[0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
              buff[0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
              infobuff[0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
              <I><FONT COLOR="#B22222">//
</FONT></I>#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">DEBUG_ROBOTS</FONT>
              printf(<B><FONT COLOR="#BC8F8F">&quot;robots.txt dump:\n%s\n&quot;</FONT></B>, r.adr);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
              <B><FONT COLOR="#A020F0">do</FONT></B> {
                <B><FONT COLOR="#228B22">char</FONT></B> *comm;
                <B><FONT COLOR="#228B22">int</FONT></B> llen;

                bptr += binput(r.adr + bptr, line, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(line) - 2);
                <I><FONT COLOR="#B22222">/* strip comment */</FONT></I>
                comm = strchr(line, <B><FONT COLOR="#BC8F8F">'#'</FONT></B>);
                <B><FONT COLOR="#A020F0">if</FONT></B> (comm != NULL) {
                  *comm = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
                }
                <I><FONT COLOR="#B22222">/* strip spaces */</FONT></I>
                llen = (<B><FONT COLOR="#228B22">int</FONT></B>) strlen(line);
                <B><FONT COLOR="#A020F0">while</FONT></B>(llen &gt; 0 &amp;&amp; is_realspace(line[llen - 1])) {
                  line[llen - 1] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
                  llen--;
                }
                <B><FONT COLOR="#A020F0">if</FONT></B> (strfield(line, <B><FONT COLOR="#BC8F8F">&quot;user-agent:&quot;</FONT></B>)) {
                  <B><FONT COLOR="#228B22">char</FONT></B> *a;

                  a = line + 11;
                  <B><FONT COLOR="#A020F0">while</FONT></B>(is_realspace(*a))
                    a++;        <I><FONT COLOR="#B22222">// sauter espace(s)
</FONT></I>                  <B><FONT COLOR="#A020F0">if</FONT></B> (*a == <B><FONT COLOR="#BC8F8F">'*'</FONT></B>) {
                    <B><FONT COLOR="#A020F0">if</FONT></B> (record != 2)
                      record = 1;       <I><FONT COLOR="#B22222">// c pour nous
</FONT></I>                  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (strfield(a, <B><FONT COLOR="#BC8F8F">&quot;httrack&quot;</FONT></B>) || strfield(a, <B><FONT COLOR="#BC8F8F">&quot;winhttrack&quot;</FONT></B>)
                             || strfield(a, <B><FONT COLOR="#BC8F8F">&quot;webhttrack&quot;</FONT></B>)) {
                    buff[0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;     <I><FONT COLOR="#B22222">// re-enregistrer
</FONT></I>                    infobuff[0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
                    record = 2; <I><FONT COLOR="#B22222">// locked
</FONT></I>#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">DEBUG_ROBOTS</FONT>
                    printf(<B><FONT COLOR="#BC8F8F">&quot;explicit disallow for httrack\n&quot;</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
                  } <B><FONT COLOR="#A020F0">else</FONT></B>
                    record = 0;
                } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (record) {
                  <B><FONT COLOR="#A020F0">if</FONT></B> (strfield(line, <B><FONT COLOR="#BC8F8F">&quot;disallow:&quot;</FONT></B>)) {
                    <B><FONT COLOR="#228B22">char</FONT></B> *a = line + 9;

                    <B><FONT COLOR="#A020F0">while</FONT></B>(is_realspace(*a))
                      a++;      <I><FONT COLOR="#B22222">// sauter espace(s)
</FONT></I>                    <B><FONT COLOR="#A020F0">if</FONT></B> (strnotempty(a)) {
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">IGNORE_RESTRICTIVE_ROBOTS</FONT>
                      <B><FONT COLOR="#A020F0">if</FONT></B> (strcmp(a, <B><FONT COLOR="#BC8F8F">&quot;/&quot;</FONT></B>) != 0 || opt-&gt;robots &gt;= 3)
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
                      {         <I><FONT COLOR="#B22222">/* ignoring disallow: / */</FONT></I>
                        <B><FONT COLOR="#A020F0">if</FONT></B> ((strlen(buff) + strlen(a) + 8) &lt; <B><FONT COLOR="#A020F0">sizeof</FONT></B>(buff)) {
                          strcatbuff(buff, a);
                          strcatbuff(buff, <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>);
                          <B><FONT COLOR="#A020F0">if</FONT></B> ((strlen(infobuff) + strlen(a) + 8) &lt;
                              <B><FONT COLOR="#A020F0">sizeof</FONT></B>(infobuff)) {
                            <B><FONT COLOR="#A020F0">if</FONT></B> (strnotempty(infobuff))
                              strcatbuff(infobuff, <B><FONT COLOR="#BC8F8F">&quot;, &quot;</FONT></B>);
                            strcatbuff(infobuff, a);
                          }
                        }
                      }
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">IGNORE_RESTRICTIVE_ROBOTS</FONT>
                      <B><FONT COLOR="#A020F0">else</FONT></B> {
                        hts_log_print(opt, LOG_NOTICE,
                                      <B><FONT COLOR="#BC8F8F">&quot;Note: %s robots.txt rules are too restrictive, ignoring /&quot;</FONT></B>,
                                      urladr());
                      }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
                    }
                  }
                }
              } <B><FONT COLOR="#A020F0">while</FONT></B>((bptr &lt; r.size) &amp;&amp; (strlen(buff) &lt; (<B><FONT COLOR="#A020F0">sizeof</FONT></B>(buff) - 32)));
              <B><FONT COLOR="#A020F0">if</FONT></B> (strnotempty(buff)) {
                checkrobots_set(&amp;robots, urladr(), buff);
                hts_log_print(opt, LOG_INFO,
                              <B><FONT COLOR="#BC8F8F">&quot;Note: robots.txt forbidden links for %s are: %s&quot;</FONT></B>,
                              urladr(), infobuff);
                hts_log_print(opt, LOG_NOTICE,
                              <B><FONT COLOR="#BC8F8F">&quot;Note: due to %s remote robots.txt rules, links beginning with these path will be forbidden: %s (see in the options to disable this)&quot;</FONT></B>,
                              urladr(), infobuff);
              }
            }
          }
        } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (r.is_write) {        <I><FONT COLOR="#B22222">// déja sauvé sur disque
</FONT></I>          <I><FONT COLOR="#B22222">/*
             if (!ishttperror(r.statuscode))
             HTS_STAT.stat_files++;
             HTS_STAT.stat_bytes+=r.size;
           */</FONT></I>
          <I><FONT COLOR="#B22222">//printf(&quot;ok......\n&quot;);
</FONT></I>        } <B><FONT COLOR="#A020F0">else</FONT></B> {
          <I><FONT COLOR="#B22222">// Si on doit sauver une page HTML sans la scanner, cela signifie que le niveau de
</FONT></I>          <I><FONT COLOR="#B22222">// récursion nous en empêche
</FONT></I>          <I><FONT COLOR="#B22222">// Dans ce cas on met un fichier indiquant ce fait
</FONT></I>          <I><FONT COLOR="#B22222">// Si par la suite on doit retraiter ce fichier avec un niveau de récursion plus
</FONT></I>          <I><FONT COLOR="#B22222">// fort, on supprimera le readme, et on scannera le fichier html!
</FONT></I>          <I><FONT COLOR="#B22222">// note: sauté si store_errpage (càd si page d'erreur, non à scanner!)
</FONT></I>          <B><FONT COLOR="#A020F0">if</FONT></B> ((is_hypertext_mime(opt, r.contenttype, urlfil())) &amp;&amp; (!store_errpage) &amp;&amp; (r.size &gt; 0)) {    <I><FONT COLOR="#B22222">// c'est du html!!
</FONT></I>            <B><FONT COLOR="#228B22">char</FONT></B> BIGSTK tempo[HTS_URLMAXSIZE * 2];
            FILE *fp;

            tempo[0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
            strcpybuff(tempo, savename());
            strcatbuff(tempo, <B><FONT COLOR="#BC8F8F">&quot;.readme&quot;</FONT></B>);

#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_DOSNAME</FONT>
            <I><FONT COLOR="#B22222">// remplacer / par des slash arrière
</FONT></I>            {
              <B><FONT COLOR="#228B22">int</FONT></B> i = 0;

              <B><FONT COLOR="#A020F0">while</FONT></B>(tempo[i]) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (tempo[i] == <B><FONT COLOR="#BC8F8F">'/'</FONT></B>)
                  tempo[i] = <B><FONT COLOR="#BC8F8F">'\\'</FONT></B>;
                i++;
              }
            }
            <I><FONT COLOR="#B22222">// a partir d'ici le slash devient antislash
</FONT></I>#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

            <B><FONT COLOR="#A020F0">if</FONT></B> ((fp = FOPEN(tempo, <B><FONT COLOR="#BC8F8F">&quot;wb&quot;</FONT></B>)) != NULL) {
              fprintf(fp,
                      <B><FONT COLOR="#BC8F8F">&quot;Info-file generated by HTTrack Website Copier &quot;</FONT></B>
                      HTTRACK_VERSION <B><FONT COLOR="#BC8F8F">&quot;%s&quot;</FONT></B> CRLF <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B> CRLF,
                      hts_get_version_info(opt));
              fprintf(fp, <B><FONT COLOR="#BC8F8F">&quot;The file %s has not been scanned by HTS&quot;</FONT></B> CRLF,
                      savename());
              fprintf(fp,
                      <B><FONT COLOR="#BC8F8F">&quot;Some links contained in it may be unreachable locally.&quot;</FONT></B>
                      CRLF);
              fprintf(fp,
                      <B><FONT COLOR="#BC8F8F">&quot;If you want to get these files, you have to set an upper recurse level, &quot;</FONT></B>);
              fprintf(fp, <B><FONT COLOR="#BC8F8F">&quot;and to rescan the URL.&quot;</FONT></B> CRLF);
              fclose(fp);
#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">_WIN32</FONT>
              chmod(tempo, HTS_ACCESS_FILE);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
              usercommand(opt, 0, NULL, fconv(OPT_GET_BUFF(opt), OPT_GET_BUFF_SIZE(opt), tempo), <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>,
                          <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>);
            }

            hts_log_print(opt, LOG_WARNING,
                          <B><FONT COLOR="#BC8F8F">&quot;Warning: store %s without scan: %s&quot;</FONT></B>, r.contenttype,
                          savename());
          } <B><FONT COLOR="#A020F0">else</FONT></B> {
            <B><FONT COLOR="#A020F0">if</FONT></B> ((opt-&gt;getmode &amp; 2) != 0) {      <I><FONT COLOR="#B22222">// ok autorisé
</FONT></I>              hts_log_print(opt, LOG_DEBUG, <B><FONT COLOR="#BC8F8F">&quot;Store %s: %s&quot;</FONT></B>, r.contenttype,
                            savename());
            } <B><FONT COLOR="#A020F0">else</FONT></B> {            <I><FONT COLOR="#B22222">// lien non autorisé! (ex: cgi-bin en html)
</FONT></I>              hts_log_print(opt, LOG_DEBUG,
                            <B><FONT COLOR="#BC8F8F">&quot;non-html file ignored after upload at %s : %s&quot;</FONT></B>,
                            urladr(), urlfil());
              <B><FONT COLOR="#A020F0">if</FONT></B> (r.adr) {
                freet(r.adr);
                r.adr = NULL;
              }
            }
          }

          <I><FONT COLOR="#B22222">//printf(&quot;extern=%s\n&quot;,r.contenttype);
</FONT></I>
          <I><FONT COLOR="#B22222">// ATTENTION C'EST ICI QU'ON SAUVE LE FICHIER!!          
</FONT></I>          <B><FONT COLOR="#A020F0">if</FONT></B> (r.adr != NULL || r.size == 0) {
            file_notify(opt, urladr(), urlfil(), savename(), 1, 1, r.notmodified);
            <B><FONT COLOR="#A020F0">if</FONT></B> (filesave(opt, r.adr, (<B><FONT COLOR="#228B22">int</FONT></B>) r.size, savename(), urladr(), urlfil()) !=
                0) {
              <B><FONT COLOR="#228B22">int</FONT></B> fcheck;

              <B><FONT COLOR="#A020F0">if</FONT></B> ((fcheck = check_fatal_io_errno())) {
                hts_log_print(opt, LOG_ERROR,
                              <B><FONT COLOR="#BC8F8F">&quot;Mirror aborted: disk full or filesystem problems&quot;</FONT></B>);
                opt-&gt;state.exit_xh = -1;        <I><FONT COLOR="#B22222">/* fatal error */</FONT></I>
              }
              hts_log_print(opt, LOG_ERROR | LOG_ERRNO,
                            <B><FONT COLOR="#BC8F8F">&quot;Unable to save file %s&quot;</FONT></B>, savename());
            } <B><FONT COLOR="#A020F0">else</FONT></B> {
              <I><FONT COLOR="#B22222">/*
                 if (!ishttperror(r.statuscode))
                 HTS_STAT.stat_files++;
                 HTS_STAT.stat_bytes+=r.size;
               */</FONT></I>
            }
          }

        }

        <I><FONT COLOR="#B22222">/* Parsing of other media types (java, ram..) */</FONT></I>
        <I><FONT COLOR="#B22222">/*
           if (strfield2(r.contenttype,&quot;audio/x-pn-realaudio&quot;)) {
           hts_log_print(opt, LOG_DEBUG, &quot;(Real Media): parsing %s&quot;,savename());
           if (fexist(savename())) {   // ok, existe bien!
           FILE* fp=FOPEN(savename(),&quot;r+b&quot;);
           if (fp) {
           if (!fseek(fp,0,SEEK_SET)) {
           char BIGSTK line[HTS_URLMAXSIZE*2];
           linput(fp,line,HTS_URLMAXSIZE);
           if (strnotempty(line)) {
           hts_log_print(opt, LOG_DEBUG, &quot;(Real Media): detected %s&quot;,line);
           }
           }
           fclose(fp);
           }
           }
           } else */</FONT></I>

        <I><FONT COLOR="#B22222">/* External modules */</FONT></I>
        <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;parsejava &amp;&amp; (opt-&gt;parsejava &amp; HTSPARSE_NO_CLASS) == 0
            &amp;&amp; fexist(savename())) {
          <B><FONT COLOR="#228B22">char</FONT></B> BIGSTK buff_err_msg[1024];
          htsmoduleStruct BIGSTK str;

          buff_err_msg[0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
          memset(&amp;str, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(str));
          <I><FONT COLOR="#B22222">/* */</FONT></I>
          str.err_msg = buff_err_msg;
          str.filename = savename();
          str.mime = r.contenttype;
          str.url_host = urladr();
          str.url_file = urlfil();
          str.size = (<B><FONT COLOR="#228B22">int</FONT></B>) r.size;
          <I><FONT COLOR="#B22222">/* */</FONT></I>
          str.addLink = htsAddLink;
          <I><FONT COLOR="#B22222">/* */</FONT></I>
          str.opt = opt;
          str.sback = sback;
          str.cache = &amp;cache;
          str.hashptr = hashptr;
          str.numero_passe = numero_passe;
          str.ptr_ = &amp;ptr;

          <I><FONT COLOR="#B22222">/* Parse if recognized */</FONT></I>
          <B><FONT COLOR="#A020F0">switch</FONT></B> (hts_parse_externals(&amp;str)) {
          <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">1</FONT></B>:
            hts_log_print(opt, LOG_DEBUG,
                          <B><FONT COLOR="#BC8F8F">&quot;(External module): parsed successfully %s&quot;</FONT></B>,
                          savename());
            <B><FONT COLOR="#A020F0">break</FONT></B>;
          <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">0</FONT></B>:
            hts_log_print(opt, LOG_DEBUG,
                          <B><FONT COLOR="#BC8F8F">&quot;(External module): couldn't parse successfully %s : %s&quot;</FONT></B>,
                          savename(), str.err_msg);
            <B><FONT COLOR="#A020F0">break</FONT></B>;
          }
        }

      }                         <I><FONT COLOR="#B22222">// text/html ou autre
</FONT></I>
      <I><FONT COLOR="#B22222">/* Post-processing */</FONT></I>
      <B><FONT COLOR="#A020F0">if</FONT></B> (fexist(savename())) {
        usercommand(opt, 0, NULL, savename(), urladr(), urlfil());
      }

    }                           <I><FONT COLOR="#B22222">// if !error
</FONT></I>
  <B><FONT COLOR="#5F9EA0">jump_if_done</FONT></B>:
    <I><FONT COLOR="#B22222">// libérer les liens
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B> (r.adr) {
      freet(r.adr);
      r.adr = NULL;
    }                           <I><FONT COLOR="#B22222">// libérer la mémoire!
</FONT></I>
    <I><FONT COLOR="#B22222">// prochain lien
</FONT></I>    ptr++;

    <I><FONT COLOR="#B22222">// faut-il sauter le(s) lien(s) suivant(s)? (fichiers images à passer après les html)
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;getmode &amp; 4) {     <I><FONT COLOR="#B22222">// sauver les non html après
</FONT></I>      <I><FONT COLOR="#B22222">// sauter les fichiers selon la passe
</FONT></I>      <B><FONT COLOR="#A020F0">if</FONT></B> (!numero_passe) {
        <B><FONT COLOR="#A020F0">while</FONT></B>((ptr &lt; opt-&gt;lien_tot) ? (heap(ptr)-&gt;pass2) : 0)
          ptr++;
      } <B><FONT COLOR="#A020F0">else</FONT></B> {
        <B><FONT COLOR="#A020F0">while</FONT></B>((ptr &lt; opt-&gt;lien_tot) ? (!heap(ptr)-&gt;pass2) : 0)
          ptr++;
      }
      <B><FONT COLOR="#A020F0">if</FONT></B> (ptr &gt;= opt-&gt;lien_tot) {    <I><FONT COLOR="#B22222">// fin de boucle
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (!numero_passe) {    <I><FONT COLOR="#B22222">// première boucle
</FONT></I>          hts_log_print(opt, LOG_DEBUG, <B><FONT COLOR="#BC8F8F">&quot;Now getting non-html files...&quot;</FONT></B>);
          numero_passe = 1;     <I><FONT COLOR="#B22222">// seconde boucle
</FONT></I>          ptr = 0;
          <I><FONT COLOR="#B22222">// prochain pass2
</FONT></I>          <B><FONT COLOR="#A020F0">while</FONT></B>((ptr &lt; opt-&gt;lien_tot) ? (!heap(ptr)-&gt;pass2) : 0)
            ptr++;

          <I><FONT COLOR="#B22222">//printf(&quot;first link==%d\n&quot;);
</FONT></I>
        }
      }
    }
    <I><FONT COLOR="#B22222">// copy abort state if necessary from outside
</FONT></I>    <I><FONT COLOR="#B22222">//if (!exit_xh &amp;&amp; opt-&gt;state.exit_xh) {
</FONT></I>    <I><FONT COLOR="#B22222">//  exit_xh=opt-&gt;state.exit_xh;
</FONT></I>    <I><FONT COLOR="#B22222">//}
</FONT></I>    <I><FONT COLOR="#B22222">// a-t-on dépassé le quota?
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B> (!back_checkmirror(opt)) {
      ptr = opt-&gt;lien_tot;
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;state.exit_xh) {    <I><FONT COLOR="#B22222">// sortir
</FONT></I>      <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;state.exit_xh == 1) {
        hts_log_print(opt, LOG_ERROR, <B><FONT COLOR="#BC8F8F">&quot;Exit requested by shell or user&quot;</FONT></B>);
      } <B><FONT COLOR="#A020F0">else</FONT></B> {
        hts_log_print(opt, LOG_ERROR, <B><FONT COLOR="#BC8F8F">&quot;Exit requested by engine&quot;</FONT></B>);
      }
      ptr = opt-&gt;lien_tot;
    }
  } <B><FONT COLOR="#A020F0">while</FONT></B>(ptr &lt; opt-&gt;lien_tot);
  <I><FONT COLOR="#B22222">//
</FONT></I>  <I><FONT COLOR="#B22222">//
</FONT></I>  <I><FONT COLOR="#B22222">//
</FONT></I>
  <I><FONT COLOR="#B22222">/*
     Ensure the index is being closed
   */</FONT></I>
  HT_INDEX_END;

  <I><FONT COLOR="#B22222">/* 
     updating-a-remotely-deteted-website hack
     no much data transferred, no data saved
     &lt;no files successfulyl saved&gt;
     we assume that something was bad (no connection)
     just backup old cache and restore everything
   */</FONT></I>
  <B><FONT COLOR="#A020F0">if</FONT></B> ((HTS_STAT.stat_files &lt;= 0)
      &amp;&amp; (HTS_STAT.HTS_TOTAL_RECV &lt; 32768)      <I><FONT COLOR="#B22222">/* should be fine */</FONT></I>
    ) {
    hts_log_print(opt, LOG_NOTICE,
                  <B><FONT COLOR="#BC8F8F">&quot;No data seems to have been transferred during this session! : restoring previous one!&quot;</FONT></B>);
    XH_uninit;
    <B><FONT COLOR="#A020F0">if</FONT></B> ((fexist
         (fconcat
          (OPT_GET_BUFF(opt), OPT_GET_BUFF_SIZE(opt), StringBuff(opt-&gt;path_log), <B><FONT COLOR="#BC8F8F">&quot;hts-cache/old.dat&quot;</FONT></B>)))
        &amp;&amp;
        (fexist
         (fconcat
          (OPT_GET_BUFF(opt), OPT_GET_BUFF_SIZE(opt), StringBuff(opt-&gt;path_log),
           <B><FONT COLOR="#BC8F8F">&quot;hts-cache/old.ndx&quot;</FONT></B>)))) {
      remove(fconcat
             (OPT_GET_BUFF(opt), OPT_GET_BUFF_SIZE(opt), StringBuff(opt-&gt;path_log),
              <B><FONT COLOR="#BC8F8F">&quot;hts-cache/new.dat&quot;</FONT></B>));
      remove(fconcat
             (OPT_GET_BUFF(opt), OPT_GET_BUFF_SIZE(opt), StringBuff(opt-&gt;path_log),
              <B><FONT COLOR="#BC8F8F">&quot;hts-cache/new.ndx&quot;</FONT></B>));
      remove(fconcat
             (OPT_GET_BUFF(opt), OPT_GET_BUFF_SIZE(opt), StringBuff(opt-&gt;path_log),
              <B><FONT COLOR="#BC8F8F">&quot;hts-cache/new.lst&quot;</FONT></B>));
      remove(fconcat
             (OPT_GET_BUFF(opt), OPT_GET_BUFF_SIZE(opt), StringBuff(opt-&gt;path_log),
              <B><FONT COLOR="#BC8F8F">&quot;hts-cache/new.txt&quot;</FONT></B>));
      rename(fconcat
             (OPT_GET_BUFF(opt), OPT_GET_BUFF_SIZE(opt), StringBuff(opt-&gt;path_log),
              <B><FONT COLOR="#BC8F8F">&quot;hts-cache/old.dat&quot;</FONT></B>), fconcat(OPT_GET_BUFF(opt), OPT_GET_BUFF_SIZE(opt),
                                            StringBuff(opt-&gt;path_log),
                                            <B><FONT COLOR="#BC8F8F">&quot;hts-cache/new.dat&quot;</FONT></B>));
      rename(fconcat
             (OPT_GET_BUFF(opt), OPT_GET_BUFF_SIZE(opt), StringBuff(opt-&gt;path_log),
              <B><FONT COLOR="#BC8F8F">&quot;hts-cache/old.ndx&quot;</FONT></B>), fconcat(OPT_GET_BUFF(opt), OPT_GET_BUFF_SIZE(opt),
                                            StringBuff(opt-&gt;path_log),
                                            <B><FONT COLOR="#BC8F8F">&quot;hts-cache/new.ndx&quot;</FONT></B>));
      rename(fconcat
             (OPT_GET_BUFF(opt), OPT_GET_BUFF_SIZE(opt), StringBuff(opt-&gt;path_log),
              <B><FONT COLOR="#BC8F8F">&quot;hts-cache/old.lst&quot;</FONT></B>), fconcat(OPT_GET_BUFF(opt), OPT_GET_BUFF_SIZE(opt),
                                            StringBuff(opt-&gt;path_log),
                                            <B><FONT COLOR="#BC8F8F">&quot;hts-cache/new.lst&quot;</FONT></B>));
      rename(fconcat
             (OPT_GET_BUFF(opt), OPT_GET_BUFF_SIZE(opt), StringBuff(opt-&gt;path_log),
              <B><FONT COLOR="#BC8F8F">&quot;hts-cache/old.txt&quot;</FONT></B>), fconcat(OPT_GET_BUFF(opt), OPT_GET_BUFF_SIZE(opt),
                                            StringBuff(opt-&gt;path_log),
                                            <B><FONT COLOR="#BC8F8F">&quot;hts-cache/new.txt&quot;</FONT></B>));
    }
    opt-&gt;state.exit_xh = 2;     <I><FONT COLOR="#B22222">/* interrupted (no connection detected) */</FONT></I>
    <B><FONT COLOR="#A020F0">return</FONT></B> 1;
  }
  <I><FONT COLOR="#B22222">// info text  
</FONT></I>  <B><FONT COLOR="#A020F0">if</FONT></B> (cache.txt) {
    fclose(cache.txt);
    cache.txt = NULL;
  }
  <I><FONT COLOR="#B22222">// purger!
</FONT></I>  <B><FONT COLOR="#A020F0">if</FONT></B> (cache.lst) {
    fclose(cache.lst);
    cache.lst = opt-&gt;state.strc.lst = NULL;
    <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;delete_old) {
      FILE *old_lst, *new_lst;

      <I><FONT COLOR="#B22222">//
</FONT></I>      opt-&gt;state._hts_in_html_parsing = 3;
      <I><FONT COLOR="#B22222">//
</FONT></I>      old_lst =
        fopen(fconcat
              (OPT_GET_BUFF(opt), OPT_GET_BUFF_SIZE(opt), StringBuff(opt-&gt;path_log),
               <B><FONT COLOR="#BC8F8F">&quot;hts-cache/old.lst&quot;</FONT></B>), <B><FONT COLOR="#BC8F8F">&quot;rb&quot;</FONT></B>);
      <B><FONT COLOR="#A020F0">if</FONT></B> (old_lst) {
        <B><FONT COLOR="#228B22">const</FONT></B> size_t sz =
          off_t_to_size_t(fsize(fconcat
                (OPT_GET_BUFF(opt), OPT_GET_BUFF_SIZE(opt), StringBuff(opt-&gt;path_log),
                 <B><FONT COLOR="#BC8F8F">&quot;hts-cache/new.lst&quot;</FONT></B>)));
        new_lst =
          fopen(fconcat
                (OPT_GET_BUFF(opt), OPT_GET_BUFF_SIZE(opt), StringBuff(opt-&gt;path_log),
                 <B><FONT COLOR="#BC8F8F">&quot;hts-cache/new.lst&quot;</FONT></B>), <B><FONT COLOR="#BC8F8F">&quot;rb&quot;</FONT></B>);
        <B><FONT COLOR="#A020F0">if</FONT></B> (new_lst != NULL &amp;&amp; sz != (size_t) -1) {
          <B><FONT COLOR="#228B22">char</FONT></B> *adr = (<B><FONT COLOR="#228B22">char</FONT></B> *) malloct(sz);

          <B><FONT COLOR="#A020F0">if</FONT></B> (adr) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (fread(adr, 1, sz, new_lst) == sz) {
              <B><FONT COLOR="#228B22">char</FONT></B> line[1100];
              <B><FONT COLOR="#228B22">int</FONT></B> purge = 0;

              <B><FONT COLOR="#A020F0">while</FONT></B>(!feof(old_lst)) {
                linput(old_lst, line, 1000);
                <B><FONT COLOR="#A020F0">if</FONT></B> (!strstr(adr, line)) {       <I><FONT COLOR="#B22222">// fichier non trouvé dans le nouveau?
</FONT></I>                  <B><FONT COLOR="#228B22">char</FONT></B> BIGSTK file[HTS_URLMAXSIZE * 2];

                  strcpybuff(file, StringBuff(opt-&gt;path_html));
                  strcatbuff(file, line + 1);
                  file[strlen(file) - 1] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
                  <B><FONT COLOR="#A020F0">if</FONT></B> (fexist(file)) {   <I><FONT COLOR="#B22222">// toujours sur disque: virer
</FONT></I>                    hts_log_print(opt, LOG_INFO, <B><FONT COLOR="#BC8F8F">&quot;Purging %s&quot;</FONT></B>, file);
                    remove(file);
                    purge = 1;
                  }
                }
              }
              {
                fseek(old_lst, 0, SEEK_SET);
                <B><FONT COLOR="#A020F0">while</FONT></B>(!feof(old_lst)) {
                  linput(old_lst, line, 1000);
                  <B><FONT COLOR="#A020F0">while</FONT></B>(strnotempty(line) &amp;&amp; (line[strlen(line) - 1] != <B><FONT COLOR="#BC8F8F">'/'</FONT></B>)
                        &amp;&amp; (line[strlen(line) - 1] != <B><FONT COLOR="#BC8F8F">'\\'</FONT></B>)) {
                    line[strlen(line) - 1] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
                  }
                  <B><FONT COLOR="#A020F0">if</FONT></B> (strnotempty(line))
                    line[strlen(line) - 1] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
                  <B><FONT COLOR="#A020F0">if</FONT></B> (strnotempty(line))
                    <B><FONT COLOR="#A020F0">if</FONT></B> (!strstr(adr, line)) {   <I><FONT COLOR="#B22222">// non trouvé?
</FONT></I>                      <B><FONT COLOR="#228B22">char</FONT></B> BIGSTK file[HTS_URLMAXSIZE * 2];

                      strcpybuff(file, StringBuff(opt-&gt;path_html));
                      strcatbuff(file, line + 1);
                      <B><FONT COLOR="#A020F0">while</FONT></B>((strnotempty(file)) &amp;&amp; (rmdir(file) == 0)) {        <I><FONT COLOR="#B22222">// ok, éliminé (existait)
</FONT></I>                        purge = 1;
                        <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;log) {
                          hts_log_print(opt, LOG_INFO, <B><FONT COLOR="#BC8F8F">&quot;Purging directory %s/&quot;</FONT></B>,
                                        file);
                          <B><FONT COLOR="#A020F0">while</FONT></B>(strnotempty(file)
                                &amp;&amp; (file[strlen(file) - 1] != <B><FONT COLOR="#BC8F8F">'/'</FONT></B>)
                                &amp;&amp; (file[strlen(file) - 1] != <B><FONT COLOR="#BC8F8F">'\\'</FONT></B>)) {
                            file[strlen(file) - 1] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
                          }
                          <B><FONT COLOR="#A020F0">if</FONT></B> (strnotempty(file))
                            file[strlen(file) - 1] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
                        }
                      }
                    }
                }
              }
              <I><FONT COLOR="#B22222">//
</FONT></I>              <B><FONT COLOR="#A020F0">if</FONT></B> (!purge) {
                hts_log_print(opt, LOG_INFO, <B><FONT COLOR="#BC8F8F">&quot;No files purged&quot;</FONT></B>);
              }
            }
            freet(adr);
          }
          fclose(new_lst);
        }
        fclose(old_lst);
      }
      <I><FONT COLOR="#B22222">//
</FONT></I>      opt-&gt;state._hts_in_html_parsing = 0;
    }
  }
  <I><FONT COLOR="#B22222">// fin purge!
</FONT></I>
  <I><FONT COLOR="#B22222">// Indexation
</FONT></I>  <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;kindex)
    index_finish(StringBuff(opt-&gt;path_html), opt-&gt;kindex);

  <I><FONT COLOR="#B22222">// afficher résumé dans log
</FONT></I>  <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;log != NULL) {
    <B><FONT COLOR="#228B22">char</FONT></B> BIGSTK finalInfo[8192];
    <B><FONT COLOR="#228B22">int</FONT></B> error = fspc(opt, NULL, <B><FONT COLOR="#BC8F8F">&quot;error&quot;</FONT></B>);
    <B><FONT COLOR="#228B22">int</FONT></B> warning = fspc(opt, NULL, <B><FONT COLOR="#BC8F8F">&quot;warning&quot;</FONT></B>);
    <B><FONT COLOR="#228B22">int</FONT></B> info = fspc(opt, NULL, <B><FONT COLOR="#BC8F8F">&quot;info&quot;</FONT></B>);
    <B><FONT COLOR="#228B22">char</FONT></B> BIGSTK htstime[256];
    <B><FONT COLOR="#228B22">char</FONT></B> BIGSTK infoupdated[256];

    <I><FONT COLOR="#B22222">// int n=(int) (stat_loaded/(time_local()-HTS_STAT.stat_timestart));
</FONT></I>    LLint n =
      (LLint) (HTS_STAT.HTS_TOTAL_RECV /
               (max(1, time_local() - HTS_STAT.stat_timestart)));

    sec2str(htstime, time_local() - HTS_STAT.stat_timestart);
    <I><FONT COLOR="#B22222">//sprintf(finalInfo + strlen(finalInfo),LF&quot;HTS-mirror complete in %s : %d links scanned, %d files written (%d bytes overall) [%d bytes received at %d bytes/sec]&quot;LF,htstime,lien_tot-1,HTS_STAT.stat_files,stat_bytes,stat_loaded,n);
</FONT></I>    infoupdated[0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
    <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;is_update) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (HTS_STAT.stat_updated_files &gt; 0) {
        sprintf(infoupdated, <B><FONT COLOR="#BC8F8F">&quot;, %d files updated&quot;</FONT></B>,
                (<B><FONT COLOR="#228B22">int</FONT></B>) HTS_STAT.stat_updated_files);
      } <B><FONT COLOR="#A020F0">else</FONT></B> {
        sprintf(infoupdated, <B><FONT COLOR="#BC8F8F">&quot;, no files updated&quot;</FONT></B>);
      }
    }
    finalInfo[0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
    sprintf(finalInfo + strlen(finalInfo),
            <B><FONT COLOR="#BC8F8F">&quot;HTTrack Website Copier/&quot;</FONT></B> HTTRACK_VERSION
            <B><FONT COLOR="#BC8F8F">&quot; mirror complete in %s : &quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;%d links scanned, %d files written (&quot;</FONT></B>
            LLintP <B><FONT COLOR="#BC8F8F">&quot; bytes overall)%s &quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;[&quot;</FONT></B> LLintP <B><FONT COLOR="#BC8F8F">&quot; bytes received at &quot;</FONT></B> LLintP
            <B><FONT COLOR="#BC8F8F">&quot; bytes/sec]&quot;</FONT></B>, htstime, (<B><FONT COLOR="#228B22">int</FONT></B>) opt-&gt;lien_tot - 1,
            (<B><FONT COLOR="#228B22">int</FONT></B>) HTS_STAT.stat_files, (LLint) HTS_STAT.stat_bytes, infoupdated,
            (LLint) HTS_STAT.HTS_TOTAL_RECV, (LLint) n);

    <B><FONT COLOR="#A020F0">if</FONT></B> (HTS_STAT.total_packed &gt; 0 &amp;&amp; HTS_STAT.total_unpacked &gt; 0) {
      <B><FONT COLOR="#228B22">int</FONT></B> packed_ratio =
        (<B><FONT COLOR="#228B22">int</FONT></B>) ((LLint) (HTS_STAT.total_packed * 100) / HTS_STAT.total_unpacked);
      sprintf(finalInfo + strlen(finalInfo),
              <B><FONT COLOR="#BC8F8F">&quot;, &quot;</FONT></B> LLintP
              <B><FONT COLOR="#BC8F8F">&quot; bytes transferred using HTTP compression in %d files, ratio %d%%&quot;</FONT></B>,
              (LLint) HTS_STAT.total_unpacked, HTS_STAT.total_packedfiles,
              (<B><FONT COLOR="#228B22">int</FONT></B>) packed_ratio);
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (!opt-&gt;nokeepalive &amp;&amp; HTS_STAT.stat_sockid &gt; 0
        &amp;&amp; HTS_STAT.stat_nrequests &gt; HTS_STAT.stat_sockid) {
      <B><FONT COLOR="#228B22">int</FONT></B> rq = (HTS_STAT.stat_nrequests * 10) / HTS_STAT.stat_sockid;

      sprintf(finalInfo + strlen(finalInfo), <B><FONT COLOR="#BC8F8F">&quot;, %d.%d requests per connection&quot;</FONT></B>,
              rq / 10, rq % 10);
    }
    sprintf(finalInfo + strlen(finalInfo), LF);
    <B><FONT COLOR="#A020F0">if</FONT></B> (error)
      sprintf(finalInfo + strlen(finalInfo),
              <B><FONT COLOR="#BC8F8F">&quot;(%d errors, %d warnings, %d messages)&quot;</FONT></B> LF, error, warning, info);
    <B><FONT COLOR="#A020F0">else</FONT></B>
      sprintf(finalInfo + strlen(finalInfo),
              <B><FONT COLOR="#BC8F8F">&quot;(No errors, %d warnings, %d messages)&quot;</FONT></B> LF, warning, info);

    <I><FONT COLOR="#B22222">// Log
</FONT></I>    fprintf(opt-&gt;log, LF <B><FONT COLOR="#BC8F8F">&quot;%s&quot;</FONT></B>, finalInfo);

    <I><FONT COLOR="#B22222">// Close ZIP
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B> (cache.zipOutput) {
      zipClose(cache.zipOutput, finalInfo);
      cache.zipOutput = NULL;
    }
  }
  <I><FONT COLOR="#B22222">// fin afficher résumé dans log
</FONT></I>
  <I><FONT COLOR="#B22222">// ending
</FONT></I>  usercommand(opt, 0, NULL, NULL, NULL, NULL);

  <I><FONT COLOR="#B22222">// désallocation mémoire &amp; buffers
</FONT></I>  XH_uninit;

  <B><FONT COLOR="#A020F0">return</FONT></B> 1;                     <I><FONT COLOR="#B22222">// OK
</FONT></I>}

<I><FONT COLOR="#B22222">// version 2 pour le reste
</FONT></I>
<I><FONT COLOR="#B22222">// Estimate transfer rate
</FONT></I><I><FONT COLOR="#B22222">// a little bit complex, but not too much
</FONT></I><I><FONT COLOR="#B22222">/*
  .. : idle
  ^  : event

  ----|----|----|----|----|----|----|----|----&gt;
   1    2    3    4    5    6    7    8    9   time (seconds)
  ----|----|----|----|----|----|----|----|----&gt;
  ^........^.........^.........^.........^.... timer 0
  ----^.........^.........^.........^......... timer 1
           0    1    0    1    0    1    0     timer N sets its statistics
      *         *         *         *          timer 0 resync timer 1

  Therefore, each seconds, we resync the transfer rate with 2-seconds

*/</FONT></I>
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">engine_stats</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>) {
#<B><FONT COLOR="#5F9EA0">if</FONT></B> 0
  <B><FONT COLOR="#228B22">static</FONT></B> FILE *debug_fp = NULL; <I><FONT COLOR="#B22222">/* ok */</FONT></I>

  <B><FONT COLOR="#A020F0">if</FONT></B> (!debug_fp)
    debug_fp = fopen(<B><FONT COLOR="#BC8F8F">&quot;esstat.txt&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;wb&quot;</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
  HTS_STAT.stat_nsocket = HTS_STAT.stat_errors = HTS_STAT.nbk = 0;
  HTS_STAT.nb = 0;
  <B><FONT COLOR="#A020F0">if</FONT></B> (HTS_STAT.HTS_TOTAL_RECV &gt; 2048) {
    TStamp cdif = mtime_local();
    <B><FONT COLOR="#228B22">int</FONT></B> i;

    <B><FONT COLOR="#A020F0">for</FONT></B>(i = 0; i &lt; 2; i++) {
      <B><FONT COLOR="#A020F0">if</FONT></B> ((cdif - HTS_STAT.istat_timestart[i]) &gt;= 2000) {
        TStamp dif;

#<B><FONT COLOR="#5F9EA0">if</FONT></B> 0
        fprintf(debug_fp, <B><FONT COLOR="#BC8F8F">&quot;set timer %d\n&quot;</FONT></B>, i);
        fflush(debug_fp);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
        dif = cdif - HTS_STAT.istat_timestart[i];
        <B><FONT COLOR="#A020F0">if</FONT></B> ((TStamp) (dif / 1000) &gt; 0) {
          LLint byt = (HTS_STAT.HTS_TOTAL_RECV - HTS_STAT.istat_bytes[i]);

          HTS_STAT.rate = (LLint) ((TStamp) ((TStamp) byt / (dif / 1000)));
          HTS_STAT.istat_idlasttimer = i;       <I><FONT COLOR="#B22222">// this timer recently sets the stats
</FONT></I>          <I><FONT COLOR="#B22222">//
</FONT></I>          HTS_STAT.istat_bytes[i] = HTS_STAT.HTS_TOTAL_RECV;
          HTS_STAT.istat_timestart[i] = cdif;
        }
        <B><FONT COLOR="#A020F0">return</FONT></B> 1;               <I><FONT COLOR="#B22222">/* refreshed */</FONT></I>
      }
    }

    <I><FONT COLOR="#B22222">// resynchronization between timer 0 (master) and 1 (slave)
</FONT></I>    <I><FONT COLOR="#B22222">// timer #0 resync timer #1 when reaching 1 second limit
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B> (HTS_STAT.istat_reference01 != HTS_STAT.istat_timestart[0]) {
      <B><FONT COLOR="#A020F0">if</FONT></B> ((cdif - HTS_STAT.istat_timestart[0]) &gt;= 1000) {
#<B><FONT COLOR="#5F9EA0">if</FONT></B> 0
        fprintf(debug_fp, <B><FONT COLOR="#BC8F8F">&quot;resync timer 1\n&quot;</FONT></B>);
        fflush(debug_fp);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
        HTS_STAT.istat_bytes[1] = HTS_STAT.HTS_TOTAL_RECV;
        HTS_STAT.istat_timestart[1] = cdif;
        HTS_STAT.istat_reference01 = HTS_STAT.istat_timestart[0];
      }
    }

  }
  <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">_FILTERS</FONT>     (*opt-&gt;filters.filters)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">_FILTERS_PTR</FONT> (opt-&gt;filters.filptr)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">_ROBOTS</FONT>      ((robots_wizard*)opt-&gt;robotsptr)

<I><FONT COLOR="#B22222">// bannir host (trop lent etc)
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">host_ban</FONT></B>(httrackp * opt, <B><FONT COLOR="#228B22">int</FONT></B> ptr,
              struct_back * sback, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *host) {
  lien_back *<B><FONT COLOR="#228B22">const</FONT></B> back = sback-&gt;lnk;
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> back_max = sback-&gt;count;

  <I><FONT COLOR="#B22222">//int l;
</FONT></I>  <B><FONT COLOR="#228B22">int</FONT></B> i;

  <B><FONT COLOR="#A020F0">if</FONT></B> (host[0] == <B><FONT COLOR="#BC8F8F">'!'</FONT></B>)
    <B><FONT COLOR="#A020F0">return</FONT></B>;                     <I><FONT COLOR="#B22222">// erreur.. déja cancellé.. bizarre.. devrait pas arriver
</FONT></I>
  <I><FONT COLOR="#B22222">/* sanity check */</FONT></I>
  <B><FONT COLOR="#A020F0">if</FONT></B> (*_FILTERS_PTR + 1 &gt;= opt-&gt;maxfilter) {
    opt-&gt;maxfilter += HTS_FILTERSINC;
    <B><FONT COLOR="#A020F0">if</FONT></B> (filters_init(&amp;_FILTERS, opt-&gt;maxfilter, HTS_FILTERSINC) == 0) {
      printf(<B><FONT COLOR="#BC8F8F">&quot;PANIC! : Too many filters : &gt;%d [%d]\n&quot;</FONT></B>, *_FILTERS_PTR, __LINE__);
      hts_log_print(opt, LOG_PANIC, <B><FONT COLOR="#BC8F8F">&quot;Too many filters, giving up..(&gt;%d)&quot;</FONT></B>,
                    *_FILTERS_PTR);
      hts_log_print(opt, LOG_INFO,
                    <B><FONT COLOR="#BC8F8F">&quot;To avoid that: use #F option for more filters (example: -#F5000)&quot;</FONT></B>);
      assertf(<B><FONT COLOR="#BC8F8F">&quot;too many filters - giving up&quot;</FONT></B> == NULL);
    }
  }
  <I><FONT COLOR="#B22222">// interdire host
</FONT></I>  assertf((*_FILTERS_PTR) &lt; opt-&gt;maxfilter);
  <B><FONT COLOR="#A020F0">if</FONT></B> (*_FILTERS_PTR &lt; opt-&gt;maxfilter) {
    strcpybuff(_FILTERS[*_FILTERS_PTR], <B><FONT COLOR="#BC8F8F">&quot;-&quot;</FONT></B>);
    strcatbuff(_FILTERS[*_FILTERS_PTR], host);
    strcatbuff(_FILTERS[*_FILTERS_PTR], <B><FONT COLOR="#BC8F8F">&quot;/*&quot;</FONT></B>);  <I><FONT COLOR="#B22222">// host/ * interdit
</FONT></I>    (*_FILTERS_PTR)++;
  }
  <I><FONT COLOR="#B22222">// oups
</FONT></I>  <B><FONT COLOR="#A020F0">if</FONT></B> (strlen(host) &lt;= 1) {      <I><FONT COLOR="#B22222">// euhh?? longueur &lt;= 1
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B> (strcmp(host, <B><FONT COLOR="#BC8F8F">&quot;file://&quot;</FONT></B>)) {
      <I><FONT COLOR="#B22222">//## if (host[0]!=lOCAL_CHAR) {  // pas local
</FONT></I>      hts_log_print(opt, LOG_PANIC,
                    <B><FONT COLOR="#BC8F8F">&quot;PANIC! HostCancel detected memory leaks [char %d]&quot;</FONT></B>,
                    host[0]);
      <B><FONT COLOR="#A020F0">return</FONT></B>;                   <I><FONT COLOR="#B22222">// purée
</FONT></I>    }
  }
  <I><FONT COLOR="#B22222">// couper connexion
</FONT></I>  <B><FONT COLOR="#A020F0">for</FONT></B>(i = 0; i &lt; back_max; i++) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status &gt;= 0)    <I><FONT COLOR="#B22222">// réception OU prêt
</FONT></I>      <B><FONT COLOR="#A020F0">if</FONT></B> (strfield2(back[i].url_adr, host)) {
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_DEBUG_CLOSESOCK</FONT>
        DEBUG_W(<B><FONT COLOR="#BC8F8F">&quot;host control: deletehttp\n&quot;</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
        back[i].status = 0;     <I><FONT COLOR="#B22222">// terminé
</FONT></I>        back_set_finished(sback, i);
        <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.soc != INVALID_SOCKET)
          deletehttp(&amp;back[i].r);
        back[i].r.soc = INVALID_SOCKET;
        back[i].r.statuscode = STATUSCODE_TIMEOUT;      <I><FONT COLOR="#B22222">// timeout (peu importe si c'est un traffic jam)
</FONT></I>        strcpybuff(back[i].r.msg, <B><FONT COLOR="#BC8F8F">&quot;Link Cancelled by host control&quot;</FONT></B>);
        hts_log_print(opt, LOG_DEBUG, <B><FONT COLOR="#BC8F8F">&quot;Shutdown: %s%s&quot;</FONT></B>, back[i].url_adr,
                      back[i].url_fil);
      }
  }

  <I><FONT COLOR="#B22222">// effacer liens
</FONT></I>  <I><FONT COLOR="#B22222">//l=strlen(host);
</FONT></I>  <B><FONT COLOR="#A020F0">for</FONT></B>(i = 0; i &lt; opt-&gt;lien_tot; i++) {
    <I><FONT COLOR="#B22222">//if (heap(i)-&gt;adr_len==l) {    // même taille de chaîne
</FONT></I>    <I><FONT COLOR="#B22222">// Calcul de taille sécurisée
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B> (heap(i)) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (heap(i)-&gt;adr) {
        <B><FONT COLOR="#228B22">int</FONT></B> l = 0;

        <B><FONT COLOR="#A020F0">while</FONT></B>((heap(i)-&gt;adr[l]) &amp;&amp; (l &lt; 1020))
          l++;
        <B><FONT COLOR="#A020F0">if</FONT></B> ((l &gt; 0) &amp;&amp; (l &lt; 1020)) {    <I><FONT COLOR="#B22222">// sécurité
</FONT></I>          <B><FONT COLOR="#A020F0">if</FONT></B> (strfield2(jump_identification_const(heap(i)-&gt;adr), host)) {    <I><FONT COLOR="#B22222">// host
</FONT></I>            hts_log_print(opt, LOG_DEBUG, <B><FONT COLOR="#BC8F8F">&quot;Cancel: %s%s&quot;</FONT></B>, heap(i)-&gt;adr,
                          heap(i)-&gt;fil);
            hts_invalidate_link(opt, i);  <I><FONT COLOR="#B22222">// invalidate hashtable entry
</FONT></I>            <I><FONT COLOR="#B22222">// on efface pas le hash, because si on rencontre le lien, reverif sav..
</FONT></I>          }
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
          <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;log != NULL) {
            <B><FONT COLOR="#228B22">char</FONT></B> dmp[1040];

            dmp[0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
            strncatbuff(dmp, heap(i)-&gt;adr, 1024);
            hts_log_print(opt, LOG_WARNING,
                          <B><FONT COLOR="#BC8F8F">&quot;WARNING! HostCancel detected memory leaks [len %d at %d]&quot;</FONT></B>,
                          l, i);
            hts_log_print(opt, LOG_WARNING,
                          <B><FONT COLOR="#BC8F8F">&quot;dump 1024 bytes (address %p): &quot;</FONT></B> LF <B><FONT COLOR="#BC8F8F">&quot;%s&quot;</FONT></B>,
                          heap(i)-&gt;adr, dmp);
          }
        }
      } <B><FONT COLOR="#A020F0">else</FONT></B> {
        hts_log_print(opt, LOG_WARNING,
                      <B><FONT COLOR="#BC8F8F">&quot;WARNING! HostCancel detected memory leaks [adr at %d]&quot;</FONT></B>,
                      i);
      }
    } <B><FONT COLOR="#A020F0">else</FONT></B> {
      hts_log_print(opt, LOG_WARNING,
                    <B><FONT COLOR="#BC8F8F">&quot;WARNING! HostCancel detected memory leaks [null at %d]&quot;</FONT></B>,
                    i);
    }
    <I><FONT COLOR="#B22222">//}
</FONT></I>  }
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">filters_init</FONT></B>(<B><FONT COLOR="#228B22">char</FONT></B> ***ptrfilters, <B><FONT COLOR="#228B22">int</FONT></B> maxfilter, <B><FONT COLOR="#228B22">int</FONT></B> filterinc) {
  <B><FONT COLOR="#228B22">char</FONT></B> **filters = *ptrfilters;
  <B><FONT COLOR="#228B22">int</FONT></B> filter_max = maximum(maxfilter, 128);

  <B><FONT COLOR="#A020F0">if</FONT></B> (filters == NULL) {
    filters = (<B><FONT COLOR="#228B22">char</FONT></B> **) malloct(<B><FONT COLOR="#A020F0">sizeof</FONT></B>(<B><FONT COLOR="#228B22">char</FONT></B> *) * (filter_max + 2));
    memset(filters, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(<B><FONT COLOR="#228B22">char</FONT></B> *) * (filter_max + 2));      <I><FONT COLOR="#B22222">// filters[0] == 0
</FONT></I>  } <B><FONT COLOR="#A020F0">else</FONT></B> {
    filters = (<B><FONT COLOR="#228B22">char</FONT></B> **) realloct(filters, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(<B><FONT COLOR="#228B22">char</FONT></B> *) * (filter_max + 2));
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (filters) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (filters[0] == NULL) {
      filters[0] =
        (<B><FONT COLOR="#228B22">char</FONT></B> *) malloct(<B><FONT COLOR="#A020F0">sizeof</FONT></B>(<B><FONT COLOR="#228B22">char</FONT></B>) * (filter_max + 2) *
                         (HTS_URLMAXSIZE * 2));
      memset(filters[0], 0,
             <B><FONT COLOR="#A020F0">sizeof</FONT></B>(<B><FONT COLOR="#228B22">char</FONT></B>) * (filter_max + 2) * (HTS_URLMAXSIZE * 2));
    } <B><FONT COLOR="#A020F0">else</FONT></B> {
      filters[0] =
        (<B><FONT COLOR="#228B22">char</FONT></B> *) realloct(filters[0],
                          <B><FONT COLOR="#A020F0">sizeof</FONT></B>(<B><FONT COLOR="#228B22">char</FONT></B>) * (filter_max +
                                          2) * (HTS_URLMAXSIZE * 2));
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (filters[0] == NULL) {
      freet(filters);
      filters = NULL;
    }
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (filters != NULL) {
    <B><FONT COLOR="#228B22">int</FONT></B> i;
    <B><FONT COLOR="#228B22">int</FONT></B> from;

    <B><FONT COLOR="#A020F0">if</FONT></B> (filterinc == 0)
      from = 0;
    <B><FONT COLOR="#A020F0">else</FONT></B>
      from = filter_max - filterinc;
    <B><FONT COLOR="#A020F0">for</FONT></B>(i = 0; i &lt;= filter_max; i++) {  <I><FONT COLOR="#B22222">// PLUS UN (sécurité)
</FONT></I>      filters[i] = filters[0] + i * (HTS_URLMAXSIZE * 2);
    }
    <B><FONT COLOR="#A020F0">for</FONT></B>(i = from; i &lt;= filter_max; i++) {       <I><FONT COLOR="#B22222">// PLUS UN (sécurité)
</FONT></I>      filters[i][0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;     <I><FONT COLOR="#B22222">// clear
</FONT></I>    }
  }
  *ptrfilters = filters;
  <B><FONT COLOR="#A020F0">return</FONT></B> (filters != NULL) ? filter_max : 0;
}

<B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">mkdir_compat</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *pathname) {
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">_WIN32</FONT>
  <B><FONT COLOR="#A020F0">return</FONT></B> mkdir(pathname);
#<B><FONT COLOR="#5F9EA0">else</FONT></B>
  <B><FONT COLOR="#A020F0">return</FONT></B> mkdir(pathname, HTS_ACCESS_FOLDER);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
}

<I><FONT COLOR="#B22222">/* path must end with &quot;/&quot; or with the finename (/tmp/bar/ or /tmp/bar/foo.zip) */</FONT></I>
<I><FONT COLOR="#B22222">/* Note: preserve errno */</FONT></I>
HTSEXT_API <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">dir_exists</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *path) {
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> err = errno;
  STRUCT_STAT st;
  <B><FONT COLOR="#228B22">char</FONT></B> BIGSTK file[HTS_URLMAXSIZE * 2];
  <B><FONT COLOR="#228B22">int</FONT></B> i = 0;

  <B><FONT COLOR="#A020F0">if</FONT></B> (strnotempty(path) == 0) {
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (strlen(path) &gt; HTS_URLMAXSIZE) {
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
  }

  <I><FONT COLOR="#B22222">/* Get a copy */</FONT></I>
  strcpybuff(file, path);
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">_WIN32</FONT>
  <I><FONT COLOR="#B22222">/* To system name */</FONT></I>
  <B><FONT COLOR="#A020F0">for</FONT></B>(i = 0; file[i] != 0; i++) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (file[i] == <B><FONT COLOR="#BC8F8F">'/'</FONT></B>) {
      file[i] = PATH_SEPARATOR;
    }
  }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
  <I><FONT COLOR="#B22222">/* Get prefix (note: file can not be empty here) */</FONT></I>
  <B><FONT COLOR="#A020F0">for</FONT></B>(i = (<B><FONT COLOR="#228B22">int</FONT></B>) strlen(file) - 1; i &gt; 0 &amp;&amp; file[i] != PATH_SEPARATOR; i--) ;
  <B><FONT COLOR="#A020F0">for</FONT></B>(; i &gt; 0 &amp;&amp; file[i] == PATH_SEPARATOR; i--) ;
  file[i + 1] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;

  <I><FONT COLOR="#B22222">/* Check the final dir */</FONT></I>
  <B><FONT COLOR="#A020F0">if</FONT></B> (STAT(file, &amp;st) == 0 &amp;&amp; S_ISDIR(st.st_mode)) {
    <B><FONT COLOR="#A020F0">return</FONT></B> 1;                   <I><FONT COLOR="#B22222">/* EXISTS */</FONT></I>
  }
  errno = err;
  <B><FONT COLOR="#A020F0">return</FONT></B> 0;                     <I><FONT COLOR="#B22222">/* DOES NOT EXIST */</FONT></I>
}

<I><FONT COLOR="#B22222">/* path must end with &quot;/&quot; or with the finename (/tmp/bar/ or /tmp/bar/foo.zip) */</FONT></I>
<I><FONT COLOR="#B22222">/* Note: *not* UTF-8 */</FONT></I>
HTSEXT_API <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">structcheck</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *path) {
  <B><FONT COLOR="#228B22">struct</FONT></B> stat st;
  <B><FONT COLOR="#228B22">char</FONT></B> BIGSTK tmpbuf[HTS_URLMAXSIZE * 2];
  <B><FONT COLOR="#228B22">char</FONT></B> BIGSTK file[HTS_URLMAXSIZE * 2];
  <B><FONT COLOR="#228B22">int</FONT></B> i = 0;
  <B><FONT COLOR="#228B22">int</FONT></B> npaths;

  <B><FONT COLOR="#A020F0">if</FONT></B> (strnotempty(path) == 0)
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
  <B><FONT COLOR="#A020F0">if</FONT></B> (strlen(path) &gt; HTS_URLMAXSIZE) {
    errno = EINVAL;
    <B><FONT COLOR="#A020F0">return</FONT></B> -1;
  }

  <I><FONT COLOR="#B22222">/* Get a copy */</FONT></I>
  strcpybuff(file, path);
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">_WIN32</FONT>
  <I><FONT COLOR="#B22222">/* To system name */</FONT></I>
  <B><FONT COLOR="#A020F0">for</FONT></B>(i = 0; file[i] != 0; i++) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (file[i] == <B><FONT COLOR="#BC8F8F">'/'</FONT></B>) {
      file[i] = PATH_SEPARATOR;
    }
  }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
  <I><FONT COLOR="#B22222">/* Get prefix (note: file can not be empty here) */</FONT></I>
  <B><FONT COLOR="#A020F0">for</FONT></B>(i = (<B><FONT COLOR="#228B22">int</FONT></B>) strlen(file) - 1; i &gt; 0 &amp;&amp; file[i] != PATH_SEPARATOR; i--) ;
  <B><FONT COLOR="#A020F0">for</FONT></B>(; i &gt; 0 &amp;&amp; file[i] == PATH_SEPARATOR; i--) ;
  file[i + 1] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;

  <I><FONT COLOR="#B22222">/* First check the final dir */</FONT></I>
  <B><FONT COLOR="#A020F0">if</FONT></B> (stat(file, &amp;st) == 0 &amp;&amp; S_ISDIR(st.st_mode)) {
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;                   <I><FONT COLOR="#B22222">/* OK */</FONT></I>
  }

  <I><FONT COLOR="#B22222">/* Start from the beginning */</FONT></I>
  i = 0;

  <I><FONT COLOR="#B22222">/* Skip irrelevant part (the root slash, or the drive path) */</FONT></I>
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">_WIN32</FONT>
  <B><FONT COLOR="#A020F0">if</FONT></B> (file[0] != 0 &amp;&amp; file[1] == <B><FONT COLOR="#BC8F8F">':'</FONT></B>) { <I><FONT COLOR="#B22222">/* f:\ */</FONT></I>
    i += 2;
    <B><FONT COLOR="#A020F0">if</FONT></B> (file[i] == PATH_SEPARATOR) {    <I><FONT COLOR="#B22222">/* f:\ */</FONT></I>
      i++;
    }
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (file[0] == PATH_SEPARATOR &amp;&amp; file[1] == PATH_SEPARATOR) {  <I><FONT COLOR="#B22222">/* \\mch */</FONT></I>
    <B><FONT COLOR="#228B22">int</FONT></B> j;

    i += 2;
    <I><FONT COLOR="#B22222">// skip machine and first dir (share) or we'll have troubles (TomZ)
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(j = 0; j &lt; 2; j++) {
      <I><FONT COLOR="#B22222">// skip segment
</FONT></I>      <B><FONT COLOR="#A020F0">for</FONT></B>(; file[i] != <B><FONT COLOR="#BC8F8F">'\0'</FONT></B> &amp;&amp; file[i] != PATH_SEPARATOR; i++) ;
      <I><FONT COLOR="#B22222">// skip final separator
</FONT></I>      <B><FONT COLOR="#A020F0">if</FONT></B> (file[i] == PATH_SEPARATOR) {  <I><FONT COLOR="#B22222">/* f:\ */</FONT></I>
        i++;
      }
    }
  }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

  <I><FONT COLOR="#B22222">/* Check paths */</FONT></I>
  <B><FONT COLOR="#A020F0">for</FONT></B>(npaths = 1;; npaths++) {
    <B><FONT COLOR="#228B22">char</FONT></B> end_char;

    <I><FONT COLOR="#B22222">/* Go to next path */</FONT></I>

    <I><FONT COLOR="#B22222">/* Skip separator(s) */</FONT></I>
    <B><FONT COLOR="#A020F0">for</FONT></B>(; file[i] == PATH_SEPARATOR; i++) ;
    <I><FONT COLOR="#B22222">/* Next separator */</FONT></I>
    <B><FONT COLOR="#A020F0">for</FONT></B>(; file[i] != 0 &amp;&amp; file[i] != PATH_SEPARATOR; i++) ;

    <I><FONT COLOR="#B22222">/* Check */</FONT></I>
    end_char = file[i];
    <B><FONT COLOR="#A020F0">if</FONT></B> (end_char != 0) {
      file[i] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (stat(file, &amp;st) == 0) { <I><FONT COLOR="#B22222">/* Something exists */</FONT></I>
      <B><FONT COLOR="#A020F0">if</FONT></B> (!S_ISDIR(st.st_mode)) {
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_REMOVE_ANNOYING_INDEX</FONT>
        <B><FONT COLOR="#A020F0">if</FONT></B> (S_ISREG(st.st_mode)) {      <I><FONT COLOR="#B22222">/* Regular file in place ; move it and create directory */</FONT></I>
          sprintf(tmpbuf, <B><FONT COLOR="#BC8F8F">&quot;%s.txt&quot;</FONT></B>, file);
          <B><FONT COLOR="#A020F0">if</FONT></B> (rename(file, tmpbuf) != 0) {      <I><FONT COLOR="#B22222">/* Can't rename regular file */</FONT></I>
            <B><FONT COLOR="#A020F0">return</FONT></B> -1;
          }
          <B><FONT COLOR="#A020F0">if</FONT></B> (mkdir_compat(file) != 0) {        <I><FONT COLOR="#B22222">/* Can't create directory */</FONT></I>
            <B><FONT COLOR="#A020F0">return</FONT></B> -1;
          }
        }
#<B><FONT COLOR="#5F9EA0">else</FONT></B>
#<B><FONT COLOR="#5F9EA0">error</FONT></B> <FONT COLOR="#B8860B">Not</FONT> <FONT COLOR="#B8860B">implemented</FONT>
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
      }
    } <B><FONT COLOR="#A020F0">else</FONT></B> {                    <I><FONT COLOR="#B22222">/* Nothing exists ; create directory */</FONT></I>
      <B><FONT COLOR="#A020F0">if</FONT></B> (mkdir_compat(file) != 0) {    <I><FONT COLOR="#B22222">/* Can't create directory */</FONT></I>
        <B><FONT COLOR="#A020F0">return</FONT></B> -1;
      }
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (end_char == 0) {        <I><FONT COLOR="#B22222">/* End */</FONT></I>
      <B><FONT COLOR="#A020F0">break</FONT></B>;
    } <B><FONT COLOR="#A020F0">else</FONT></B> {
      file[i] = end_char;       <I><FONT COLOR="#B22222">/* Restore / */</FONT></I>
    }
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}

<I><FONT COLOR="#B22222">/* path must end with &quot;/&quot; or with the finename (/tmp/bar/ or /tmp/bar/foo.zip) */</FONT></I>
<I><FONT COLOR="#B22222">/* Note: UTF-8 */</FONT></I>
HTSEXT_API <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">structcheck_utf8</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *path) {
  STRUCT_STAT st;
  <B><FONT COLOR="#228B22">char</FONT></B> BIGSTK tmpbuf[HTS_URLMAXSIZE * 2];
  <B><FONT COLOR="#228B22">char</FONT></B> BIGSTK file[HTS_URLMAXSIZE * 2];
  <B><FONT COLOR="#228B22">int</FONT></B> i = 0;
  <B><FONT COLOR="#228B22">int</FONT></B> npaths;

  <B><FONT COLOR="#A020F0">if</FONT></B> (strnotempty(path) == 0)
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
  <B><FONT COLOR="#A020F0">if</FONT></B> (strlen(path) &gt; HTS_URLMAXSIZE) {
    errno = EINVAL;
    <B><FONT COLOR="#A020F0">return</FONT></B> -1;
  }

  <I><FONT COLOR="#B22222">/* Get a copy */</FONT></I>
  strcpybuff(file, path);
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">_WIN32</FONT>
  <I><FONT COLOR="#B22222">/* To system name */</FONT></I>
  <B><FONT COLOR="#A020F0">for</FONT></B>(i = 0; file[i] != 0; i++) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (file[i] == <B><FONT COLOR="#BC8F8F">'/'</FONT></B>) {
      file[i] = PATH_SEPARATOR;
    }
  }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
  <I><FONT COLOR="#B22222">/* Get prefix (note: file can not be empty here) */</FONT></I>
  <B><FONT COLOR="#A020F0">for</FONT></B>(i = (<B><FONT COLOR="#228B22">int</FONT></B>) strlen(file) - 1; i &gt; 0 &amp;&amp; file[i] != PATH_SEPARATOR; i--) ;
  <B><FONT COLOR="#A020F0">for</FONT></B>(; i &gt; 0 &amp;&amp; file[i] == PATH_SEPARATOR; i--) ;
  file[i + 1] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;

  <I><FONT COLOR="#B22222">/* First check the final dir */</FONT></I>
  <B><FONT COLOR="#A020F0">if</FONT></B> (STAT(file, &amp;st) == 0 &amp;&amp; S_ISDIR(st.st_mode)) {
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;                   <I><FONT COLOR="#B22222">/* OK */</FONT></I>
  }

  <I><FONT COLOR="#B22222">/* Start from the beginning */</FONT></I>
  i = 0;

  <I><FONT COLOR="#B22222">/* Skip irrelevant part (the root slash, or the drive path) */</FONT></I>
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">_WIN32</FONT>
  <B><FONT COLOR="#A020F0">if</FONT></B> (file[0] != 0 &amp;&amp; file[1] == <B><FONT COLOR="#BC8F8F">':'</FONT></B>) { <I><FONT COLOR="#B22222">/* f:\ */</FONT></I>
    i += 2;
    <B><FONT COLOR="#A020F0">if</FONT></B> (file[i] == PATH_SEPARATOR) {    <I><FONT COLOR="#B22222">/* f:\ */</FONT></I>
      i++;
    }
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (file[0] == PATH_SEPARATOR &amp;&amp; file[1] == PATH_SEPARATOR) {  <I><FONT COLOR="#B22222">/* \\mch */</FONT></I>
    <B><FONT COLOR="#228B22">int</FONT></B> j;

    i += 2;
    <I><FONT COLOR="#B22222">// skip machine and first dir (share) or we'll have troubles (TomZ)
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(j = 0; j &lt; 2; j++) {
      <I><FONT COLOR="#B22222">// skip segment
</FONT></I>      <B><FONT COLOR="#A020F0">for</FONT></B>(; file[i] != <B><FONT COLOR="#BC8F8F">'\0'</FONT></B> &amp;&amp; file[i] != PATH_SEPARATOR; i++) ;
      <I><FONT COLOR="#B22222">// skip final separator
</FONT></I>      <B><FONT COLOR="#A020F0">if</FONT></B> (file[i] == PATH_SEPARATOR) {  <I><FONT COLOR="#B22222">/* f:\ */</FONT></I>
        i++;
      }
    }
  }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

  <I><FONT COLOR="#B22222">/* Check paths */</FONT></I>
  <B><FONT COLOR="#A020F0">for</FONT></B>(npaths = 1;; npaths++) {
    <B><FONT COLOR="#228B22">char</FONT></B> end_char;

    <I><FONT COLOR="#B22222">/* Go to next path */</FONT></I>

    <I><FONT COLOR="#B22222">/* Skip separator(s) */</FONT></I>
    <B><FONT COLOR="#A020F0">for</FONT></B>(; file[i] == PATH_SEPARATOR; i++) ;
    <I><FONT COLOR="#B22222">/* Next separator */</FONT></I>
    <B><FONT COLOR="#A020F0">for</FONT></B>(; file[i] != 0 &amp;&amp; file[i] != PATH_SEPARATOR; i++) ;

    <I><FONT COLOR="#B22222">/* Check */</FONT></I>
    end_char = file[i];
    <B><FONT COLOR="#A020F0">if</FONT></B> (end_char != 0) {
      file[i] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (STAT(file, &amp;st) == 0) { <I><FONT COLOR="#B22222">/* Something exists */</FONT></I>
      <B><FONT COLOR="#A020F0">if</FONT></B> (!S_ISDIR(st.st_mode)) {
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_REMOVE_ANNOYING_INDEX</FONT>
        <B><FONT COLOR="#A020F0">if</FONT></B> (S_ISREG(st.st_mode)) {      <I><FONT COLOR="#B22222">/* Regular file in place ; move it and create directory */</FONT></I>
          sprintf(tmpbuf, <B><FONT COLOR="#BC8F8F">&quot;%s.txt&quot;</FONT></B>, file);
          <B><FONT COLOR="#A020F0">if</FONT></B> (RENAME(file, tmpbuf) != 0) {      <I><FONT COLOR="#B22222">/* Can't rename regular file */</FONT></I>
            <B><FONT COLOR="#A020F0">return</FONT></B> -1;
          }
          <B><FONT COLOR="#A020F0">if</FONT></B> (MKDIR(file) != 0) {       <I><FONT COLOR="#B22222">/* Can't create directory */</FONT></I>
            <B><FONT COLOR="#A020F0">return</FONT></B> -1;
          }
        }
#<B><FONT COLOR="#5F9EA0">else</FONT></B>
#<B><FONT COLOR="#5F9EA0">error</FONT></B> <FONT COLOR="#B8860B">Not</FONT> <FONT COLOR="#B8860B">implemented</FONT>
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
      }
    } <B><FONT COLOR="#A020F0">else</FONT></B> {                    <I><FONT COLOR="#B22222">/* Nothing exists ; create directory */</FONT></I>
      <B><FONT COLOR="#A020F0">if</FONT></B> (MKDIR(file) != 0) {   <I><FONT COLOR="#B22222">/* Can't create directory */</FONT></I>
        <B><FONT COLOR="#A020F0">return</FONT></B> -1;
      }
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (end_char == 0) {        <I><FONT COLOR="#B22222">/* End */</FONT></I>
      <B><FONT COLOR="#A020F0">break</FONT></B>;
    } <B><FONT COLOR="#A020F0">else</FONT></B> {
      file[i] = end_char;       <I><FONT COLOR="#B22222">/* Restore / */</FONT></I>
    }
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}

<I><FONT COLOR="#B22222">// sauver un fichier
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">filesave</FONT></B>(httrackp * opt, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *adr, <B><FONT COLOR="#228B22">int</FONT></B> len, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *s,
             <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *url_adr, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *url_fil) {
  FILE *fp;

  <I><FONT COLOR="#B22222">// écrire le fichier
</FONT></I>  <B><FONT COLOR="#A020F0">if</FONT></B> ((fp = filecreate(&amp;opt-&gt;state.strc, s)) != NULL) {
    <B><FONT COLOR="#228B22">int</FONT></B> nl = 0;

    <B><FONT COLOR="#A020F0">if</FONT></B> (len &gt; 0) {
      nl = (<B><FONT COLOR="#228B22">int</FONT></B>) fwrite(adr, 1, len, fp);
    }
    fclose(fp);
    <B><FONT COLOR="#A020F0">if</FONT></B> (nl != len)              <I><FONT COLOR="#B22222">// erreur
</FONT></I>      <B><FONT COLOR="#A020F0">return</FONT></B> -1;
  } <B><FONT COLOR="#A020F0">else</FONT></B>
    <B><FONT COLOR="#A020F0">return</FONT></B> -1;

  <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}

<I><FONT COLOR="#B22222">/* We should stop */</FONT></I>
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">check_fatal_io_errno</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>) {
  <B><FONT COLOR="#A020F0">switch</FONT></B> (errno) {
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">EMFILE</FONT>
  <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">EMFILE</FONT></B>:                 <I><FONT COLOR="#B22222">/* Too many open files */</FONT></I>
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">ENOSPC</FONT>
  <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">ENOSPC</FONT></B>:                 <I><FONT COLOR="#B22222">/* No space left on device */</FONT></I>
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">EROFS</FONT>
  <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">EROFS</FONT></B>:                  <I><FONT COLOR="#B22222">/* Read-only file system */</FONT></I>
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    <B><FONT COLOR="#A020F0">return</FONT></B> 1;
    <B><FONT COLOR="#A020F0">break</FONT></B>;
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}

<I><FONT COLOR="#B22222">// ouvrir un fichier (avec chemin Un*x)
</FONT></I><I><FONT COLOR="#B22222">/* Note: utf-8 */</FONT></I>
FILE *<B><FONT COLOR="#0000FF">filecreate</FONT></B>(filenote_strc * strc, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *s) {
  <B><FONT COLOR="#228B22">char</FONT></B> BIGSTK fname[HTS_URLMAXSIZE * 2];
  FILE *fp;
  <B><FONT COLOR="#228B22">int</FONT></B> last_errno = 0;

  fname[0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;

  <I><FONT COLOR="#B22222">// noter lst
</FONT></I>  <B><FONT COLOR="#A020F0">if</FONT></B> (strc != NULL) {
    filenote(strc, s, NULL);
  }

  strcpybuff(fname, s);
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_DOSNAME</FONT>
  <I><FONT COLOR="#B22222">// remplacer / par des slash arrière
</FONT></I>  {
    <B><FONT COLOR="#228B22">int</FONT></B> i = 0;

    <B><FONT COLOR="#A020F0">while</FONT></B>(fname[i]) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (fname[i] == <B><FONT COLOR="#BC8F8F">'/'</FONT></B>)
        fname[i] = <B><FONT COLOR="#BC8F8F">'\\'</FONT></B>;
      i++;
    }
  }
  <I><FONT COLOR="#B22222">// a partir d'ici le slash devient antislash
</FONT></I>#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

  <I><FONT COLOR="#B22222">/* Try to open the file */</FONT></I>
  fp = FOPEN(fname, <B><FONT COLOR="#BC8F8F">&quot;wb&quot;</FONT></B>);

  <I><FONT COLOR="#B22222">/* Error ? Check the directory structure and retry. */</FONT></I>
  <B><FONT COLOR="#A020F0">if</FONT></B> (fp == NULL) {
    last_errno = errno;
    <B><FONT COLOR="#A020F0">if</FONT></B> (structcheck_utf8(s) != 0) {
      last_errno = errno;
    } <B><FONT COLOR="#A020F0">else</FONT></B> {
      last_errno = 0;
    }
    fp = FOPEN(fname, <B><FONT COLOR="#BC8F8F">&quot;wb&quot;</FONT></B>);
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (fp == NULL &amp;&amp; last_errno != 0) {
    errno = last_errno;
  }
#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">_WIN32</FONT>
  <B><FONT COLOR="#A020F0">if</FONT></B> (fp != NULL)
    chmod(fname, HTS_ACCESS_FILE);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
  <B><FONT COLOR="#A020F0">return</FONT></B> fp;
}

<I><FONT COLOR="#B22222">// ouvrir un fichier (avec chemin Un*x)
</FONT></I>FILE *<B><FONT COLOR="#0000FF">fileappend</FONT></B>(filenote_strc * strc, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *s) {
  <B><FONT COLOR="#228B22">char</FONT></B> BIGSTK fname[HTS_URLMAXSIZE * 2];
  FILE *fp;

  fname[0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;

  <I><FONT COLOR="#B22222">// noter lst
</FONT></I>  filenote(strc, s, NULL);

  <I><FONT COLOR="#B22222">// if (*s=='/') strcpybuff(fname,s+1); else strcpybuff(fname,s);    // pas de / (root!!) // ** SIIIIIII!!! à cause de -O &lt;path&gt;
</FONT></I>  strcpybuff(fname, s);

#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_DOSNAME</FONT>
  <I><FONT COLOR="#B22222">// remplacer / par des slash arrière
</FONT></I>  {
    <B><FONT COLOR="#228B22">int</FONT></B> i = 0;

    <B><FONT COLOR="#A020F0">while</FONT></B>(fname[i]) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (fname[i] == <B><FONT COLOR="#BC8F8F">'/'</FONT></B>)
        fname[i] = <B><FONT COLOR="#BC8F8F">'\\'</FONT></B>;
      i++;
    }
  }
  <I><FONT COLOR="#B22222">// a partir d'ici le slash devient antislash
</FONT></I>#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

  <I><FONT COLOR="#B22222">// ouvrir
</FONT></I>  fp = FOPEN(fname, <B><FONT COLOR="#BC8F8F">&quot;ab&quot;</FONT></B>);

#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">_WIN32</FONT>
  <B><FONT COLOR="#A020F0">if</FONT></B> (fp != NULL)
    chmod(fname, HTS_ACCESS_FILE);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

  <B><FONT COLOR="#A020F0">return</FONT></B> fp;
}

<I><FONT COLOR="#B22222">// create an empty file
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">filecreateempty</FONT></B>(filenote_strc * strc, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *filename) {
  FILE *fp;

  fp = filecreate(strc, filename);      <I><FONT COLOR="#B22222">// filenote &amp; co
</FONT></I>  <B><FONT COLOR="#A020F0">if</FONT></B> (fp) {
    fclose(fp);
    <B><FONT COLOR="#A020F0">return</FONT></B> 1;
  } <B><FONT COLOR="#A020F0">else</FONT></B>
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}

<I><FONT COLOR="#B22222">// noter fichier
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">filenote</FONT></B>(filenote_strc * strc, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *s, filecreate_params * params) {
  <I><FONT COLOR="#B22222">// gestion du fichier liste liste
</FONT></I>  <B><FONT COLOR="#A020F0">if</FONT></B> (params) {
    <I><FONT COLOR="#B22222">//filecreate_params* p = (filecreate_params*) params;
</FONT></I>    strcpybuff(strc-&gt;path, params-&gt;path);
    strc-&gt;lst = params-&gt;lst;
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (strc-&gt;lst) {
    <B><FONT COLOR="#228B22">char</FONT></B> BIGSTK savelst[HTS_URLMAXSIZE * 2];
    <B><FONT COLOR="#228B22">char</FONT></B> catbuff[CATBUFF_SIZE];

    strcpybuff(savelst, fslash(catbuff, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(catbuff), s));
    <I><FONT COLOR="#B22222">// couper chemin?
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B> (strnotempty(strc-&gt;path)) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (strncmp(fslash(catbuff, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(catbuff), strc-&gt;path), savelst, strlen(strc-&gt;path)) == 0) {     <I><FONT COLOR="#B22222">// couper
</FONT></I>        strcpybuff(savelst, s + strlen(strc-&gt;path));
      }
    }
    fprintf(strc-&gt;lst, <B><FONT COLOR="#BC8F8F">&quot;[%s]&quot;</FONT></B> LF, savelst);
    fflush(strc-&gt;lst);
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> 1;
}

<I><FONT COLOR="#B22222">/* Note: utf-8 */</FONT></I>
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">file_notify</FONT></B>(httrackp * opt, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *adr, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *fil,
                 <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *save, <B><FONT COLOR="#228B22">int</FONT></B> create, <B><FONT COLOR="#228B22">int</FONT></B> modify, <B><FONT COLOR="#228B22">int</FONT></B> not_updated) {
  RUN_CALLBACK6(opt, filesave2, adr, fil, save, create, modify, not_updated);
}

<I><FONT COLOR="#B22222">// executer commande utilisateur
</FONT></I><B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">postprocess_file</FONT></B>(httrackp * opt, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *save, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *adr,
                             <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *fil);
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">usercommand</FONT></B>(httrackp * opt, <B><FONT COLOR="#228B22">int</FONT></B> _exe, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *_cmd, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *file,
                 <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *adr, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *fil) {
  usercommand_strc *strc = &amp;opt-&gt;state.usercmd;

  <I><FONT COLOR="#B22222">/* Callback */</FONT></I>
  <B><FONT COLOR="#A020F0">if</FONT></B> (_exe) {
    strcpybuff(strc-&gt;cmd, _cmd);
    <B><FONT COLOR="#A020F0">if</FONT></B> (strnotempty(strc-&gt;cmd))
      strc-&gt;exe = _exe;
    <B><FONT COLOR="#A020F0">else</FONT></B>
      strc-&gt;exe = 0;
  }

  <I><FONT COLOR="#B22222">/* post-processing */</FONT></I>
  postprocess_file(opt, file, adr, fil);

  <B><FONT COLOR="#A020F0">if</FONT></B> (file != NULL &amp;&amp; strnotempty(file)) {
    RUN_CALLBACK1(opt, filesave, file);
  }

  <B><FONT COLOR="#A020F0">if</FONT></B> (strc-&gt;exe) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (file != NULL &amp;&amp; strnotempty(file)) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (strnotempty(strc-&gt;cmd)) {
        usercommand_exe(strc-&gt;cmd, file);
      }
    }
  }
}
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">usercommand_exe</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *cmd, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *file) {
  <B><FONT COLOR="#228B22">char</FONT></B> BIGSTK temp[8192];
  size_t i;

  temp[0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
  <I><FONT COLOR="#B22222">//
</FONT></I>  <B><FONT COLOR="#A020F0">for</FONT></B>(i = 0; cmd[i] != <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>; i++) {
    <B><FONT COLOR="#A020F0">if</FONT></B> ((cmd[i] == <B><FONT COLOR="#BC8F8F">'$'</FONT></B>) &amp;&amp; (cmd[i + 1] == <B><FONT COLOR="#BC8F8F">'0'</FONT></B>)) {
      strcatbuff(temp, file);
      i++;
    } <B><FONT COLOR="#A020F0">else</FONT></B> {
      <B><FONT COLOR="#228B22">char</FONT></B> c[2];
      c[0] = cmd[i];
      c[1] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
      strcatbuff(temp, c);
    }
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (system(temp) == -1) {
    assertf(!<B><FONT COLOR="#BC8F8F">&quot;can not spawn process&quot;</FONT></B>);
  }
}

<B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">postprocess_file</FONT></B>(httrackp * opt, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *save, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *adr,
                             <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *fil) {
  <I><FONT COLOR="#B22222">//int first = 0;
</FONT></I>  <I><FONT COLOR="#B22222">/* MIME-html archive to build */</FONT></I>
  <B><FONT COLOR="#A020F0">if</FONT></B> (opt != NULL &amp;&amp; opt-&gt;mimehtml) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (adr != NULL &amp;&amp; strcmp(adr, <B><FONT COLOR="#BC8F8F">&quot;primary&quot;</FONT></B>) == 0) {
      adr = NULL;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (save != NULL &amp;&amp; opt != NULL &amp;&amp; adr != NULL &amp;&amp; adr[0]
        &amp;&amp; strnotempty(save) &amp;&amp; fexist(save)) {
      <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *rsc_save = save;
      <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *rsc_fil = strrchr(fil, <B><FONT COLOR="#BC8F8F">'/'</FONT></B>);
      <B><FONT COLOR="#228B22">int</FONT></B> n;

      <B><FONT COLOR="#A020F0">if</FONT></B> (rsc_fil == NULL)
        rsc_fil = fil;
      <B><FONT COLOR="#A020F0">if</FONT></B> (strncmp
          (fslash(OPT_GET_BUFF(opt), OPT_GET_BUFF_SIZE(opt), save),
           fslash(OPT_GET_BUFF(opt), OPT_GET_BUFF_SIZE(opt), 
           StringBuff(opt-&gt;path_html_utf8)), (n =
                                                                        (<B><FONT COLOR="#228B22">int</FONT></B>)
                                                                        strlen
                                                                        (StringBuff
                                                                         (opt-&gt;
                                                                          path_html_utf8))))
          == 0) {
        rsc_save += n;
      }

      <B><FONT COLOR="#A020F0">if</FONT></B> (!opt-&gt;state.mimehtml_created) {
        <I><FONT COLOR="#B22222">//first = 1;
</FONT></I>        opt-&gt;state.mimefp =
          fopen(fconcat
                (OPT_GET_BUFF(opt), OPT_GET_BUFF_SIZE(opt),
                StringBuff(opt-&gt;path_html), <B><FONT COLOR="#BC8F8F">&quot;index.mht&quot;</FONT></B>),
                <B><FONT COLOR="#BC8F8F">&quot;wb&quot;</FONT></B>);
        (<B><FONT COLOR="#228B22">void</FONT></B>) unlink(fconcat(OPT_GET_BUFF(opt), OPT_GET_BUFF_SIZE(opt),
          StringBuff(opt-&gt;path_html),
                              <B><FONT COLOR="#BC8F8F">&quot;index.eml&quot;</FONT></B>));
#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">_WIN32</FONT>
        <B><FONT COLOR="#A020F0">if</FONT></B> (symlink(<B><FONT COLOR="#BC8F8F">&quot;index.mht&quot;</FONT></B>,
                    fconcat(OPT_GET_BUFF(opt), OPT_GET_BUFF_SIZE(opt), StringBuff(opt-&gt;path_html),
                            <B><FONT COLOR="#BC8F8F">&quot;index.eml&quot;</FONT></B>)) != 0) {
          <B><FONT COLOR="#A020F0">if</FONT></B> (errno != EPERM) {
            hts_log_print(opt, LOG_WARNING | LOG_ERRNO,
              <B><FONT COLOR="#BC8F8F">&quot;could not create symbolic link from index.mht to index.eml&quot;</FONT></B>);
          }
        }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
        <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;state.mimefp != NULL) {
          <B><FONT COLOR="#228B22">char</FONT></B> BIGSTK rndtmp[1024], currtime[256];

          srand((<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>) time(NULL));
          time_gmt_rfc822(currtime);
          sprintf(rndtmp, <B><FONT COLOR="#BC8F8F">&quot;%d_%d&quot;</FONT></B>, (<B><FONT COLOR="#228B22">int</FONT></B>) time(NULL), (<B><FONT COLOR="#228B22">int</FONT></B>) rand());
          StringRoom(opt-&gt;state.mimemid, 256);
          sprintf(StringBuffRW(opt-&gt;state.mimemid), <B><FONT COLOR="#BC8F8F">&quot;----=_MIMEPart_%s_=----&quot;</FONT></B>,
                  rndtmp);
          StringSetLength(opt-&gt;state.mimemid, -1);
          fprintf(opt-&gt;state.mimefp,
                  <B><FONT COLOR="#BC8F8F">&quot;From: HTTrack Website Copier &lt;nobody@localhost&gt;\r\n&quot;</FONT></B>
                  <B><FONT COLOR="#BC8F8F">&quot;Subject: Local mirror\r\n&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;Date: %s\r\n&quot;</FONT></B>
                  <B><FONT COLOR="#BC8F8F">&quot;Message-ID: &lt;httrack_%s@localhost&gt;\r\n&quot;</FONT></B>
                  <B><FONT COLOR="#BC8F8F">&quot;Content-Type: multipart/related;\r\n&quot;</FONT></B>
                  <B><FONT COLOR="#BC8F8F">&quot;\tboundary=\&quot;%s\&quot;;\r\n&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;\ttype=\&quot;text/html\&quot;\r\n&quot;</FONT></B>
                  <B><FONT COLOR="#BC8F8F">&quot;MIME-Version: 1.0\r\n&quot;</FONT></B>
                  <B><FONT COLOR="#BC8F8F">&quot;\r\nThis message is a RFC MIME-compliant multipart message.\r\n&quot;</FONT></B>
                  <B><FONT COLOR="#BC8F8F">&quot;\r\n&quot;</FONT></B>, currtime, rndtmp, StringBuff(opt-&gt;state.mimemid));
          opt-&gt;state.mimehtml_created = 1;
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
          opt-&gt;state.mimehtml_created = -1;
          hts_log_print(opt, LOG_ERROR, <B><FONT COLOR="#BC8F8F">&quot;unable to create index.mht&quot;</FONT></B>);
        }
      }
      <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;state.mimehtml_created == 1 &amp;&amp; opt-&gt;state.mimefp != NULL) {
        FILE *fp = FOPEN(save, <B><FONT COLOR="#BC8F8F">&quot;rb&quot;</FONT></B>);

        <B><FONT COLOR="#A020F0">if</FONT></B> (fp != NULL) {
          <B><FONT COLOR="#228B22">char</FONT></B> buff[60 * 100 + 2];
          <B><FONT COLOR="#228B22">char</FONT></B> mimebuff[256];
          <B><FONT COLOR="#228B22">char</FONT></B> BIGSTK cid[HTS_URLMAXSIZE * 3];
          size_t len;
          <B><FONT COLOR="#228B22">int</FONT></B> isHtml = (ishtml(opt, save) == 1);

          mimebuff[0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;

          <I><FONT COLOR="#B22222">/* CID */</FONT></I>
          make_content_id(adr, fil, cid, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(cid));

          guess_httptype(opt, mimebuff, save);
          fprintf(opt-&gt;state.mimefp, <B><FONT COLOR="#BC8F8F">&quot;--%s\r\n&quot;</FONT></B>,
                  StringBuff(opt-&gt;state.mimemid));
          <I><FONT COLOR="#B22222">/*if (first)
             fprintf(opt-&gt;state.mimefp, &quot;Content-disposition: inline\r\n&quot;);
             else */</FONT></I>
          fprintf(opt-&gt;state.mimefp,
                  <B><FONT COLOR="#BC8F8F">&quot;Content-disposition: attachment; filename=\&quot;%s\&quot;\r\n&quot;</FONT></B>,
                  rsc_save);
          fprintf(opt-&gt;state.mimefp,
                  <B><FONT COLOR="#BC8F8F">&quot;Content-Type: %s\r\n&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;Content-Transfer-Encoding: %s\r\n&quot;</FONT></B>
                  <I><FONT COLOR="#B22222">/*&quot;Content-Location: http://localhost/%s\r\n&quot; */</FONT></I>
                  <B><FONT COLOR="#BC8F8F">&quot;Content-ID: &lt;%s&gt;\r\n&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;\r\n&quot;</FONT></B>, mimebuff,
                  isHtml ? <B><FONT COLOR="#BC8F8F">&quot;8bit&quot;</FONT></B> : <B><FONT COLOR="#BC8F8F">&quot;base64&quot;</FONT></B>
                  <I><FONT COLOR="#B22222">/*, rsc_save */</FONT></I>
                  , cid);
          <B><FONT COLOR="#A020F0">while</FONT></B>((len = fread(buff, 1, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(buff) - 2, fp)) &gt; 0) {
            buff[len] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
            <B><FONT COLOR="#A020F0">if</FONT></B> (!isHtml) {
              <B><FONT COLOR="#228B22">char</FONT></B> base64buff[60 * 100 * 2];

              code64((<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *) buff, (<B><FONT COLOR="#228B22">int</FONT></B>) len,
                     (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *) base64buff, 1);
              fprintf(opt-&gt;state.mimefp, <B><FONT COLOR="#BC8F8F">&quot;%s&quot;</FONT></B>, base64buff);
            } <B><FONT COLOR="#A020F0">else</FONT></B> {
              fprintf(opt-&gt;state.mimefp, <B><FONT COLOR="#BC8F8F">&quot;%s&quot;</FONT></B>, buff);
            }
          }
          fclose(fp);
          fprintf(opt-&gt;state.mimefp, <B><FONT COLOR="#BC8F8F">&quot;\r\n\r\n&quot;</FONT></B>);
        }
      }
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (save == NULL) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;state.mimehtml_created == 1 &amp;&amp; opt-&gt;state.mimefp != NULL) {
        fprintf(opt-&gt;state.mimefp, <B><FONT COLOR="#BC8F8F">&quot;--%s--\r\n&quot;</FONT></B>,
                StringBuff(opt-&gt;state.mimemid));
        fclose(opt-&gt;state.mimefp);
        opt-&gt;state.mimefp = NULL;
      }
    }
  }
}

<I><FONT COLOR="#B22222">// écrire n espaces dans fp
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">fspc</FONT></B>(httrackp * opt, FILE * fp, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *type) {
  fspc_strc *<B><FONT COLOR="#228B22">const</FONT></B> strc = (opt != NULL) ? &amp;opt-&gt;state.fspc : NULL;

  <B><FONT COLOR="#A020F0">if</FONT></B> (fp != NULL) {
    <B><FONT COLOR="#228B22">char</FONT></B> s[256];
    time_t tt;
    <B><FONT COLOR="#228B22">struct</FONT></B> tm *A;

    tt = time(NULL);
    A = localtime(&amp;tt);
    <B><FONT COLOR="#A020F0">if</FONT></B> (A == NULL) {
      <B><FONT COLOR="#228B22">int</FONT></B> localtime_returned_null = 0;

      assertf(localtime_returned_null);
    }
    strftime(s, 250, <B><FONT COLOR="#BC8F8F">&quot;%H:%M:%S&quot;</FONT></B>, A);
    <B><FONT COLOR="#A020F0">if</FONT></B> (strnotempty(type))
      fprintf(fp, <B><FONT COLOR="#BC8F8F">&quot;%s\t%c%s: \t&quot;</FONT></B>, s, hichar(*type), type + 1);
    <B><FONT COLOR="#A020F0">else</FONT></B>
      fprintf(fp, <B><FONT COLOR="#BC8F8F">&quot;%s\t \t&quot;</FONT></B>, s);
    <B><FONT COLOR="#A020F0">if</FONT></B> (strc != NULL) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (strcmp(type, <B><FONT COLOR="#BC8F8F">&quot;warning&quot;</FONT></B>) == 0)
        strc-&gt;warning++;
      <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (strcmp(type, <B><FONT COLOR="#BC8F8F">&quot;error&quot;</FONT></B>) == 0)
        strc-&gt;error++;
      <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (strcmp(type, <B><FONT COLOR="#BC8F8F">&quot;info&quot;</FONT></B>) == 0)
        strc-&gt;info++;
    }
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (strc == NULL) {
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!type) {
    strc-&gt;error = strc-&gt;warning = strc-&gt;info = 0;       <I><FONT COLOR="#B22222">// reset
</FONT></I>  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (strcmp(type, <B><FONT COLOR="#BC8F8F">&quot;warning&quot;</FONT></B>) == 0)
    <B><FONT COLOR="#A020F0">return</FONT></B> strc-&gt;warning;
  <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (strcmp(type, <B><FONT COLOR="#BC8F8F">&quot;error&quot;</FONT></B>) == 0)
    <B><FONT COLOR="#A020F0">return</FONT></B> strc-&gt;error;
  <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (strcmp(type, <B><FONT COLOR="#BC8F8F">&quot;info&quot;</FONT></B>) == 0)
    <B><FONT COLOR="#A020F0">return</FONT></B> strc-&gt;info;
  <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}

<I><FONT COLOR="#B22222">// vérifier taux de transfert
</FONT></I>#<B><FONT COLOR="#5F9EA0">if</FONT></B> 0
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">check_rate</FONT></B>(TStamp stat_timestart, <B><FONT COLOR="#228B22">int</FONT></B> maxrate) {
  <I><FONT COLOR="#B22222">// vérifier taux de transfert (pas trop grand?)
</FONT></I>  <I><FONT COLOR="#B22222">/*
     if (maxrate&gt;0) {
     int r = (int) (HTS_STAT.HTS_TOTAL_RECV/(time_local()-stat_timestart));    // taux actuel de transfert
     HTS_STAT.HTS_TOTAL_RECV_STATE=0;
     if (r&gt;maxrate) {    // taux&gt;taux autorisé
     int taux = (int) (((TStamp) (r - maxrate) * 100) / (TStamp) maxrate);
     if (taux&lt;15)
     HTS_STAT.HTS_TOTAL_RECV_STATE=1;   // ralentir un peu (&lt;15% dépassement)
     else if (taux&lt;50)
     HTS_STAT.HTS_TOTAL_RECV_STATE=2;   // beaucoup (&lt;50% dépassement)
     else
     HTS_STAT.HTS_TOTAL_RECV_STATE=3;   // énormément (&gt;50% dépassement)
     }
     }
   */</FONT></I>
}
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">// ---
</FONT></I><I><FONT COLOR="#B22222">// sous routines liées au moteur et au backing
</FONT></I>
<I><FONT COLOR="#B22222">// supplemental links ready (done) after ptr or ready in background
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">backlinks_done</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> struct_back * sback,
                   lien_url ** liens, <B><FONT COLOR="#228B22">int</FONT></B> lien_tot,
                   <B><FONT COLOR="#228B22">int</FONT></B> ptr) {
  <B><FONT COLOR="#228B22">int</FONT></B> n = 0;

#<B><FONT COLOR="#5F9EA0">if</FONT></B> 0
  <B><FONT COLOR="#228B22">int</FONT></B> i;

  <I><FONT COLOR="#B22222">//Links done and stored in cache
</FONT></I>  <B><FONT COLOR="#A020F0">for</FONT></B>(i = ptr + 1; i &lt; lien_tot; i++) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (heap(i)) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (heap(i)-&gt;pass2 == -1) {
        n++;
      }
    }
  }
#<B><FONT COLOR="#5F9EA0">else</FONT></B>
  <I><FONT COLOR="#B22222">// finalized in background
</FONT></I>  n += HTS_STAT.stat_background;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
  n += back_done_incache(sback);
  <B><FONT COLOR="#A020F0">return</FONT></B> n;
}

<I><FONT COLOR="#B22222">// remplir backing si moins de max_bytes en mémoire
</FONT></I>HTS_INLINE <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">back_fillmax</FONT></B>(struct_back * sback, httrackp * opt,
                            cache_back * cache, <B><FONT COLOR="#228B22">int</FONT></B> ptr,
                            <B><FONT COLOR="#228B22">int</FONT></B> numero_passe) {
  <B><FONT COLOR="#A020F0">if</FONT></B> (!opt-&gt;state.stop) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (back_incache(sback) &lt; opt-&gt;maxcache) {  <I><FONT COLOR="#B22222">// pas trop en mémoire?
</FONT></I>      <B><FONT COLOR="#A020F0">return</FONT></B> back_fill(sback, opt, cache, ptr, numero_passe);
    }
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> -1;                    <I><FONT COLOR="#B22222">/* plus de place */</FONT></I>
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">back_pluggable_sockets_strict</FONT></B>(struct_back * sback, httrackp * opt) {
  <B><FONT COLOR="#228B22">int</FONT></B> n = opt-&gt;maxsoc - back_nsoc(sback);

  <I><FONT COLOR="#B22222">// connect limiter
</FONT></I>  <B><FONT COLOR="#A020F0">if</FONT></B> (n &gt; 0 &amp;&amp; opt-&gt;maxconn &gt; 0 &amp;&amp; HTS_STAT.last_connect &gt; 0) {
    TStamp opTime =
      HTS_STAT.last_request ? HTS_STAT.last_request : HTS_STAT.last_connect;
    TStamp cTime = mtime_local();
    TStamp lap = (cTime - opTime);
    TStamp minLap = (TStamp) (1000.0 / opt-&gt;maxconn);

    <B><FONT COLOR="#A020F0">if</FONT></B> (lap &lt; minLap) {
      n = 0;
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (minLap != 0) {
      <B><FONT COLOR="#228B22">int</FONT></B> nMax = (<B><FONT COLOR="#228B22">int</FONT></B>) (lap / minLap);

      n = min(n, nMax);
    }
  }

  <B><FONT COLOR="#A020F0">return</FONT></B> n;
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">back_pluggable_sockets</FONT></B>(struct_back * sback, httrackp * opt) {
  <B><FONT COLOR="#228B22">int</FONT></B> n;

  <I><FONT COLOR="#B22222">// ajouter autant de socket qu'on peut ajouter
</FONT></I>  n = back_pluggable_sockets_strict(sback, opt);

  <I><FONT COLOR="#B22222">// vérifier qu'il restera assez de place pour les tests ensuite (en théorie, 1 entrée libre restante suffirait)
</FONT></I>  n = min(n, back_available(sback) - 8);

  <I><FONT COLOR="#B22222">// no space left on backing stack - do not back anymore
</FONT></I>  <B><FONT COLOR="#A020F0">if</FONT></B> (back_stack_available(sback) &lt;= 2)
    n = 0;

  <B><FONT COLOR="#A020F0">return</FONT></B> n;
}

<I><FONT COLOR="#B22222">// remplir backing
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">back_fill</FONT></B>(struct_back * sback, httrackp * opt, cache_back * cache,
              <B><FONT COLOR="#228B22">int</FONT></B> ptr, <B><FONT COLOR="#228B22">int</FONT></B> numero_passe) {
  <B><FONT COLOR="#228B22">int</FONT></B> n = back_pluggable_sockets(sback, opt);

  <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;savename_delayed == 2 &amp;&amp; !opt-&gt;delayed_cached)       <I><FONT COLOR="#B22222">/* cancel (always delayed) */</FONT></I>
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
  <B><FONT COLOR="#A020F0">if</FONT></B> (n &gt; 0) {
    <B><FONT COLOR="#228B22">int</FONT></B> p;

    <B><FONT COLOR="#A020F0">if</FONT></B> (ptr &lt; cache-&gt;ptr_last) {        <I><FONT COLOR="#B22222">/* restart (2 scans: first html, then non html) */</FONT></I>
      cache-&gt;ptr_ant = 0;
    }

    p = ptr + 1;
    <I><FONT COLOR="#B22222">/* on a déja parcouru */</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B> (p &lt; cache-&gt;ptr_ant)
      p = cache-&gt;ptr_ant;
    <B><FONT COLOR="#A020F0">while</FONT></B>(p &lt; opt-&gt;lien_tot &amp;&amp; n &gt; 0 &amp;&amp; back_checkmirror(opt)) {
      <I><FONT COLOR="#B22222">//while((p&lt;lien_tot) &amp;&amp; (n&gt;0) &amp;&amp; (p &lt; ptr+opt-&gt;maxcache_anticipate)) {
</FONT></I>      <B><FONT COLOR="#228B22">int</FONT></B> ok = 1;

      <I><FONT COLOR="#B22222">// on ne met pas le fichier en backing si il doit être traité après ou s'il a déja été traité
</FONT></I>      <B><FONT COLOR="#A020F0">if</FONT></B> (heap(p)-&gt;pass2) {    <I><FONT COLOR="#B22222">// 2è passe
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (numero_passe != 1)
          ok = 0;
      } <B><FONT COLOR="#A020F0">else</FONT></B> {
        <B><FONT COLOR="#A020F0">if</FONT></B> (numero_passe != 0)
          ok = 0;
      }

      <I><FONT COLOR="#B22222">// Why in hell did I do that ?
</FONT></I>      <I><FONT COLOR="#B22222">//if (ok &amp;&amp; heap(p)-&gt;sav != NULL &amp;&amp; heap(p)-&gt;sav[0] != '\0' 
</FONT></I>      <I><FONT COLOR="#B22222">//  &amp;&amp; hash_read(opt-&gt;hash,heap(p)-&gt;sav,NULL,HASH_STRUCT_FILENAME ) &gt;= 0)     // lookup in liens_record
</FONT></I>      <I><FONT COLOR="#B22222">//{
</FONT></I>      <I><FONT COLOR="#B22222">//  ok = 0;
</FONT></I>      <I><FONT COLOR="#B22222">//}
</FONT></I>      <B><FONT COLOR="#A020F0">if</FONT></B> (heap(p)-&gt;sav == NULL || heap(p)-&gt;sav[0] == <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>
          || hash_read(opt-&gt;hash, heap(p)-&gt;sav, NULL, HASH_STRUCT_FILENAME ) &lt; 0) {
        ok = 0;
      }
      <I><FONT COLOR="#B22222">// note: si un backing est fini, il reste en mémoire jusqu'à ce que
</FONT></I>      <I><FONT COLOR="#B22222">// le ptr l'atteigne
</FONT></I>      <B><FONT COLOR="#A020F0">if</FONT></B> (ok) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (!back_exist
            (sback, opt, heap(p)-&gt;adr, heap(p)-&gt;fil, heap(p)-&gt;sav)) {
          <B><FONT COLOR="#A020F0">if</FONT></B> (back_add
              (sback, opt, cache, heap(p)-&gt;adr, heap(p)-&gt;fil, heap(p)-&gt;sav,
               heap(heap(p)-&gt;precedent)-&gt;adr, heap(heap(p)-&gt;precedent)-&gt;fil,
               heap(p)-&gt;testmode) == -1) {
            hts_log_print(opt, LOG_DEBUG,
                          <B><FONT COLOR="#BC8F8F">&quot;error: unable to add more links through back_add for back_fill&quot;</FONT></B>);
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">BDEBUG</FONT>==1
            printf(<B><FONT COLOR="#BC8F8F">&quot;error while adding\n&quot;</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
            n = 0;              <I><FONT COLOR="#B22222">// sortir
</FONT></I>          } <B><FONT COLOR="#A020F0">else</FONT></B> {
            n--;
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">BDEBUG</FONT>==1
            printf(<B><FONT COLOR="#BC8F8F">&quot;backing: %s%s\n&quot;</FONT></B>, heap(p)-&gt;adr, heap(p)-&gt;fil);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
          }
        }
      }
      p++;
    }                           <I><FONT COLOR="#B22222">// while
</FONT></I>    <I><FONT COLOR="#B22222">/* sauver position dernière anticipation */</FONT></I>
    cache-&gt;ptr_ant = p;
    cache-&gt;ptr_last = ptr;
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}

<I><FONT COLOR="#B22222">// ---
</FONT></I>
<I><FONT COLOR="#B22222">// Poll stdin.. si besoin
</FONT></I>#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_POLL</FONT>
<I><FONT COLOR="#B22222">// lecture stdin des caractères disponibles
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">read_stdin</FONT></B>(<B><FONT COLOR="#228B22">char</FONT></B> *s, <B><FONT COLOR="#228B22">int</FONT></B> max) {
  <B><FONT COLOR="#228B22">int</FONT></B> i = 0;

  <B><FONT COLOR="#A020F0">while</FONT></B>((check_stdin()) &amp;&amp; (i &lt; (max - 1)))
    s[i++] = fgetc(stdin);
  s[i] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
  <B><FONT COLOR="#A020F0">return</FONT></B> i;
}

#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">_WIN32</FONT>
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">check_stdin</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>) {
  <B><FONT COLOR="#A020F0">return</FONT></B> (_kbhit());
}
#<B><FONT COLOR="#5F9EA0">else</FONT></B>
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">check_flot</FONT></B>(T_SOC s) {
  fd_set fds;
  <B><FONT COLOR="#228B22">struct</FONT></B> timeval tv;

  FD_ZERO(&amp;fds);
  FD_SET((T_SOC) s, &amp;fds);
  tv.tv_sec = 0;
  tv.tv_usec = 0;
  select(s + 1, &amp;fds, NULL, NULL, &amp;tv);
  <B><FONT COLOR="#A020F0">return</FONT></B> FD_ISSET(s, &amp;fds);
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">check_stdin</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>) {
  fflush(stdout);
  fflush(stdin);
  <B><FONT COLOR="#A020F0">if</FONT></B> (check_flot(0))
    <B><FONT COLOR="#A020F0">return</FONT></B> 1;
  <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">check_sockerror</FONT></B>(T_SOC s) {
  fd_set fds;
  <B><FONT COLOR="#228B22">struct</FONT></B> timeval tv;

  FD_ZERO(&amp;fds);
  FD_SET((T_SOC) s, &amp;fds);
  tv.tv_sec = 0;
  tv.tv_usec = 0;
  select((<B><FONT COLOR="#228B22">int</FONT></B>) s + 1, NULL, NULL, &amp;fds, &amp;tv);
  <B><FONT COLOR="#A020F0">return</FONT></B> FD_ISSET(s, &amp;fds);
}

<I><FONT COLOR="#B22222">/* check incoming data */</FONT></I>
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">check_sockdata</FONT></B>(T_SOC s) {
  fd_set fds;
  <B><FONT COLOR="#228B22">struct</FONT></B> timeval tv;

  FD_ZERO(&amp;fds);
  FD_SET((T_SOC) s, &amp;fds);
  tv.tv_sec = 0;
  tv.tv_usec = 0;
  select((<B><FONT COLOR="#228B22">int</FONT></B>) s + 1, &amp;fds, NULL, NULL, &amp;tv);
  <B><FONT COLOR="#A020F0">return</FONT></B> FD_ISSET(s, &amp;fds);
}

<I><FONT COLOR="#B22222">// Attente de touche
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">ask_continue</FONT></B>(httrackp * opt) {
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *s;

  s = RUN_CALLBACK1(opt, query2, opt-&gt;state.HTbuff);
  <B><FONT COLOR="#A020F0">if</FONT></B> (s) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (strnotempty(s)) {
      <B><FONT COLOR="#A020F0">if</FONT></B> ((strfield2(s, <B><FONT COLOR="#BC8F8F">&quot;N&quot;</FONT></B>)) || (strfield2(s, <B><FONT COLOR="#BC8F8F">&quot;NO&quot;</FONT></B>)) || (strfield2(s, <B><FONT COLOR="#BC8F8F">&quot;NON&quot;</FONT></B>)))
        <B><FONT COLOR="#A020F0">return</FONT></B> 0;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> 1;
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> 1;
}

<I><FONT COLOR="#B22222">// nombre de digits dans un nombre
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">nombre_digit</FONT></B>(<B><FONT COLOR="#228B22">int</FONT></B> n) {
  <B><FONT COLOR="#228B22">int</FONT></B> i = 1;

  <B><FONT COLOR="#A020F0">while</FONT></B>(n &gt;= 10) {
    n /= 10;
    i++;
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> i;
}

<I><FONT COLOR="#B22222">// renvoi adresse de la fin du token dans p
</FONT></I><I><FONT COLOR="#B22222">// renvoi NULL si la chaine est un token unique
</FONT></I><I><FONT COLOR="#B22222">// (PATCHE également la chaine)
</FONT></I><I><FONT COLOR="#B22222">// ex: &quot;test&quot; &quot;test2&quot; renvoi adresse sur espace
</FONT></I><I><FONT COLOR="#B22222">// flag==1 si chaine comporte des echappements comme \&quot;
</FONT></I><B><FONT COLOR="#228B22">char</FONT></B> *<B><FONT COLOR="#0000FF">next_token</FONT></B>(<B><FONT COLOR="#228B22">char</FONT></B> *p, <B><FONT COLOR="#228B22">int</FONT></B> flag) {
  <B><FONT COLOR="#228B22">int</FONT></B> detect = 0;
  <B><FONT COLOR="#228B22">int</FONT></B> quote = 0;

  p--;
  <B><FONT COLOR="#A020F0">do</FONT></B> {
    p++;
    <B><FONT COLOR="#A020F0">if</FONT></B> (flag &amp;&amp; (*p == <B><FONT COLOR="#BC8F8F">'\\'</FONT></B>)) { <I><FONT COLOR="#B22222">// sauter \x ou \&quot;
</FONT></I>      <B><FONT COLOR="#A020F0">if</FONT></B> (quote) {
        <B><FONT COLOR="#228B22">char</FONT></B> c = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;

        <B><FONT COLOR="#A020F0">if</FONT></B> (*(p + 1) == <B><FONT COLOR="#BC8F8F">'\\'</FONT></B>)
          c = <B><FONT COLOR="#BC8F8F">'\\'</FONT></B>;
        <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (*(p + 1) == <B><FONT COLOR="#BC8F8F">'&quot;'</FONT></B>)
          c = <B><FONT COLOR="#BC8F8F">'&quot;'</FONT></B>;
        <B><FONT COLOR="#A020F0">if</FONT></B> (c) {
          <B><FONT COLOR="#228B22">char</FONT></B> BIGSTK tempo[8192];

          tempo[0] = c;
          tempo[1] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
          strcatbuff(tempo, p + 2);
          strcpybuff(p, tempo);
        }
      }
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (*p == 34) {      <I><FONT COLOR="#B22222">// guillemets (de fin)
</FONT></I>      <B><FONT COLOR="#228B22">char</FONT></B> BIGSTK tempo[8192];

      tempo[0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
      strcatbuff(tempo, p + 1);
      strcpybuff(p, tempo);     <I><FONT COLOR="#B22222">/* wipe &quot;&quot; */</FONT></I>
      p--;
      <I><FONT COLOR="#B22222">/* */</FONT></I>
      quote = !quote;
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (*p == 32) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (!quote)
        detect = 1;
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (*p == <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>) {
      p = NULL;
      detect = 1;
    }
  } <B><FONT COLOR="#A020F0">while</FONT></B>(!detect);
  <B><FONT COLOR="#A020F0">return</FONT></B> p;
}

<B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">hts_cancel_file_push_</FONT></B>(httrackp * opt, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *url) {
  <B><FONT COLOR="#A020F0">if</FONT></B> (url != NULL &amp;&amp; url[0] != <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>) {
    htsoptstatecancel **cancel;

    <I><FONT COLOR="#B22222">/* search for available place to store a new htsoptstatecancel* */</FONT></I>
    <B><FONT COLOR="#A020F0">for</FONT></B>(cancel = &amp;opt-&gt;state.cancel; *cancel != NULL;
        cancel = &amp;((*cancel)-&gt;next)) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (strcmp((*cancel)-&gt;url, url) == 0) {
        <B><FONT COLOR="#A020F0">return</FONT></B> 1;               <I><FONT COLOR="#B22222">/* already there */</FONT></I>
      }
    }
    *cancel = malloct(<B><FONT COLOR="#A020F0">sizeof</FONT></B>(htsoptstatecancel));
    (*cancel)-&gt;next = NULL;
    (*cancel)-&gt;url = strdupt(url);
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> 1;
}

<I><FONT COLOR="#B22222">/* cancel a file (locked) */</FONT></I>
HTSEXT_API <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">hts_cancel_file_push</FONT></B>(httrackp * opt, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *url) {
  <B><FONT COLOR="#228B22">int</FONT></B> ret;

  hts_mutexlock(&amp;opt-&gt;state.lock);
  ret = hts_cancel_file_push_(opt, url);
  hts_mutexrelease(&amp;opt-&gt;state.lock);
  <B><FONT COLOR="#A020F0">return</FONT></B> ret;
}

<B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *<B><FONT COLOR="#0000FF">hts_cancel_file_pop_</FONT></B>(httrackp * opt) {
  <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;state.cancel != NULL) {
    htsoptstatecancel **cancel;
    htsoptstatecancel *ret;

    <B><FONT COLOR="#A020F0">for</FONT></B>(cancel = &amp;opt-&gt;state.cancel; (*cancel)-&gt;next != NULL;
        cancel = &amp;((*cancel)-&gt;next)) ;
    ret = *cancel;
    *cancel = NULL;
    <B><FONT COLOR="#A020F0">return</FONT></B> ret-&gt;url;
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> NULL;                  <I><FONT COLOR="#B22222">/* no entry */</FONT></I>
}

<B><FONT COLOR="#228B22">char</FONT></B> *<B><FONT COLOR="#0000FF">hts_cancel_file_pop</FONT></B>(httrackp * opt) {
  <B><FONT COLOR="#228B22">char</FONT></B> *ret;

  hts_mutexlock(&amp;opt-&gt;state.lock);
  ret = hts_cancel_file_pop_(opt);
  hts_mutexrelease(&amp;opt-&gt;state.lock);
  <B><FONT COLOR="#A020F0">return</FONT></B> ret;
}

HTSEXT_API <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">hts_cancel_test</FONT></B>(httrackp * opt) {
  <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;state._hts_in_html_parsing == 2)
    opt-&gt;state._hts_cancel = 2;
}
HTSEXT_API <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">hts_cancel_parsing</FONT></B>(httrackp * opt) {
  <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;state._hts_in_html_parsing)
    opt-&gt;state._hts_cancel = 1;
}

<I><FONT COLOR="#B22222">// en train de parser un fichier html? réponse: % effectués
</FONT></I><I><FONT COLOR="#B22222">// flag&gt;0 : refresh demandé
</FONT></I>HTSEXT_API <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">hts_is_parsing</FONT></B>(httrackp * opt, <B><FONT COLOR="#228B22">int</FONT></B> flag) {
  <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;state._hts_in_html_parsing) {        <I><FONT COLOR="#B22222">// parsing?
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B> (flag &gt;= 0)
      opt-&gt;state._hts_in_html_poll = 1; <I><FONT COLOR="#B22222">// faudrait un tit refresh
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> max(opt-&gt;state._hts_in_html_done, 1);        <I><FONT COLOR="#B22222">// % effectués
</FONT></I>  } <B><FONT COLOR="#A020F0">else</FONT></B> {
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;                   <I><FONT COLOR="#B22222">// non
</FONT></I>  }
}
HTSEXT_API <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">hts_is_testing</FONT></B>(httrackp * opt) { <I><FONT COLOR="#B22222">// 0 non 1 test 2 purge
</FONT></I>  <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;state._hts_in_html_parsing == 2)
    <B><FONT COLOR="#A020F0">return</FONT></B> 1;
  <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;state._hts_in_html_parsing == 3)
    <B><FONT COLOR="#A020F0">return</FONT></B> 2;
  <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;state._hts_in_html_parsing == 4)
    <B><FONT COLOR="#A020F0">return</FONT></B> 3;
  <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;state._hts_in_html_parsing == 5)        <I><FONT COLOR="#B22222">// scheduling
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> 4;
  <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;state._hts_in_html_parsing == 6)        <I><FONT COLOR="#B22222">// wait for slot
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> 5;
  <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}
HTSEXT_API <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">hts_is_exiting</FONT></B>(httrackp * opt) {
  <B><FONT COLOR="#A020F0">return</FONT></B> opt-&gt;state.exit_xh;
}

<I><FONT COLOR="#B22222">// message d'erreur?
</FONT></I><B><FONT COLOR="#228B22">char</FONT></B> *<B><FONT COLOR="#0000FF">hts_errmsg</FONT></B>(httrackp * opt) {
  <B><FONT COLOR="#A020F0">return</FONT></B> opt-&gt;state._hts_errmsg;
}

<I><FONT COLOR="#B22222">// mode pause transfer
</FONT></I>HTSEXT_API <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">hts_setpause</FONT></B>(httrackp * opt, <B><FONT COLOR="#228B22">int</FONT></B> p) {
  <B><FONT COLOR="#A020F0">if</FONT></B> (p &gt;= 0)
    opt-&gt;state._hts_setpause = p;
  <B><FONT COLOR="#A020F0">return</FONT></B> opt-&gt;state._hts_setpause;
}

<I><FONT COLOR="#B22222">// ask for termination
</FONT></I>HTSEXT_API <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">hts_request_stop</FONT></B>(httrackp * opt, <B><FONT COLOR="#228B22">int</FONT></B> force) {
  <B><FONT COLOR="#A020F0">if</FONT></B> (opt != NULL) {
    hts_log_print(opt, LOG_ERROR, <B><FONT COLOR="#BC8F8F">&quot;Exit requested by shell or user&quot;</FONT></B>);
    hts_mutexlock(&amp;opt-&gt;state.lock);
    opt-&gt;state.stop = 1;
    hts_mutexrelease(&amp;opt-&gt;state.lock);
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}

HTSEXT_API <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">hts_has_stopped</FONT></B>(httrackp * opt) {
  <B><FONT COLOR="#228B22">int</FONT></B> ended;
  hts_mutexlock(&amp;opt-&gt;state.lock);
  ended = opt-&gt;state.is_ended;
  hts_mutexrelease(&amp;opt-&gt;state.lock);
  <B><FONT COLOR="#A020F0">return</FONT></B> ended;
}

<I><FONT COLOR="#B22222">// régler en cours de route les paramètres réglables..
</FONT></I><I><FONT COLOR="#B22222">// -1 : erreur
</FONT></I><I><FONT COLOR="#B22222">//HTSEXT_API int hts_setopt(httrackp* set_opt) {
</FONT></I><I><FONT COLOR="#B22222">//  if (set_opt) {
</FONT></I><I><FONT COLOR="#B22222">//    httrackp* engine_opt=hts_declareoptbuffer(NULL);
</FONT></I><I><FONT COLOR="#B22222">//    if (engine_opt) {
</FONT></I><I><FONT COLOR="#B22222">//      //_hts_setopt=opt;
</FONT></I><I><FONT COLOR="#B22222">//      copy_htsopt(set_opt,engine_opt);
</FONT></I><I><FONT COLOR="#B22222">//    }
</FONT></I><I><FONT COLOR="#B22222">//  }
</FONT></I><I><FONT COLOR="#B22222">//  return 0;
</FONT></I><I><FONT COLOR="#B22222">//}
</FONT></I><I><FONT COLOR="#B22222">// ajout d'URL
</FONT></I><I><FONT COLOR="#B22222">// -1 : erreur
</FONT></I>HTSEXT_API <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">hts_addurl</FONT></B>(httrackp * opt, <B><FONT COLOR="#228B22">char</FONT></B> **url) {
  <B><FONT COLOR="#A020F0">if</FONT></B> (url)
    opt-&gt;state._hts_addurl = url;
  <B><FONT COLOR="#A020F0">return</FONT></B> (opt-&gt;state._hts_addurl != NULL);
}
HTSEXT_API <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">hts_resetaddurl</FONT></B>(httrackp * opt) {
  opt-&gt;state._hts_addurl = NULL;
  <B><FONT COLOR="#A020F0">return</FONT></B> (opt-&gt;state._hts_addurl != NULL);
}

<I><FONT COLOR="#B22222">// copier nouveaux paramètres si besoin
</FONT></I>HTSEXT_API <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">copy_htsopt</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> httrackp * from, httrackp * to) {
  <B><FONT COLOR="#A020F0">if</FONT></B> (from-&gt;maxsite &gt; -1)
    to-&gt;maxsite = from-&gt;maxsite;

  <B><FONT COLOR="#A020F0">if</FONT></B> (from-&gt;maxfile_nonhtml &gt; -1)
    to-&gt;maxfile_nonhtml = from-&gt;maxfile_nonhtml;

  <B><FONT COLOR="#A020F0">if</FONT></B> (from-&gt;maxfile_html &gt; -1)
    to-&gt;maxfile_html = from-&gt;maxfile_html;

  <B><FONT COLOR="#A020F0">if</FONT></B> (from-&gt;maxsoc &gt; 0)
    to-&gt;maxsoc = from-&gt;maxsoc;

  <B><FONT COLOR="#A020F0">if</FONT></B> (from-&gt;nearlink &gt; -1)
    to-&gt;nearlink = from-&gt;nearlink;

  <B><FONT COLOR="#A020F0">if</FONT></B> (from-&gt;timeout &gt; -1)
    to-&gt;timeout = from-&gt;timeout;

  <B><FONT COLOR="#A020F0">if</FONT></B> (from-&gt;rateout &gt; -1)
    to-&gt;rateout = from-&gt;rateout;

  <B><FONT COLOR="#A020F0">if</FONT></B> (from-&gt;maxtime &gt; -1)
    to-&gt;maxtime = from-&gt;maxtime;

  <B><FONT COLOR="#A020F0">if</FONT></B> (from-&gt;maxrate &gt; -1)
    to-&gt;maxrate = from-&gt;maxrate;

  <B><FONT COLOR="#A020F0">if</FONT></B> (from-&gt;maxconn &gt; 0)
    to-&gt;maxconn = from-&gt;maxconn;

  <B><FONT COLOR="#A020F0">if</FONT></B> (StringNotEmpty(from-&gt;user_agent))
    StringCopyS(to-&gt;user_agent, from-&gt;user_agent);

  <B><FONT COLOR="#A020F0">if</FONT></B> (from-&gt;retry &gt; -1)
    to-&gt;retry = from-&gt;retry;

  <B><FONT COLOR="#A020F0">if</FONT></B> (from-&gt;hostcontrol &gt; -1)
    to-&gt;hostcontrol = from-&gt;hostcontrol;

  <B><FONT COLOR="#A020F0">if</FONT></B> (from-&gt;errpage &gt; -1)
    to-&gt;errpage = from-&gt;errpage;

  <B><FONT COLOR="#A020F0">if</FONT></B> (from-&gt;parseall &gt; -1)
    to-&gt;parseall = from-&gt;parseall;

  <I><FONT COLOR="#B22222">// test all: bit 8 de travel
</FONT></I>  <B><FONT COLOR="#A020F0">if</FONT></B> (from-&gt;travel &gt; -1) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (from-&gt;travel &amp; 256)
      to-&gt;travel |= 256;
    <B><FONT COLOR="#A020F0">else</FONT></B>
      to-&gt;travel &amp;= 255;
  }

  <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}

<I><FONT COLOR="#B22222">//
</FONT></I>
<I><FONT COLOR="#B22222">/* External modules callback */</FONT></I>
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">htsAddLink</FONT></B>(htsmoduleStruct * str, <B><FONT COLOR="#228B22">char</FONT></B> *link) {
  <B><FONT COLOR="#A020F0">if</FONT></B> (link != NULL &amp;&amp; str != NULL &amp;&amp; link[0] != <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>) {
    ENGINE_LOAD_CONTEXT_BASE();
    <I><FONT COLOR="#B22222">/* */</FONT></I>
    lien_adrfilsave afs;
    <B><FONT COLOR="#228B22">char</FONT></B> BIGSTK codebase[HTS_URLMAXSIZE * 2];

    <I><FONT COLOR="#B22222">/* */</FONT></I>
    <B><FONT COLOR="#228B22">int</FONT></B> pass_fix, prio_fix;

    <I><FONT COLOR="#B22222">/* */</FONT></I>
    <B><FONT COLOR="#228B22">int</FONT></B> forbidden_url = 1;

    codebase[0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;

    hts_log_print(opt, LOG_DEBUG, <B><FONT COLOR="#BC8F8F">&quot;(module): adding link : '%s'&quot;</FONT></B>, link);
    <I><FONT COLOR="#B22222">// recopie de &quot;creer le lien&quot;
</FONT></I>    <I><FONT COLOR="#B22222">//    
</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B> (!RUN_CALLBACK1(opt, linkdetected, link)) {
      hts_log_print(opt, LOG_ERROR, <B><FONT COLOR="#BC8F8F">&quot;Link %s refused by external wrapper&quot;</FONT></B>,
                    link);
      <B><FONT COLOR="#A020F0">return</FONT></B> 0;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (!RUN_CALLBACK2(opt, linkdetected2, link, NULL)) {
      hts_log_print(opt, LOG_ERROR, <B><FONT COLOR="#BC8F8F">&quot;Link %s refused by external wrapper(2)&quot;</FONT></B>,
                    link);
      <B><FONT COLOR="#A020F0">return</FONT></B> 0;
    }
    <I><FONT COLOR="#B22222">// adr = c'est la même
</FONT></I>    <I><FONT COLOR="#B22222">// fil et save: save2 et fil2
</FONT></I>    prio_fix = maximum(heap(ptr)-&gt;depth - 1, 0);
    pass_fix = max(heap(ptr)-&gt;pass2, numero_passe);
    <B><FONT COLOR="#A020F0">if</FONT></B> (heap(ptr)-&gt;cod)
      strcpybuff(codebase, heap(ptr)-&gt;cod);    <I><FONT COLOR="#B22222">// codebase valable pour tt les classes descendantes
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B> (strnotempty(codebase) == 0) {   <I><FONT COLOR="#B22222">// pas de codebase, construire
</FONT></I>      <B><FONT COLOR="#228B22">char</FONT></B> *a;

      <B><FONT COLOR="#A020F0">if</FONT></B> (str-&gt;relativeToHtmlLink == 0)
        strcpybuff(codebase, heap(ptr)-&gt;fil);
      <B><FONT COLOR="#A020F0">else</FONT></B>
        strcpybuff(codebase, heap(heap(ptr)-&gt;precedent)-&gt;fil);
      a = codebase + strlen(codebase) - 1;
      <B><FONT COLOR="#A020F0">while</FONT></B>((*a) &amp;&amp; (*a != <B><FONT COLOR="#BC8F8F">'/'</FONT></B>) &amp;&amp; (a &gt; codebase))
        a--;
      <B><FONT COLOR="#A020F0">if</FONT></B> (*a == <B><FONT COLOR="#BC8F8F">'/'</FONT></B>)
        *(a + 1) = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;        <I><FONT COLOR="#B22222">// couper
</FONT></I>    } <B><FONT COLOR="#A020F0">else</FONT></B> {                    <I><FONT COLOR="#B22222">// couper http:// éventuel
</FONT></I>      <B><FONT COLOR="#A020F0">if</FONT></B> (strfield(codebase, <B><FONT COLOR="#BC8F8F">&quot;http://&quot;</FONT></B>)) {
        <B><FONT COLOR="#228B22">char</FONT></B> BIGSTK tempo[HTS_URLMAXSIZE * 2];
        <B><FONT COLOR="#228B22">char</FONT></B> *a = codebase + 7;

        a = strchr(a, <B><FONT COLOR="#BC8F8F">'/'</FONT></B>);     <I><FONT COLOR="#B22222">// après host
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (a) {                <I><FONT COLOR="#B22222">// ** msg erreur et vérifier?
</FONT></I>          strcpybuff(tempo, a);
          strcpybuff(codebase, tempo);  <I><FONT COLOR="#B22222">// couper host
</FONT></I>        } <B><FONT COLOR="#A020F0">else</FONT></B> {
          hts_log_print(opt, LOG_ERROR, <B><FONT COLOR="#BC8F8F">&quot;Unexpected strstr error in base %s&quot;</FONT></B>,
                        codebase);
        }
      }
    }

    <B><FONT COLOR="#A020F0">if</FONT></B> (!((<B><FONT COLOR="#228B22">int</FONT></B>) strlen(codebase) &lt; HTS_URLMAXSIZE)) {   <I><FONT COLOR="#B22222">// trop long
</FONT></I>      hts_log_print(opt, LOG_ERROR, <B><FONT COLOR="#BC8F8F">&quot;Codebase too long, parsing skipped (%s)&quot;</FONT></B>,
                    codebase);
    }

    {
      <B><FONT COLOR="#228B22">char</FONT></B> *lien = link;
      <B><FONT COLOR="#228B22">int</FONT></B> dejafait = 0;

      <B><FONT COLOR="#A020F0">if</FONT></B> (strnotempty(lien) &amp;&amp; strlen(lien) &lt; HTS_URLMAXSIZE) {

        <I><FONT COLOR="#B22222">// calculer les chemins et noms de sauvegarde
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (ident_url_relatif(lien, urladr(), codebase, &amp;afs.af) &gt;= 0) { <I><FONT COLOR="#B22222">// reformage selon chemin
</FONT></I>          <B><FONT COLOR="#228B22">int</FONT></B> r;
          <B><FONT COLOR="#228B22">int</FONT></B> set_prio_to = 0;
          <B><FONT COLOR="#228B22">int</FONT></B> just_test_it = 0;

          forbidden_url =
            hts_acceptlink(opt, ptr, afs.af.adr, afs.af.fil, NULL, NULL, &amp;set_prio_to, &amp;just_test_it);
          hts_log_print(opt, LOG_DEBUG,
                        <B><FONT COLOR="#BC8F8F">&quot;result for wizard external module link: %d&quot;</FONT></B>,
                        forbidden_url);

          <I><FONT COLOR="#B22222">/* Link accepted */</FONT></I>
          <B><FONT COLOR="#A020F0">if</FONT></B> (!forbidden_url) {
            <B><FONT COLOR="#228B22">char</FONT></B> BIGSTK tempo[HTS_URLMAXSIZE * 2];
            <B><FONT COLOR="#228B22">int</FONT></B> a, b;

            tempo[0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
            a = opt-&gt;savename_type;
            b = opt-&gt;savename_83;
            opt-&gt;savename_type = 0;
            opt-&gt;savename_83 = 0;
            <I><FONT COLOR="#B22222">// note: adr,fil peuvent être patchés
</FONT></I>            r =
              url_savename(&amp;afs, NULL, NULL, NULL, opt, sback, cache, hashptr, ptr, numero_passe,
                           NULL);
            <I><FONT COLOR="#B22222">// resolve unresolved type
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B> (r != -1 &amp;&amp; forbidden_url == 0 &amp;&amp; IS_DELAYED_EXT(afs.save)
              ) {               <I><FONT COLOR="#B22222">// pas d'erreur, on continue
</FONT></I>              lien_adrfil former;

              former.adr[0] = former.fil[0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
              r =
                hts_wait_delayed(str, &amp;afs, NULL, NULL, &amp;former, &amp;forbidden_url);
            }
            <I><FONT COLOR="#B22222">// end resolve unresolved type
</FONT></I>            opt-&gt;savename_type = a;
            opt-&gt;savename_83 = b;
            <B><FONT COLOR="#A020F0">if</FONT></B> (r != -1 &amp;&amp; !forbidden_url) {
              <B><FONT COLOR="#A020F0">if</FONT></B> (savename()) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (lienrelatif(tempo, afs.save, savename()) == 0) {
                  hts_log_print(opt, LOG_DEBUG,
                                <B><FONT COLOR="#BC8F8F">&quot;(module): relative link at %s build with %s and %s: %s&quot;</FONT></B>,
                                afs.af.adr, afs.save, savename(), tempo);
                  <B><FONT COLOR="#A020F0">if</FONT></B> (str-&gt;localLink
                      &amp;&amp; str-&gt;localLinkSize &gt; (<B><FONT COLOR="#228B22">int</FONT></B>) strlen(tempo) + 1) {
                    strcpybuff(str-&gt;localLink, tempo);
                  }
                }
              }
            }
          }

          <B><FONT COLOR="#A020F0">if</FONT></B> (forbidden_url) {
            hts_log_print(opt, LOG_DEBUG, <B><FONT COLOR="#BC8F8F">&quot;(module): file not caught: %s&quot;</FONT></B>,
                          lien);
            <B><FONT COLOR="#A020F0">if</FONT></B> (str-&gt;localLink
                &amp;&amp; str-&gt;localLinkSize &gt; (<B><FONT COLOR="#228B22">int</FONT></B>) (strlen(afs.af.adr) + strlen(afs.af.fil) + 8)) {
              str-&gt;localLink[0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
              <B><FONT COLOR="#A020F0">if</FONT></B> (!link_has_authority(afs.af.adr))
                strcpybuff(str-&gt;localLink, <B><FONT COLOR="#BC8F8F">&quot;http://&quot;</FONT></B>);
              strcatbuff(str-&gt;localLink, afs.af.adr);
              strcatbuff(str-&gt;localLink, afs.af.fil);
            }
            r = -1;
          }
          <I><FONT COLOR="#B22222">//
</FONT></I>          <B><FONT COLOR="#A020F0">if</FONT></B> (r != -1) {
            hts_log_print(opt, LOG_DEBUG, <B><FONT COLOR="#BC8F8F">&quot;(module): %s%s -&gt; %s (base %s)&quot;</FONT></B>, afs.af.adr,
                          afs.af.fil, afs.save, codebase);

            <I><FONT COLOR="#B22222">// modifié par rapport à l'autre version (cf prio_fix notamment et save2)
</FONT></I>
            <I><FONT COLOR="#B22222">// vérifier que le lien n'a pas déja été noté
</FONT></I>            <I><FONT COLOR="#B22222">// si c'est le cas, alors il faut s'assurer que la priorité associée
</FONT></I>            <I><FONT COLOR="#B22222">// au fichier est la plus grande des deux priorités
</FONT></I>            <I><FONT COLOR="#B22222">//
</FONT></I>            <I><FONT COLOR="#B22222">// On part de la fin et on essaye de se presser (économise temps machine)
</FONT></I>            {
              <B><FONT COLOR="#228B22">int</FONT></B> i = hash_read(hashptr, afs.save, NULL, HASH_STRUCT_FILENAME );    <I><FONT COLOR="#B22222">// lecture type 0 (sav)
</FONT></I>
              <B><FONT COLOR="#A020F0">if</FONT></B> (i &gt;= 0) {
                heap(i)-&gt;depth = maximum(heap(i)-&gt;depth, prio_fix);
                dejafait = 1;
              }
            }

            <B><FONT COLOR="#A020F0">if</FONT></B> (!dejafait) {
              <I><FONT COLOR="#B22222">//
</FONT></I>              <I><FONT COLOR="#B22222">// &gt;&gt;&gt;&gt; CREER LE LIEN JAVA &lt;&lt;&lt;&lt;
</FONT></I>
              <I><FONT COLOR="#B22222">// enregistrer fichier (MACRO)
</FONT></I>              <B><FONT COLOR="#A020F0">if</FONT></B> (!hts_record_link(opt, afs.af.adr, afs.af.fil, afs.save, <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>)) {    <I><FONT COLOR="#B22222">// erreur, pas de place réservée
</FONT></I>                opt-&gt;state.exit_xh = -1;        <I><FONT COLOR="#B22222">/* fatal error -&gt; exit */</FONT></I>
                <B><FONT COLOR="#A020F0">return</FONT></B> 0;
              }
              <I><FONT COLOR="#B22222">// mode test?                          
</FONT></I>              heap_top()-&gt;testmode = 0;    <I><FONT COLOR="#B22222">// pas mode test
</FONT></I>              heap_top()-&gt;link_import = 0; <I><FONT COLOR="#B22222">// pas mode import
</FONT></I>
              <I><FONT COLOR="#B22222">// écrire autres paramètres de la structure-lien
</FONT></I>              <I><FONT COLOR="#B22222">//if (meme_adresse)                                 
</FONT></I>              heap_top()-&gt;premier = heap(ptr)-&gt;premier;
              <I><FONT COLOR="#B22222">//else    // sinon l'objet père est le précédent lui même
</FONT></I>              <I><FONT COLOR="#B22222">//  heap_top()-&gt;premier=ptr;
</FONT></I>
              heap_top()-&gt;precedent = ptr;
              <I><FONT COLOR="#B22222">// noter la priorité
</FONT></I>              <B><FONT COLOR="#A020F0">if</FONT></B> (!set_prio_to)
                heap_top()-&gt;depth = prio_fix;
              <B><FONT COLOR="#A020F0">else</FONT></B>
                heap_top()-&gt;depth = max(0, min(heap(ptr)-&gt;depth - 1, set_prio_to - 1));   <I><FONT COLOR="#B22222">// PRIORITE NULLE (catch page)
</FONT></I>              heap_top()-&gt;pass2 = max(pass_fix, numero_passe);
              heap_top()-&gt;retry = opt-&gt;retry;

              <I><FONT COLOR="#B22222">//strcpybuff(heap_top()-&gt;adr,adr);
</FONT></I>              <I><FONT COLOR="#B22222">//strcpybuff(heap_top()-&gt;fil,fil);
</FONT></I>              <I><FONT COLOR="#B22222">//strcpybuff(heap_top()-&gt;sav,save); 
</FONT></I>              hts_log_print(opt, LOG_DEBUG, <B><FONT COLOR="#BC8F8F">&quot;(module): OK, NOTE: %s%s -&gt; %s&quot;</FONT></B>,
                            heap_top()-&gt;adr, heap_top()-&gt;fil,
                            heap_top()-&gt;sav);

            }
          }
        }
      }
    }

    <I><FONT COLOR="#B22222">/* Apply changes */</FONT></I>
    ENGINE_SAVE_CONTEXT_BASE();

    <B><FONT COLOR="#A020F0">return</FONT></B> (forbidden_url == 0);
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}

<I><FONT COLOR="#B22222">// message copyright interne
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">voidf</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>) {
  <B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *a;

  a = <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B> CRLF <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B> CRLF;
  a = <B><FONT COLOR="#BC8F8F">&quot;+-----------------------------------------------+&quot;</FONT></B> CRLF;
  a = <B><FONT COLOR="#BC8F8F">&quot;|HyperTextTRACKer, Offline Browser Utility      |&quot;</FONT></B> CRLF;
  a = <B><FONT COLOR="#BC8F8F">&quot;|                      HTTrack Website Copier   |&quot;</FONT></B> CRLF;
  a = <B><FONT COLOR="#BC8F8F">&quot;|Code:         Windows Interface Xavier Roche   |&quot;</FONT></B> CRLF;
  a = <B><FONT COLOR="#BC8F8F">&quot;|                    HTS/HTTrack Xavier Roche   |&quot;</FONT></B> CRLF;
  a = <B><FONT COLOR="#BC8F8F">&quot;|                .class Parser Yann Philippot   |&quot;</FONT></B> CRLF;
  a = <B><FONT COLOR="#BC8F8F">&quot;|                                               |&quot;</FONT></B> CRLF;
  a = <B><FONT COLOR="#BC8F8F">&quot;|Tested on:                 Windows95,98,NT,2K  |&quot;</FONT></B> CRLF;
  a = <B><FONT COLOR="#BC8F8F">&quot;|                           Linux PC            |&quot;</FONT></B> CRLF;
  a = <B><FONT COLOR="#BC8F8F">&quot;|                           Sun-Solaris 5.6     |&quot;</FONT></B> CRLF;
  a = <B><FONT COLOR="#BC8F8F">&quot;|                           AIX 4               |&quot;</FONT></B> CRLF;
  a = <B><FONT COLOR="#BC8F8F">&quot;|                                               |&quot;</FONT></B> CRLF;
  a = <B><FONT COLOR="#BC8F8F">&quot;|Copyright (C) Xavier Roche and other           |&quot;</FONT></B> CRLF;
  a = <B><FONT COLOR="#BC8F8F">&quot;|contributors                                   |&quot;</FONT></B> CRLF;
  a = <B><FONT COLOR="#BC8F8F">&quot;|                                               |&quot;</FONT></B> CRLF;
  a = <B><FONT COLOR="#BC8F8F">&quot;|Use this program at your own risks!            |&quot;</FONT></B> CRLF;
  a = <B><FONT COLOR="#BC8F8F">&quot;+-----------------------------------------------+&quot;</FONT></B> CRLF;
  a = <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B> CRLF;
  (<B><FONT COLOR="#228B22">void</FONT></B>) a;
}

<I><FONT COLOR="#B22222">// HTTrack Website Copier Copyright (C) 1998-2015 Xavier Roche and other contributors
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I></PRE>
<HR>
<ADDRESS>Generated by <A HREF="http://www.iki.fi/~mtr/genscript/">GNU Enscript 1.6.5.90</A>.</ADDRESS>
</BODY>

<!-- Mirrored from www.httrack.com/src/htscore.c.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 02 Jan 2023 20:31:40 GMT -->
</HTML>
