<!DOCTYPE html PUBLIC "-//IETF//DTD HTML 2.0//EN">
<HTML>

<!-- Mirrored from www.httrack.com/src/htsback.c.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 02 Jan 2023 20:31:10 GMT -->
<HEAD>
<TITLE>./htsback.c - HTTrack Website Copier</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#1F00FF" ALINK="#FF0000" VLINK="#9900DD">
<A NAME="top">
<A NAME="file1">
<H1>./htsback.c</H1>

<PRE>
<I><FONT COLOR="#B22222">/* ------------------------------------------------------------ */</FONT></I>
<I><FONT COLOR="#B22222">/*
HTTrack Website Copier, Offline Browser for Windows and Unix
Copyright (C) 1998-2015 Xavier Roche and other contributors

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program. If not, see &lt;http://www.gnu.org/licenses/&gt;.

Important notes:

- We hereby ask people using this source NOT to use it in purpose of grabbing
emails addresses, or collecting any other private information on persons.
This would disgrace our work, and spoil the many hours we spent on it.

Please visit our Website: http://www.httrack.com
*/</FONT></I>

<I><FONT COLOR="#B22222">/* ------------------------------------------------------------ */</FONT></I>
<I><FONT COLOR="#B22222">/* File: httrack.c subroutines:                                 */</FONT></I>
<I><FONT COLOR="#B22222">/*       backing system (multiple socket download)              */</FONT></I>
<I><FONT COLOR="#B22222">/* Author: Xavier Roche                                         */</FONT></I>
<I><FONT COLOR="#B22222">/* ------------------------------------------------------------ */</FONT></I>

<I><FONT COLOR="#B22222">/* Internal engine bytecode */</FONT></I>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">HTS_INTERNAL_BYTECODE</FONT>

<I><FONT COLOR="#B22222">/* specific definitions */</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;htsnet.h&quot;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;htscore.h&quot;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;htsthread.h&quot;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;time.h&gt;</FONT></B>
<I><FONT COLOR="#B22222">/* END specific definitions */</FONT></I>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;htsback.h&quot;</FONT></B>

<I><FONT COLOR="#B22222">//#ifdef _WIN32
</FONT></I>#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;htsftp.h&quot;</FONT></B>
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_USEZLIB</FONT>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;htszlib.h&quot;</FONT></B>
#<B><FONT COLOR="#5F9EA0">else</FONT></B>
#<B><FONT COLOR="#5F9EA0">error</FONT></B> <FONT COLOR="#B8860B">HTS_USEZLIB</FONT> <FONT COLOR="#B8860B">not</FONT> <FONT COLOR="#B8860B">defined</FONT>
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
<I><FONT COLOR="#B22222">//#endif
</FONT></I>
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">_WIN32</FONT>
#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">__cplusplus</FONT>
<I><FONT COLOR="#B22222">// DOS
</FONT></I>#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;process.h&gt;</FONT></B>            <I><FONT COLOR="#B22222">/* _beginthread, _endthread */</FONT></I>
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
#<B><FONT COLOR="#5F9EA0">else</FONT></B>
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">VT_CLREOL</FONT>       <B><FONT COLOR="#BC8F8F">&quot;\33[K&quot;</FONT></B>

<I><FONT COLOR="#B22222">/* Slot operations */</FONT></I>
<B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">slot_can_be_cached_on_disk</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> lien_back * back);
<B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">slot_can_be_cleaned</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> lien_back * back);
<B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">slot_can_be_finalized</FONT></B>(httrackp * opt, <B><FONT COLOR="#228B22">const</FONT></B> lien_back * back);

struct_back *<B><FONT COLOR="#0000FF">back_new</FONT></B>(httrackp *opt, <B><FONT COLOR="#228B22">int</FONT></B> back_max) {
  <B><FONT COLOR="#228B22">int</FONT></B> i;
  struct_back *sback = calloct(1, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(struct_back));

  sback-&gt;count = back_max;
  sback-&gt;lnk = (lien_back *) calloct((back_max + 1), <B><FONT COLOR="#A020F0">sizeof</FONT></B>(lien_back));
  sback-&gt;ready = coucal_new(0);
  hts_set_hash_handler(sback-&gt;ready, opt);
  coucal_set_name(sback-&gt;ready, <B><FONT COLOR="#BC8F8F">&quot;back_new&quot;</FONT></B>);
  sback-&gt;ready_size_bytes = 0;
  coucal_value_is_malloc(sback-&gt;ready, 1);
  <I><FONT COLOR="#B22222">// init
</FONT></I>  <B><FONT COLOR="#A020F0">for</FONT></B>(i = 0; i &lt; sback-&gt;count; i++) {
    sback-&gt;lnk[i].r.location = sback-&gt;lnk[i].location_buffer;
    sback-&gt;lnk[i].status = STATUS_FREE;
    sback-&gt;lnk[i].r.soc = INVALID_SOCKET;
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> sback;
}

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">back_free</FONT></B>(struct_back ** sback) {
  <B><FONT COLOR="#A020F0">if</FONT></B> (sback != NULL &amp;&amp; *sback != NULL) {
    <B><FONT COLOR="#A020F0">if</FONT></B> ((*sback)-&gt;lnk != NULL) {
      freet((*sback)-&gt;lnk);
      (*sback)-&gt;lnk = NULL;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> ((*sback)-&gt;ready != NULL) {
      coucal_delete(&amp;(*sback)-&gt;ready);
      (*sback)-&gt;ready_size_bytes = 0;
    }
    freet(*sback);
    *sback = NULL;
  }
}

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">back_delete_all</FONT></B>(httrackp * opt, cache_back * cache, struct_back * sback) {
  <B><FONT COLOR="#A020F0">if</FONT></B> (sback != NULL) {
    <B><FONT COLOR="#228B22">int</FONT></B> i;

    <I><FONT COLOR="#B22222">// delete live slots
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(i = 0; i &lt; sback-&gt;count; i++) {
      back_delete(opt, cache, sback, i);
    }
    <I><FONT COLOR="#B22222">// delete stored slots
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B> (sback-&gt;ready != NULL) {
      struct_coucal_enum e = coucal_enum_new(sback-&gt;ready);
      coucal_item *item;

      <B><FONT COLOR="#A020F0">while</FONT></B>((item = coucal_enum_next(&amp;e))) {
#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">HTS_NO_BACK_ON_DISK</FONT>
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *filename = (<B><FONT COLOR="#228B22">char</FONT></B> *) item-&gt;value.ptr;

        <B><FONT COLOR="#A020F0">if</FONT></B> (filename != NULL) {
          (<B><FONT COLOR="#228B22">void</FONT></B>) UNLINK(filename);
        }
#<B><FONT COLOR="#5F9EA0">else</FONT></B>
        <I><FONT COLOR="#B22222">/* clear entry content (but not yet the entry) */</FONT></I>
        lien_back *back = (lien_back *) item-&gt;value.ptr;

        back_clear_entry(back);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
      }
      <I><FONT COLOR="#B22222">/* delete hashtable &amp; content */</FONT></I>
      coucal_delete(&amp;sback-&gt;ready);
      sback-&gt;ready_size_bytes = 0;
    }
  }
}

<I><FONT COLOR="#B22222">// ---
</FONT></I><I><FONT COLOR="#B22222">// routines de backing
</FONT></I>
<B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">back_index_ready</FONT></B>(httrackp * opt, struct_back * sback, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *adr,
                            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *fil, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *sav, <B><FONT COLOR="#228B22">int</FONT></B> getIndex);
<B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">back_index_fetch</FONT></B>(httrackp * opt, struct_back * sback, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *adr,
                            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *fil, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *sav, <B><FONT COLOR="#228B22">int</FONT></B> getIndex);

<I><FONT COLOR="#B22222">// retourne l'index d'un lien dans un tableau de backing
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">back_index</FONT></B>(httrackp * opt, struct_back * sback, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *adr, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *fil,
               <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *sav) {
  <B><FONT COLOR="#A020F0">return</FONT></B> back_index_fetch(opt, sback, adr, fil, sav, 1);
}

<B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">back_index_fetch</FONT></B>(httrackp * opt, struct_back * sback, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *adr,
                            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *fil, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *sav, <B><FONT COLOR="#228B22">int</FONT></B> getIndex) {
  lien_back *<B><FONT COLOR="#228B22">const</FONT></B> back = sback-&gt;lnk;
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> back_max = sback-&gt;count;
  <B><FONT COLOR="#228B22">int</FONT></B> index = -1;
  <B><FONT COLOR="#228B22">int</FONT></B> i;

  <B><FONT COLOR="#A020F0">for</FONT></B>(i = 0; i &lt; back_max; i++) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status &gt;= 0     <I><FONT COLOR="#B22222">/* not free or alive */</FONT></I>
        &amp;&amp; strfield2(back[i].url_adr, adr)
        &amp;&amp; strcmp(back[i].url_fil, fil) == 0) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (index == -1)          <I><FONT COLOR="#B22222">/* first time we meet, store it */</FONT></I>
        index = i;
      <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (sav != NULL &amp;&amp; strcmp(back[i].url_sav, sav) == 0) {      <I><FONT COLOR="#B22222">/* oops, check sav too */</FONT></I>
        index = i;
        <B><FONT COLOR="#A020F0">return</FONT></B> index;
      }
    }
  }
  <I><FONT COLOR="#B22222">// not found in fast repository - search in the storage hashtable
</FONT></I>  <B><FONT COLOR="#A020F0">if</FONT></B> (index == -1 &amp;&amp; sav != NULL) {
    index = back_index_ready(opt, sback, adr, fil, sav, getIndex);
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> index;
}

<I><FONT COLOR="#B22222">/* resurrect stored entry */</FONT></I>
<B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">back_index_ready</FONT></B>(httrackp * opt, struct_back * sback, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *adr,
                            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *fil, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *sav, <B><FONT COLOR="#228B22">int</FONT></B> getIndex) {
  lien_back *<B><FONT COLOR="#228B22">const</FONT></B> back = sback-&gt;lnk;
  <B><FONT COLOR="#228B22">void</FONT></B> *ptr = NULL;

  <B><FONT COLOR="#A020F0">if</FONT></B> (coucal_read_pvoid(sback-&gt;ready, sav, &amp;ptr)) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (!getIndex) {            <I><FONT COLOR="#B22222">/* don't &quot;pagefault&quot; the entry */</FONT></I>
      <B><FONT COLOR="#A020F0">if</FONT></B> (ptr != NULL) {
        <B><FONT COLOR="#A020F0">return</FONT></B> sback-&gt;count;    <I><FONT COLOR="#B22222">/* (invalid but) positive result */</FONT></I>
      } <B><FONT COLOR="#A020F0">else</FONT></B> {
        <B><FONT COLOR="#A020F0">return</FONT></B> -1;              <I><FONT COLOR="#B22222">/* not found */</FONT></I>
      }
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (ptr != NULL) {
      lien_back *itemback = NULL;

#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">HTS_NO_BACK_ON_DISK</FONT>
      FILE *fp;
      <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *fileback = (<B><FONT COLOR="#228B22">char</FONT></B> *) ptr;
      <B><FONT COLOR="#228B22">char</FONT></B> catbuff[CATBUFF_SIZE];

      <B><FONT COLOR="#A020F0">if</FONT></B> ((fp = FOPEN(fconv(catbuff, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(catbuff), fileback), <B><FONT COLOR="#BC8F8F">&quot;rb&quot;</FONT></B>)) != NULL) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (back_unserialize(fp, &amp;itemback) != 0) {
          <B><FONT COLOR="#A020F0">if</FONT></B> (itemback != NULL) {
            back_clear_entry(itemback);
            freet(itemback);
            itemback = NULL;
          }
          hts_log_print(opt, LOG_WARNING | LOG_ERRNO,
                        <B><FONT COLOR="#BC8F8F">&quot;engine: warning: unserialize error for %s%s (%s)&quot;</FONT></B>, adr,
                        fil, sav);
        }
        fclose(fp);
      } <B><FONT COLOR="#A020F0">else</FONT></B> {
        hts_log_print(opt, LOG_WARNING | LOG_ERRNO,
                      <B><FONT COLOR="#BC8F8F">&quot;engine: warning: unserialize error for %s%s (%s), file disappeared&quot;</FONT></B>,
                      adr, fil, sav);
      }
      (<B><FONT COLOR="#228B22">void</FONT></B>) UNLINK(fileback);
#<B><FONT COLOR="#5F9EA0">else</FONT></B>
      itemback = (lien_back *) ptr;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
      <B><FONT COLOR="#A020F0">if</FONT></B> (itemback != NULL) {
        <I><FONT COLOR="#B22222">// move from hashtable to fast repository
</FONT></I>        <B><FONT COLOR="#228B22">int</FONT></B> q = back_search(opt, sback);

        <B><FONT COLOR="#A020F0">if</FONT></B> (q != -1) {
          deletehttp(&amp;back[q].r);       <I><FONT COLOR="#B22222">// security check
</FONT></I>          back_move(itemback, &amp;back[q]);
          back_clear_entry(itemback);   <I><FONT COLOR="#B22222">/* delete entry content */</FONT></I>
          freet(itemback);      <I><FONT COLOR="#B22222">/* delete item */</FONT></I>
          itemback = NULL;
          coucal_remove(sback-&gt;ready, sav);    <I><FONT COLOR="#B22222">// delete item
</FONT></I>          sback-&gt;ready_size_bytes -= back[q].r.size;    <I><FONT COLOR="#B22222">/* substract for stats */</FONT></I>
          back_set_locked(sback, q);    <I><FONT COLOR="#B22222">/* locked */</FONT></I>
          <B><FONT COLOR="#A020F0">return</FONT></B> q;
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
          hts_log_print(opt, LOG_WARNING,
                        <B><FONT COLOR="#BC8F8F">&quot;engine: warning: unserialize error for %s%s (%s): no more space to wakeup frozen slots&quot;</FONT></B>,
                        adr, fil, sav);
        }
      }
    }
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> -1;
}

<B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">slot_can_be_cached_on_disk</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> lien_back * back) {
  <B><FONT COLOR="#A020F0">return</FONT></B> (back-&gt;status == STATUS_READY &amp;&amp; back-&gt;locked == 0
          &amp;&amp; back-&gt;url_sav[0] != <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>
          &amp;&amp; strcmp(back-&gt;url_sav, BACK_ADD_TEST) != 0);
  <I><FONT COLOR="#B22222">/* Note: not checking !IS_DELAYED_EXT(back-&gt;url_sav) or it will quickly cause the slots to be filled! */</FONT></I>
}

<I><FONT COLOR="#B22222">/* Put all backing entries that are ready in the storage hashtable to spare space and CPU */</FONT></I>
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">back_cleanup_background</FONT></B>(httrackp * opt, cache_back * cache,
                            struct_back * sback) {
  lien_back *<B><FONT COLOR="#228B22">const</FONT></B> back = sback-&gt;lnk;
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> back_max = sback-&gt;count;
  <B><FONT COLOR="#228B22">int</FONT></B> nclean = 0;
  <B><FONT COLOR="#228B22">int</FONT></B> i;

  <B><FONT COLOR="#A020F0">for</FONT></B>(i = 0; i &lt; back_max; i++) {
    <I><FONT COLOR="#B22222">// ready, not locked and suitable
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B> (slot_can_be_cached_on_disk(&amp;back[i])) {
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">HTS_NO_BACK_ON_DISK</FONT>
      lien_back *itemback;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
      <I><FONT COLOR="#B22222">/* Security check */</FONT></I>
      <B><FONT COLOR="#228B22">int</FONT></B> checkIndex =
        back_index_ready(opt, sback, back[i].url_adr, back[i].url_fil,
                         back[i].url_sav, 1);
      <B><FONT COLOR="#A020F0">if</FONT></B> (checkIndex != -1) {
        hts_log_print(opt, LOG_WARNING,
                      <B><FONT COLOR="#BC8F8F">&quot;engine: unexpected duplicate file entry: %s%s -&gt; %s (%d '%s') / %s%s -&gt; %s (%d '%s')&quot;</FONT></B>,
                      back[checkIndex].url_adr, back[checkIndex].url_fil,
                      back[checkIndex].url_sav, back[checkIndex].r.statuscode,
                      back[checkIndex].r.msg, back[i].url_adr, back[i].url_fil,
                      back[i].url_sav, back[i].r.statuscode, back[i].r.msg);
        back_delete(NULL, NULL, sback, checkIndex);
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">_DEBUG</FONT>
        <I><FONT COLOR="#B22222">/* This should NOT happend! */</FONT></I>
        {
          <B><FONT COLOR="#228B22">int</FONT></B> duplicateEntryInBacklog = 1;

          assertf(!duplicateEntryInBacklog);
        }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
      }
#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">HTS_NO_BACK_ON_DISK</FONT>
      <I><FONT COLOR="#B22222">/* temporarily serialize the entry on disk */</FONT></I>
      {
        <B><FONT COLOR="#228B22">int</FONT></B> fsz = (<B><FONT COLOR="#228B22">int</FONT></B>) strlen(back[i].url_sav);
        <B><FONT COLOR="#228B22">char</FONT></B> *filename = malloc(fsz + 8 + 1);

        <B><FONT COLOR="#A020F0">if</FONT></B> (filename != NULL) {
          FILE *fp;

          <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;getmode != 0) {
            sprintf(filename, <B><FONT COLOR="#BC8F8F">&quot;%s.tmp&quot;</FONT></B>, back[i].url_sav);
          } <B><FONT COLOR="#A020F0">else</FONT></B> {
            sprintf(filename, <B><FONT COLOR="#BC8F8F">&quot;%stmpfile%d.tmp&quot;</FONT></B>,
                    StringBuff(opt-&gt;path_html_utf8), opt-&gt;state.tmpnameid++);
          }
          <I><FONT COLOR="#B22222">/* Security check */</FONT></I>
          <B><FONT COLOR="#A020F0">if</FONT></B> (fexist_utf8(filename)) {
            hts_log_print(opt, LOG_WARNING,
                          <B><FONT COLOR="#BC8F8F">&quot;engine: warning: temporary file %s already exists&quot;</FONT></B>,
                          filename);
          }
          <I><FONT COLOR="#B22222">/* Create file and serialize slot */</FONT></I>
          <B><FONT COLOR="#A020F0">if</FONT></B> ((fp = filecreate(NULL, filename)) != NULL) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (back_serialize(fp, &amp;back[i]) == 0) {
              coucal_add_pvoid(sback-&gt;ready, back[i].url_sav, filename);
              filename = NULL;
              sback-&gt;ready_size_bytes += back[i].r.size;        <I><FONT COLOR="#B22222">/* add for stats */</FONT></I>
              nclean++;
              back_clear_entry(&amp;back[i]);       <I><FONT COLOR="#B22222">/* entry is now recycled */</FONT></I>
            } <B><FONT COLOR="#A020F0">else</FONT></B> {
              hts_log_print(opt, LOG_WARNING | LOG_ERRNO,
                            <B><FONT COLOR="#BC8F8F">&quot;engine: warning: serialize error for %s%s to %s: write error&quot;</FONT></B>,
                            back[i].url_adr, back[i].url_fil, filename);
            }
            fclose(fp);
          } <B><FONT COLOR="#A020F0">else</FONT></B> {
            hts_log_print(opt, LOG_WARNING | LOG_ERRNO,
                          <B><FONT COLOR="#BC8F8F">&quot;engine: warning: serialize error for %s%s to %s: open error (%s, %s)&quot;</FONT></B>,
                          back[i].url_adr, back[i].url_fil, filename,
                          dir_exists(filename) ? <B><FONT COLOR="#BC8F8F">&quot;directory exists&quot;</FONT></B> :
                          <B><FONT COLOR="#BC8F8F">&quot;directory does NOT exist!&quot;</FONT></B>,
                          fexist_utf8(filename) ? <B><FONT COLOR="#BC8F8F">&quot;file already exists!&quot;</FONT></B> :
                          <B><FONT COLOR="#BC8F8F">&quot;file does not exist&quot;</FONT></B>);
          }
          <B><FONT COLOR="#A020F0">if</FONT></B> (filename != NULL)
            free(filename);
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
          hts_log_print(opt, LOG_WARNING | LOG_ERRNO,
                        <B><FONT COLOR="#BC8F8F">&quot;engine: warning: serialize error for %s%s to %s: memory full&quot;</FONT></B>,
                        back[i].url_adr, back[i].url_fil, filename);
        }
      }
#<B><FONT COLOR="#5F9EA0">else</FONT></B>
      itemback = calloct(1, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(lien_back));
      back_move(&amp;back[i], itemback);
      coucal_add_pvoid(sback-&gt;ready, itemback-&gt;url_sav, itemback);
      nclean++;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    }
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> nclean;
}

<I><FONT COLOR="#B22222">// nombre d'entrées libres dans le backing
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">back_available</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> struct_back * sback) {
  <B><FONT COLOR="#228B22">const</FONT></B> lien_back *<B><FONT COLOR="#228B22">const</FONT></B> back = sback-&gt;lnk;
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> back_max = sback-&gt;count;
  <B><FONT COLOR="#228B22">int</FONT></B> i;
  <B><FONT COLOR="#228B22">int</FONT></B> nb = 0;

  <B><FONT COLOR="#A020F0">for</FONT></B>(i = 0; i &lt; back_max; i++)
    <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status == STATUS_FREE)  <I><FONT COLOR="#B22222">/* libre */</FONT></I>
      nb++;
  <B><FONT COLOR="#A020F0">return</FONT></B> nb;
}

<I><FONT COLOR="#B22222">// retourne estimation de la taille des html et fichiers stockés en mémoire
</FONT></I>LLint <B><FONT COLOR="#0000FF">back_incache</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> struct_back * sback) {
  <B><FONT COLOR="#228B22">const</FONT></B> lien_back *<B><FONT COLOR="#228B22">const</FONT></B> back = sback-&gt;lnk;
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> back_max = sback-&gt;count;
  <B><FONT COLOR="#228B22">int</FONT></B> i;
  LLint sum = 0;

  <B><FONT COLOR="#A020F0">for</FONT></B>(i = 0; i &lt; back_max; i++)
    <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status != -1)
      <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.adr)        <I><FONT COLOR="#B22222">// ne comptabilier que les blocs en mémoire
</FONT></I>        sum += max(back[i].r.size, back[i].r.totalsize);
  <I><FONT COLOR="#B22222">// stored (ready) slots
</FONT></I>#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">HTS_NO_BACK_ON_DISK</FONT>
  <B><FONT COLOR="#A020F0">if</FONT></B> (sback-&gt;ready != NULL) {
    struct_coucal_enum e = coucal_enum_new(sback-&gt;ready);
    coucal_item *item;

    <B><FONT COLOR="#A020F0">while</FONT></B>((item = coucal_enum_next(&amp;e))) {
      lien_back *ritem = (lien_back *) item-&gt;value.ptr;

      <B><FONT COLOR="#A020F0">if</FONT></B> (ritem-&gt;status != -1)
        <B><FONT COLOR="#A020F0">if</FONT></B> (ritem-&gt;r.adr)       <I><FONT COLOR="#B22222">// ne comptabilier que les blocs en mémoire
</FONT></I>          sum += max(ritem-&gt;r.size, ritem-&gt;r.totalsize);
    }
  }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
  <B><FONT COLOR="#A020F0">return</FONT></B> sum;
}

<I><FONT COLOR="#B22222">// retourne estimation de la taille des html et fichiers stockés en mémoire
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">back_done_incache</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> struct_back * sback) {
  <B><FONT COLOR="#228B22">const</FONT></B> lien_back *<B><FONT COLOR="#228B22">const</FONT></B> back = sback-&gt;lnk;
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> back_max = sback-&gt;count;
  <B><FONT COLOR="#228B22">int</FONT></B> i;
  <B><FONT COLOR="#228B22">int</FONT></B> n = 0;

  <B><FONT COLOR="#A020F0">for</FONT></B>(i = 0; i &lt; back_max; i++)
    <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status == STATUS_READY)
      n++;
  <I><FONT COLOR="#B22222">// stored (ready) slots
</FONT></I>  <B><FONT COLOR="#A020F0">if</FONT></B> (sback-&gt;ready != NULL) {
#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">HTS_NO_BACK_ON_DISK</FONT>
    n += (<B><FONT COLOR="#228B22">int</FONT></B>) coucal_nitems(sback-&gt;ready);
#<B><FONT COLOR="#5F9EA0">else</FONT></B>
    struct_coucal_enum e = coucal_enum_new(sback-&gt;ready);
    coucal_item *item;

    <B><FONT COLOR="#A020F0">while</FONT></B>((item = coucal_enum_next(&amp;e))) {
      lien_back *ritem = (lien_back *) item-&gt;value.ptr;

      <B><FONT COLOR="#A020F0">if</FONT></B> (ritem-&gt;status == STATUS_READY)
        n++;
    }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> n;
}

<I><FONT COLOR="#B22222">// le lien a-t-il été mis en backing?
</FONT></I>HTS_INLINE <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">back_exist</FONT></B>(struct_back * sback, httrackp * opt, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *adr,
                          <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *fil, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *sav) {
  <B><FONT COLOR="#A020F0">return</FONT></B> (back_index_fetch(opt, sback, adr, fil, sav, <I><FONT COLOR="#B22222">/*don't fetch */</FONT></I> 0) &gt;= 0);
}

<I><FONT COLOR="#B22222">// nombre de sockets en tâche de fond
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">back_nsoc</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> struct_back * sback) {
  <B><FONT COLOR="#228B22">const</FONT></B> lien_back *<B><FONT COLOR="#228B22">const</FONT></B> back = sback-&gt;lnk;
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> back_max = sback-&gt;count;
  <B><FONT COLOR="#228B22">int</FONT></B> n = 0;
  <B><FONT COLOR="#228B22">int</FONT></B> i;

  <B><FONT COLOR="#A020F0">for</FONT></B>(i = 0; i &lt; back_max; i++)
    <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status &gt; 0)     <I><FONT COLOR="#B22222">// only receive
</FONT></I>      n++;

  <B><FONT COLOR="#A020F0">return</FONT></B> n;
}
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">back_nsoc_overall</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> struct_back * sback) {
  <B><FONT COLOR="#228B22">const</FONT></B> lien_back *<B><FONT COLOR="#228B22">const</FONT></B> back = sback-&gt;lnk;
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> back_max = sback-&gt;count;
  <B><FONT COLOR="#228B22">int</FONT></B> n = 0;
  <B><FONT COLOR="#228B22">int</FONT></B> i;

  <B><FONT COLOR="#A020F0">for</FONT></B>(i = 0; i &lt; back_max; i++)
    <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status &gt; 0 || back[i].status == STATUS_ALIVE)
      n++;

  <B><FONT COLOR="#A020F0">return</FONT></B> n;
}

<I><FONT COLOR="#B22222">/* generate temporary file on lien_back */</FONT></I>
<I><FONT COLOR="#B22222">/* Note: utf-8 */</FONT></I>
<B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">create_back_tmpfile</FONT></B>(httrackp * opt, lien_back *<B><FONT COLOR="#228B22">const</FONT></B> back) {
  <I><FONT COLOR="#B22222">// do not use tempnam() but a regular filename
</FONT></I>  back-&gt;tmpfile_buffer[0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
  <B><FONT COLOR="#A020F0">if</FONT></B> (back-&gt;url_sav != NULL &amp;&amp; back-&gt;url_sav[0] != <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>) {
    snprintf(back-&gt;tmpfile_buffer, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(back-&gt;tmpfile_buffer), <B><FONT COLOR="#BC8F8F">&quot;%s.z&quot;</FONT></B>, 
             back-&gt;url_sav);
    back-&gt;tmpfile = back-&gt;tmpfile_buffer;
    <B><FONT COLOR="#A020F0">if</FONT></B> (structcheck(back-&gt;tmpfile) != 0) {
      hts_log_print(opt, LOG_WARNING, <B><FONT COLOR="#BC8F8F">&quot;can not create directory to %s&quot;</FONT></B>, 
                    back-&gt;tmpfile);
      <B><FONT COLOR="#A020F0">return</FONT></B> -1;
    }
  } <B><FONT COLOR="#A020F0">else</FONT></B> {
    snprintf(back-&gt;tmpfile_buffer, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(back-&gt;tmpfile_buffer),
             <B><FONT COLOR="#BC8F8F">&quot;%s/tmp%d.z&quot;</FONT></B>, StringBuff(opt-&gt;path_html_utf8),
             opt-&gt;state.tmpnameid++);
    back-&gt;tmpfile = back-&gt;tmpfile_buffer;
  }
  <I><FONT COLOR="#B22222">/* OK */</FONT></I>
  hts_log_print(opt, LOG_TRACE, <B><FONT COLOR="#BC8F8F">&quot;produced temporary name %s&quot;</FONT></B>, back-&gt;tmpfile);
  <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}

<I><FONT COLOR="#B22222">// objet (lien) téléchargé ou transféré depuis le cache
</FONT></I><I><FONT COLOR="#B22222">//
</FONT></I><I><FONT COLOR="#B22222">// fermer les paramètres de transfert,
</FONT></I><I><FONT COLOR="#B22222">// et notamment vérifier les fichiers compressés (décompresser), callback etc.
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">back_finalize</FONT></B>(httrackp * opt, cache_back * cache, struct_back * sback,
                  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> p) {
  <B><FONT COLOR="#228B22">char</FONT></B> catbuff[CATBUFF_SIZE];
  lien_back *<B><FONT COLOR="#228B22">const</FONT></B> back = sback-&gt;lnk;
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> back_max = sback-&gt;count;

  assertf(p &gt;= 0 &amp;&amp; p &lt; back_max);

  <I><FONT COLOR="#B22222">/* Store ? */</FONT></I>
  <B><FONT COLOR="#A020F0">if</FONT></B> (!back[p].finalized) {
    back[p].finalized = 1;

    <I><FONT COLOR="#B22222">/* Don't store broken files. Note: check is done before compression.
       If the file is partial, the next run will attempt to continue it with compression too.
     */</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B> (back[p].r.totalsize &gt;= 0 &amp;&amp; back[p].r.statuscode &gt; 0
        &amp;&amp; back[p].r.size != back[p].r.totalsize &amp;&amp; !opt-&gt;tolerant) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (back[p].status == STATUS_READY) {
        hts_log_print(opt, LOG_WARNING,
                      <B><FONT COLOR="#BC8F8F">&quot;file not stored in cache due to bogus state (broken size, expected &quot;</FONT></B>
                      LLintP <B><FONT COLOR="#BC8F8F">&quot; got &quot;</FONT></B> LLintP <B><FONT COLOR="#BC8F8F">&quot;): %s%s&quot;</FONT></B>, back[p].r.totalsize,
                      back[p].r.size, back[p].url_adr, back[p].url_fil);
      } <B><FONT COLOR="#A020F0">else</FONT></B> {
        hts_log_print(opt, LOG_INFO,
                      <B><FONT COLOR="#BC8F8F">&quot;incomplete file not yet stored in cache (expected &quot;</FONT></B>
                      LLintP <B><FONT COLOR="#BC8F8F">&quot; got &quot;</FONT></B> LLintP <B><FONT COLOR="#BC8F8F">&quot;): %s%s&quot;</FONT></B>, back[p].r.totalsize,
                      back[p].r.size, back[p].url_adr, back[p].url_fil);
      }
      <B><FONT COLOR="#A020F0">return</FONT></B> -1;
    }

    <B><FONT COLOR="#A020F0">if</FONT></B> ((back[p].status == STATUS_READY)        <I><FONT COLOR="#B22222">// ready
</FONT></I>        &amp;&amp; (back[p].r.statuscode &gt; 0)   <I><FONT COLOR="#B22222">// not internal error
</FONT></I>      ) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (!back[p].testmode) {  <I><FONT COLOR="#B22222">// not test mode
</FONT></I>        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *state = <B><FONT COLOR="#BC8F8F">&quot;unknown&quot;</FONT></B>;

        <I><FONT COLOR="#B22222">/* décompression */</FONT></I>
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_USEZLIB</FONT>
        <B><FONT COLOR="#A020F0">if</FONT></B> (back[p].r.compressed) {
          <B><FONT COLOR="#A020F0">if</FONT></B> (back[p].r.size &gt; 0) {
            <I><FONT COLOR="#B22222">//if ( (back[p].r.adr) &amp;&amp; (back[p].r.size&gt;0) ) {
</FONT></I>            <I><FONT COLOR="#B22222">// stats
</FONT></I>            back[p].compressed_size = back[p].r.size;
            <I><FONT COLOR="#B22222">// en mémoire -&gt; passage sur disque
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B> (!back[p].r.is_write) {
              <I><FONT COLOR="#B22222">// do not use tempnam() but a regular filename
</FONT></I>              <B><FONT COLOR="#A020F0">if</FONT></B> (create_back_tmpfile(opt, &amp;back[p]) == 0) {
                assertf(back[p].tmpfile != NULL);
                <I><FONT COLOR="#B22222">/* note: tmpfile is utf-8 */</FONT></I>
                back[p].r.out = FOPEN(back[p].tmpfile, <B><FONT COLOR="#BC8F8F">&quot;wb&quot;</FONT></B>);
                <B><FONT COLOR="#A020F0">if</FONT></B> (back[p].r.out) {
                  <B><FONT COLOR="#A020F0">if</FONT></B> ((back[p].r.adr) &amp;&amp; (back[p].r.size &gt; 0)) {
                    <B><FONT COLOR="#A020F0">if</FONT></B> (fwrite
                        (back[p].r.adr, 1, (size_t) back[p].r.size,
                         back[p].r.out) != back[p].r.size) {
                      back[p].r.statuscode = STATUSCODE_INVALID;
                      strcpybuff(back[p].r.msg,
                                 <B><FONT COLOR="#BC8F8F">&quot;Write error when decompressing&quot;</FONT></B>);
                    }
                  } <B><FONT COLOR="#A020F0">else</FONT></B> {
                    back[p].tmpfile[0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
                    back[p].r.statuscode = STATUSCODE_INVALID;
                    strcpybuff(back[p].r.msg, <B><FONT COLOR="#BC8F8F">&quot;Empty compressed file&quot;</FONT></B>);
                  }
                } <B><FONT COLOR="#A020F0">else</FONT></B> {
                  snprintf(back[p].r.msg, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(back[p].r.msg),
                           <B><FONT COLOR="#BC8F8F">&quot;Open error when decompressing (can not create temporary file %s)&quot;</FONT></B>,
                           back[p].tmpfile);
                  back[p].tmpfile[0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
                  back[p].r.statuscode = STATUSCODE_INVALID;
                }
              } <B><FONT COLOR="#A020F0">else</FONT></B> {
                snprintf(back[p].r.msg, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(back[p].r.msg),
                         <B><FONT COLOR="#BC8F8F">&quot;Open error when decompressing (can not generate a temporary file)&quot;</FONT></B>);
              }
            }
            <I><FONT COLOR="#B22222">// fermer fichier sortie
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B> (back[p].r.out != NULL) {
              fclose(back[p].r.out);
              back[p].r.out = NULL;
            }
            <I><FONT COLOR="#B22222">// décompression
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B> (back[p].tmpfile != NULL) {
              <B><FONT COLOR="#A020F0">if</FONT></B> (back[p].url_sav[0]) {
                LLint size;

                file_notify(opt, back[p].url_adr, back[p].url_fil,
                            back[p].url_sav, 1, 1, back[p].r.notmodified);
                filecreateempty(&amp;opt-&gt;state.strc, back[p].url_sav);     <I><FONT COLOR="#B22222">// filenote &amp; co
</FONT></I>                <B><FONT COLOR="#A020F0">if</FONT></B> ((size = hts_zunpack(back[p].tmpfile, back[p].url_sav)) &gt;= 0) {
                  back[p].r.size = back[p].r.totalsize = size;
                  <I><FONT COLOR="#B22222">// fichier -&gt; mémoire
</FONT></I>                  <B><FONT COLOR="#A020F0">if</FONT></B> (!back[p].r.is_write) {
                    deleteaddr(&amp;back[p].r);
                    back[p].r.adr = readfile_utf8(back[p].url_sav);
                    <B><FONT COLOR="#A020F0">if</FONT></B> (!back[p].r.adr) {
                      back[p].r.statuscode = STATUSCODE_INVALID;
                      strcpybuff(back[p].r.msg,
                                 <B><FONT COLOR="#BC8F8F">&quot;Read error when decompressing&quot;</FONT></B>);
                    }
                    UNLINK(back[p].url_sav);
                  }
                } <B><FONT COLOR="#A020F0">else</FONT></B> {
                  back[p].r.statuscode = STATUSCODE_INVALID;
                  strcpybuff(back[p].r.msg, <B><FONT COLOR="#BC8F8F">&quot;Error when decompressing&quot;</FONT></B>);
                }
              }
              <I><FONT COLOR="#B22222">/* ensure that no remaining temporary file exists */</FONT></I>
              unlink(back[p].tmpfile);
              back[p].tmpfile = NULL;
            }
            <I><FONT COLOR="#B22222">// stats
</FONT></I>            HTS_STAT.total_packed += back[p].compressed_size;
            HTS_STAT.total_unpacked += back[p].r.size;
            HTS_STAT.total_packedfiles++;
            <I><FONT COLOR="#B22222">// unflag
</FONT></I>          }
        }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
        <I><FONT COLOR="#B22222">/* Write mode to disk */</FONT></I>
        <B><FONT COLOR="#A020F0">if</FONT></B> (back[p].r.is_write &amp;&amp; back[p].r.adr != NULL) {
          freet(back[p].r.adr);
          back[p].r.adr = NULL;
        }

        <I><FONT COLOR="#B22222">/* remove reference file, if any */</FONT></I>
        <B><FONT COLOR="#A020F0">if</FONT></B> (back[p].r.is_write) {
          url_savename_refname_remove(opt, back[p].url_adr, back[p].url_fil);
        }

        <I><FONT COLOR="#B22222">/* ************************************************************************
           REAL MEDIA HACK
           Check if we have to load locally the file
           ************************************************************************ */</FONT></I>
        <B><FONT COLOR="#A020F0">if</FONT></B> (back[p].r.statuscode == HTTP_OK) {  <I><FONT COLOR="#B22222">// OK (ou 304 en backing)
</FONT></I>          <B><FONT COLOR="#A020F0">if</FONT></B> (back[p].r.is_write) {     <I><FONT COLOR="#B22222">// Written file
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B> (may_be_hypertext_mime(opt, back[p].r.contenttype, back[p].url_fil)) {   <I><FONT COLOR="#B22222">// to parse!
</FONT></I>              off_t sz;

              sz = fsize_utf8(back[p].url_sav);
              <B><FONT COLOR="#A020F0">if</FONT></B> (sz &gt; 0) {     <I><FONT COLOR="#B22222">// ok, exists!
</FONT></I>                <B><FONT COLOR="#A020F0">if</FONT></B> (sz &lt; 8192) {        <I><FONT COLOR="#B22222">// ok, small file --&gt; to parse!
</FONT></I>                  FILE *fp = FOPEN(back[p].url_sav, <B><FONT COLOR="#BC8F8F">&quot;rb&quot;</FONT></B>);

                  <B><FONT COLOR="#A020F0">if</FONT></B> (fp) {
                    back[p].r.adr = malloct((size_t) sz + 1);
                    <B><FONT COLOR="#A020F0">if</FONT></B> (back[p].r.adr) {
                      <B><FONT COLOR="#A020F0">if</FONT></B> (fread(back[p].r.adr, 1, sz, fp) == sz) {
                        back[p].r.size = sz;
                        back[p].r.adr[sz] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
                        back[p].r.is_write = 0; <I><FONT COLOR="#B22222">/* not anymore a direct-to-disk file */</FONT></I>
                      } <B><FONT COLOR="#A020F0">else</FONT></B> {
                        freet(back[p].r.adr);
                        back[p].r.size = 0;
                        back[p].r.adr = NULL;
                        back[p].r.statuscode = STATUSCODE_INVALID;
                        strcpybuff(back[p].r.msg, <B><FONT COLOR="#BC8F8F">&quot;.RAM read error&quot;</FONT></B>);
                      }
                      fclose(fp);
                      fp = NULL;
                      <I><FONT COLOR="#B22222">// remove (temporary) file!
</FONT></I>                      UNLINK(fconv(catbuff, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(catbuff), back[p].url_sav));
                    }
                    <B><FONT COLOR="#A020F0">if</FONT></B> (fp)
                      fclose(fp);
                  }
                }
              }
            }
          }
        }
        <I><FONT COLOR="#B22222">/* EN OF REAL MEDIA HACK */</FONT></I>

        <I><FONT COLOR="#B22222">/* Stats */</FONT></I>
        <B><FONT COLOR="#A020F0">if</FONT></B> (cache-&gt;txt) {
          <B><FONT COLOR="#228B22">char</FONT></B> flags[32];
          <B><FONT COLOR="#228B22">char</FONT></B> s[256];
          time_t tt;
          <B><FONT COLOR="#228B22">struct</FONT></B> tm *A;

          tt = time(NULL);
          A = localtime(&amp;tt);
          <B><FONT COLOR="#A020F0">if</FONT></B> (A == NULL) {
            <B><FONT COLOR="#228B22">int</FONT></B> localtime_returned_null = 0;

            assertf(localtime_returned_null);
          }
          strftime(s, 250, <B><FONT COLOR="#BC8F8F">&quot;%H:%M:%S&quot;</FONT></B>, A);

          flags[0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
          <I><FONT COLOR="#B22222">/* input flags */</FONT></I>
          <B><FONT COLOR="#A020F0">if</FONT></B> (back[p].is_update)
            strcatbuff(flags, <B><FONT COLOR="#BC8F8F">&quot;U&quot;</FONT></B>);     <I><FONT COLOR="#B22222">// update request
</FONT></I>          <B><FONT COLOR="#A020F0">else</FONT></B>
            strcatbuff(flags, <B><FONT COLOR="#BC8F8F">&quot;-&quot;</FONT></B>);
          <B><FONT COLOR="#A020F0">if</FONT></B> (back[p].range_req_size)
            strcatbuff(flags, <B><FONT COLOR="#BC8F8F">&quot;R&quot;</FONT></B>);     <I><FONT COLOR="#B22222">// range request
</FONT></I>          <B><FONT COLOR="#A020F0">else</FONT></B>
            strcatbuff(flags, <B><FONT COLOR="#BC8F8F">&quot;-&quot;</FONT></B>);
          <I><FONT COLOR="#B22222">/* state flags */</FONT></I>
          <B><FONT COLOR="#A020F0">if</FONT></B> (back[p].r.is_file)        <I><FONT COLOR="#B22222">// direct to disk
</FONT></I>            strcatbuff(flags, <B><FONT COLOR="#BC8F8F">&quot;F&quot;</FONT></B>);
          <B><FONT COLOR="#A020F0">else</FONT></B>
            strcatbuff(flags, <B><FONT COLOR="#BC8F8F">&quot;-&quot;</FONT></B>);
          <I><FONT COLOR="#B22222">/* output flags */</FONT></I>
          <B><FONT COLOR="#A020F0">if</FONT></B> (!back[p].r.notmodified)
            strcatbuff(flags, <B><FONT COLOR="#BC8F8F">&quot;M&quot;</FONT></B>);     <I><FONT COLOR="#B22222">// modified
</FONT></I>          <B><FONT COLOR="#A020F0">else</FONT></B>
            strcatbuff(flags, <B><FONT COLOR="#BC8F8F">&quot;-&quot;</FONT></B>);
          <B><FONT COLOR="#A020F0">if</FONT></B> (back[p].r.is_chunk)       <I><FONT COLOR="#B22222">// chunked
</FONT></I>            strcatbuff(flags, <B><FONT COLOR="#BC8F8F">&quot;C&quot;</FONT></B>);
          <B><FONT COLOR="#A020F0">else</FONT></B>
            strcatbuff(flags, <B><FONT COLOR="#BC8F8F">&quot;-&quot;</FONT></B>);
          <B><FONT COLOR="#A020F0">if</FONT></B> (back[p].r.compressed)
            strcatbuff(flags, <B><FONT COLOR="#BC8F8F">&quot;Z&quot;</FONT></B>);     <I><FONT COLOR="#B22222">// gzip
</FONT></I>          <B><FONT COLOR="#A020F0">else</FONT></B>
            strcatbuff(flags, <B><FONT COLOR="#BC8F8F">&quot;-&quot;</FONT></B>);
          <I><FONT COLOR="#B22222">/* Err I had to split these.. */</FONT></I>
          fprintf(cache-&gt;txt, <B><FONT COLOR="#BC8F8F">&quot;%s\t&quot;</FONT></B>, s);
          fprintf(cache-&gt;txt, LLintP <B><FONT COLOR="#BC8F8F">&quot;/&quot;</FONT></B>, (LLint) back[p].r.size);
          fprintf(cache-&gt;txt, LLintP, (LLint) back[p].r.totalsize);
          fprintf(cache-&gt;txt, <B><FONT COLOR="#BC8F8F">&quot;\t%s\t&quot;</FONT></B>, flags);
        }
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_USEZLIB</FONT>
        back[p].r.compressed = 0;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

        <B><FONT COLOR="#A020F0">if</FONT></B> (back[p].r.statuscode == HTTP_OK) {
          <B><FONT COLOR="#A020F0">if</FONT></B> (back[p].r.size &gt;= 0) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (strcmp(back[p].url_fil, <B><FONT COLOR="#BC8F8F">&quot;/robots.txt&quot;</FONT></B>) != 0) {
              HTS_STAT.stat_bytes += back[p].r.size;
              HTS_STAT.stat_files++;
              hts_log_print(opt, LOG_TRACE, <B><FONT COLOR="#BC8F8F">&quot;added file %s%s =&gt; %s&quot;</FONT></B>,
                            back[p].url_adr, back[p].url_fil,
                            back[p].url_sav != NULL ? back[p].url_sav : <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>);
            }
            <B><FONT COLOR="#A020F0">if</FONT></B> ((!back[p].r.notmodified) &amp;&amp; (opt-&gt;is_update)) {
              HTS_STAT.stat_updated_files++;    <I><FONT COLOR="#B22222">// page modifiée
</FONT></I>              <B><FONT COLOR="#A020F0">if</FONT></B> (back[p].is_update) {
                hts_log_print(opt, LOG_INFO,
                              <B><FONT COLOR="#BC8F8F">&quot;engine: transfer-status: link updated: %s%s -&gt; %s&quot;</FONT></B>,
                              back[p].url_adr, back[p].url_fil,
                              back[p].url_sav);
              } <B><FONT COLOR="#A020F0">else</FONT></B> {
                hts_log_print(opt, LOG_INFO,
                              <B><FONT COLOR="#BC8F8F">&quot;engine: transfer-status: link added: %s%s -&gt; %s&quot;</FONT></B>,
                              back[p].url_adr, back[p].url_fil,
                              back[p].url_sav);
              }
              <B><FONT COLOR="#A020F0">if</FONT></B> (cache-&gt;txt) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (back[p].is_update) {
                  state = <B><FONT COLOR="#BC8F8F">&quot;updated&quot;</FONT></B>;
                } <B><FONT COLOR="#A020F0">else</FONT></B> {
                  state = <B><FONT COLOR="#BC8F8F">&quot;added&quot;</FONT></B>;
                }
              }
            } <B><FONT COLOR="#A020F0">else</FONT></B> {
              hts_log_print(opt, LOG_INFO,
                            <B><FONT COLOR="#BC8F8F">&quot;engine: transfer-status: link recorded: %s%s -&gt; %s&quot;</FONT></B>,
                            back[p].url_adr, back[p].url_fil, back[p].url_sav);
              <B><FONT COLOR="#A020F0">if</FONT></B> (cache-&gt;txt) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;is_update)
                  state = <B><FONT COLOR="#BC8F8F">&quot;untouched&quot;</FONT></B>;
                <B><FONT COLOR="#A020F0">else</FONT></B>
                  state = <B><FONT COLOR="#BC8F8F">&quot;added&quot;</FONT></B>;
              }
            }
          } <B><FONT COLOR="#A020F0">else</FONT></B> {
            hts_log_print(opt, LOG_INFO,
                          <B><FONT COLOR="#BC8F8F">&quot;engine: transfer-status: empty file? (%d, '%s'): %s%s&quot;</FONT></B>,
                          back[p].r.statuscode, back[p].r.msg, back[p].url_adr,
                          back[p].url_fil);
            <B><FONT COLOR="#A020F0">if</FONT></B> (cache-&gt;txt) {
              state = <B><FONT COLOR="#BC8F8F">&quot;empty&quot;</FONT></B>;
            }
          }
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
          hts_log_print(opt, LOG_INFO,
                        <B><FONT COLOR="#BC8F8F">&quot;engine: transfer-status: link error (%d, '%s'): %s%s&quot;</FONT></B>,
                        back[p].r.statuscode, back[p].r.msg, back[p].url_adr,
                        back[p].url_fil);
          <B><FONT COLOR="#A020F0">if</FONT></B> (cache-&gt;txt) {
            state = <B><FONT COLOR="#BC8F8F">&quot;error&quot;</FONT></B>;
          }
        }
        <B><FONT COLOR="#A020F0">if</FONT></B> (cache-&gt;txt) {
#<B><FONT COLOR="#5F9EA0">undef</FONT></B> <FONT COLOR="#B8860B">ESC_URL</FONT>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">ESC_URL</FONT></B>(S) escape_check_url_addr(S, OPT_GET_BUFF(opt), OPT_GET_BUFF_SIZE(opt))
          fprintf(cache-&gt;txt,
                  <B><FONT COLOR="#BC8F8F">&quot;%d\t&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;%s ('%s')\t&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;%s\t&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;%s%s\t&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;%s%s%s\t%s\t&quot;</FONT></B>
                  <B><FONT COLOR="#BC8F8F">&quot;(from %s%s%s)&quot;</FONT></B> LF, back[p].r.statuscode, state,
                  ESC_URL(back[p].r.msg),
                  ESC_URL(back[p].r.contenttype),
                  ((back[p].r.etag[0]) ? <B><FONT COLOR="#BC8F8F">&quot;etag:&quot;</FONT></B> : ((back[p].r.
                                           lastmodified[0]) ? <B><FONT COLOR="#BC8F8F">&quot;date:&quot;</FONT></B> : <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>)),
                  ESC_URL((back[p].r.etag[0]) ? back[p].r.
                                        etag : (back[p].r.lastmodified)),
                  (link_has_authority(back[p].url_adr) ? <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B> : <B><FONT COLOR="#BC8F8F">&quot;http://&quot;</FONT></B>),
                  ESC_URL(back[p].url_adr),
                  ESC_URL(back[p].url_fil),
                  ESC_URL(back[p].url_sav),
                  (link_has_authority(back[p].referer_adr)
                   || !back[p].referer_adr[0]) ? <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B> : <B><FONT COLOR="#BC8F8F">&quot;http://&quot;</FONT></B>,
                  ESC_URL(back[p].referer_adr),
                  ESC_URL(back[p].referer_fil)
            );
#<B><FONT COLOR="#5F9EA0">undef</FONT></B> <FONT COLOR="#B8860B">ESC_URL</FONT>
          <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;flush)
            fflush(cache-&gt;txt);
        }

        <I><FONT COLOR="#B22222">/* Cache */</FONT></I>
        <B><FONT COLOR="#A020F0">if</FONT></B> (!IS_DELAYED_EXT(back[p].url_sav)) {
          cache_mayadd(opt, cache, &amp;back[p].r, back[p].url_adr, back[p].url_fil,
                       back[p].url_sav);
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
          <I><FONT COLOR="#B22222">/* error */</FONT></I>
          <B><FONT COLOR="#A020F0">if</FONT></B> (!HTTP_IS_OK(back[p].r.statuscode)) {
            hts_log_print(opt, LOG_DEBUG, <B><FONT COLOR="#BC8F8F">&quot;redirect to %s%s&quot;</FONT></B>, back[p].url_adr,
                          back[p].url_fil);
            <I><FONT COLOR="#B22222">/* Store only header reference */</FONT></I>
            cache_mayadd(opt, cache, &amp;back[p].r, back[p].url_adr,
                         back[p].url_fil, NULL);
          } <B><FONT COLOR="#A020F0">else</FONT></B> {
            <I><FONT COLOR="#B22222">/* Partial file, but marked as &quot;ok&quot; ? */</FONT></I>
            hts_log_print(opt, LOG_WARNING,
                          <B><FONT COLOR="#BC8F8F">&quot;file not stored in cache due to bogus state (incomplete type with %s (%d), size &quot;</FONT></B>
                          LLintP <B><FONT COLOR="#BC8F8F">&quot;): %s%s&quot;</FONT></B>, back[p].r.msg, back[p].r.statuscode,
                          (LLint) back[p].r.size, back[p].url_adr,
                          back[p].url_fil);
          }
        }

        <I><FONT COLOR="#B22222">// status finished callback
</FONT></I>        RUN_CALLBACK1(opt, xfrstatus, &amp;back[p]);

        <B><FONT COLOR="#A020F0">return</FONT></B> 0;
      } <B><FONT COLOR="#A020F0">else</FONT></B> {                  <I><FONT COLOR="#B22222">// testmode
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (back[p].r.statuscode / 100 &gt;= 3) {  <I><FONT COLOR="#B22222">/* Store 3XX, 4XX, 5XX test response codes, but NOT 2XX */</FONT></I>
          <I><FONT COLOR="#B22222">/* Cache */</FONT></I>
          cache_mayadd(opt, cache, &amp;back[p].r, back[p].url_adr, back[p].url_fil,
                       NULL);
        }
      }
    }
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> -1;
}

<I><FONT COLOR="#B22222">/* try to keep the connection alive */</FONT></I>
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">back_letlive</FONT></B>(httrackp * opt, cache_back * cache, struct_back * sback,
                 <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> p) {
  lien_back *<B><FONT COLOR="#228B22">const</FONT></B> back = sback-&gt;lnk;
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> back_max = sback-&gt;count;
  <B><FONT COLOR="#228B22">int</FONT></B> checkerror;
  htsblk *src = &amp;back[p].r;

  assertf(p &gt;= 0 &amp;&amp; p &lt; back_max);
  <B><FONT COLOR="#A020F0">if</FONT></B> (src &amp;&amp; !src-&gt;is_file &amp;&amp; src-&gt;soc != INVALID_SOCKET &amp;&amp; src-&gt;statuscode &gt;= 0        <I><FONT COLOR="#B22222">/* no timeout errors &amp; co */</FONT></I>
      &amp;&amp; src-&gt;keep_alive_trailers == 0  <I><FONT COLOR="#B22222">/* not yet supported (chunk trailers) */</FONT></I>
      &amp;&amp; !(checkerror = check_sockerror(src-&gt;soc))
      <I><FONT COLOR="#B22222">/*&amp;&amp; !check_sockdata(src-&gt;soc) */</FONT></I><I><FONT COLOR="#B22222">/* no unexpected data */</FONT></I>
    ) {
    htsblk tmp;

    memset(&amp;tmp, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(tmp));
    <I><FONT COLOR="#B22222">/* clear everything but connection: switch, close, and reswitch */</FONT></I>
    back_connxfr(src, &amp;tmp);
    back_delete(opt, cache, sback, p);
    <I><FONT COLOR="#B22222">//deletehttp(src);
</FONT></I>    back_connxfr(&amp;tmp, src);
    src-&gt;req.flush_garbage = 1; <I><FONT COLOR="#B22222">/* ignore CRLF garbage */</FONT></I>
    <B><FONT COLOR="#A020F0">return</FONT></B> 1;
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">back_connxfr</FONT></B>(htsblk * src, htsblk * dst) {
  dst-&gt;soc = src-&gt;soc;
  src-&gt;soc = INVALID_SOCKET;
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_USEOPENSSL</FONT>
  dst-&gt;ssl = src-&gt;ssl;
  src-&gt;ssl = 0;
  dst-&gt;ssl_con = src-&gt;ssl_con;
  src-&gt;ssl_con = NULL;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
  dst-&gt;keep_alive = src-&gt;keep_alive;
  src-&gt;keep_alive = 0;
  dst-&gt;keep_alive_max = src-&gt;keep_alive_max;
  src-&gt;keep_alive_max = 0;
  dst-&gt;keep_alive_t = src-&gt;keep_alive_t;
  src-&gt;keep_alive_t = 0;
  dst-&gt;debugid = src-&gt;debugid;
  src-&gt;debugid = 0;
}

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">back_move</FONT></B>(lien_back * src, lien_back * dst) {
  memcpy(dst, src, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(lien_back));
  memset(src, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(lien_back));
  src-&gt;r.soc = INVALID_SOCKET;
  src-&gt;status = STATUS_FREE;
  src-&gt;r.location = src-&gt;location_buffer;
  dst-&gt;r.location = dst-&gt;location_buffer;
}

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">back_copy_static</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> lien_back * src, lien_back * dst) {
  memcpy(dst, src, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(lien_back));
  dst-&gt;r.soc = INVALID_SOCKET;
  dst-&gt;r.adr = NULL;
  dst-&gt;r.headers = NULL;
  dst-&gt;r.out = NULL;
  dst-&gt;r.location = dst-&gt;location_buffer;
  dst-&gt;r.fp = NULL;
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_USEOPENSSL</FONT>
  dst-&gt;r.ssl_con = NULL;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
}

<B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">back_data_serialize</FONT></B>(FILE * fp, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> *data, size_t size) {
  <B><FONT COLOR="#A020F0">if</FONT></B> (fwrite(&amp;size, 1, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(size), fp) == <B><FONT COLOR="#A020F0">sizeof</FONT></B>(size)
      &amp;&amp; (size == 0 || fwrite(data, 1, size, fp) == size)
    )
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
  <B><FONT COLOR="#A020F0">return</FONT></B> 1;                     <I><FONT COLOR="#B22222">/* error */</FONT></I>
}

<B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">back_string_serialize</FONT></B>(FILE * fp, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *str) {
  size_t size = (str != NULL) ? (strlen(str) + 1) : 0;

  <B><FONT COLOR="#A020F0">return</FONT></B> back_data_serialize(fp, str, size);
}

<B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">back_data_unserialize</FONT></B>(FILE * fp, <B><FONT COLOR="#228B22">void</FONT></B> **str, size_t * size) {
  *str = NULL;
  <B><FONT COLOR="#A020F0">if</FONT></B> (fread(size, 1, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(*size), fp) == <B><FONT COLOR="#A020F0">sizeof</FONT></B>(*size)) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (*size == 0)             <I><FONT COLOR="#B22222">/* serialized NULL ptr */</FONT></I>
      <B><FONT COLOR="#A020F0">return</FONT></B> 0;
    *str = malloct(*size + 1);
    <B><FONT COLOR="#A020F0">if</FONT></B> (*str == NULL)
      <B><FONT COLOR="#A020F0">return</FONT></B> 1;                 <I><FONT COLOR="#B22222">/* error */</FONT></I>
    ((<B><FONT COLOR="#228B22">char</FONT></B> *) *str)[*size] = 0; <I><FONT COLOR="#B22222">/* guard byte */</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B> (fread(*str, 1, *size, fp) == *size)
      <B><FONT COLOR="#A020F0">return</FONT></B> 0;
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> 1;                     <I><FONT COLOR="#B22222">/* error */</FONT></I>
}

<B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">back_string_unserialize</FONT></B>(FILE * fp, <B><FONT COLOR="#228B22">char</FONT></B> **str) {
  size_t dummy;

  <B><FONT COLOR="#A020F0">return</FONT></B> back_data_unserialize(fp, (<B><FONT COLOR="#228B22">void</FONT></B> **) str, &amp;dummy);
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">back_serialize</FONT></B>(FILE * fp, <B><FONT COLOR="#228B22">const</FONT></B> lien_back * src) {
  <B><FONT COLOR="#A020F0">if</FONT></B> (back_data_serialize(fp, src, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(lien_back)) == 0
      &amp;&amp; back_data_serialize(fp, src-&gt;r.adr,
                             src-&gt;r.adr ? (size_t) src-&gt;r.size : 0) == 0
      &amp;&amp; back_string_serialize(fp, src-&gt;r.headers) == 0 &amp;&amp; fflush(fp) == 0)
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
  <B><FONT COLOR="#A020F0">return</FONT></B> 1;
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">back_unserialize</FONT></B>(FILE * fp, lien_back ** dst) {
  size_t size;

  *dst = NULL;
  errno = 0;
  <B><FONT COLOR="#A020F0">if</FONT></B> (back_data_unserialize(fp, (<B><FONT COLOR="#228B22">void</FONT></B> **) dst, &amp;size) == 0
      &amp;&amp; size == <B><FONT COLOR="#A020F0">sizeof</FONT></B>(lien_back)) {
    (*dst)-&gt;tmpfile = NULL;
    (*dst)-&gt;chunk_adr = NULL;
    (*dst)-&gt;r.adr = NULL;
    (*dst)-&gt;r.out = NULL;
    (*dst)-&gt;r.location = (*dst)-&gt;location_buffer;
    (*dst)-&gt;r.fp = NULL;
    (*dst)-&gt;r.soc = INVALID_SOCKET;
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_USEOPENSSL</FONT>
    (*dst)-&gt;r.ssl_con = NULL;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    <B><FONT COLOR="#A020F0">if</FONT></B> (back_data_unserialize(fp, (<B><FONT COLOR="#228B22">void</FONT></B> **) &amp;(*dst)-&gt;r.adr, &amp;size) == 0) {
      (*dst)-&gt;r.size = size;
      (*dst)-&gt;r.headers = NULL;
      <B><FONT COLOR="#A020F0">if</FONT></B> (back_string_unserialize(fp, &amp;(*dst)-&gt;r.headers) == 0)
        <B><FONT COLOR="#A020F0">return</FONT></B> 0;               <I><FONT COLOR="#B22222">/* ok */</FONT></I>
      <B><FONT COLOR="#A020F0">if</FONT></B> ((*dst)-&gt;r.headers != NULL)
        freet((*dst)-&gt;r.headers);
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> ((*dst)-&gt;r.adr != NULL)
      freet((*dst)-&gt;r.adr);
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (dst != NULL) {
    freet(*dst);
    *dst = NULL;
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> 1;                     <I><FONT COLOR="#B22222">/* error */</FONT></I>
}

<I><FONT COLOR="#B22222">/* serialize a reference ; used to store references of files being downloaded in case of broken download */</FONT></I>
<I><FONT COLOR="#B22222">/* Note: NOT utf-8 */</FONT></I>
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">back_serialize_ref</FONT></B>(httrackp * opt, <B><FONT COLOR="#228B22">const</FONT></B> lien_back * src) {
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *filename =
    url_savename_refname_fullpath(opt, src-&gt;url_adr, src-&gt;url_fil);
  FILE *fp = fopen(filename, <B><FONT COLOR="#BC8F8F">&quot;wb&quot;</FONT></B>);

  <B><FONT COLOR="#A020F0">if</FONT></B> (fp == NULL) {
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">_WIN32</FONT>
    <B><FONT COLOR="#A020F0">if</FONT></B> (mkdir
        (fconcat(OPT_GET_BUFF(opt), OPT_GET_BUFF_SIZE(opt), StringBuff(opt-&gt;path_log), CACHE_REFNAME))
        == 0)
#<B><FONT COLOR="#5F9EA0">else</FONT></B>
    <B><FONT COLOR="#A020F0">if</FONT></B> (mkdir
        (fconcat(OPT_GET_BUFF(opt), OPT_GET_BUFF_SIZE(opt), StringBuff(opt-&gt;path_log), CACHE_REFNAME),
         S_IRWXU | S_IRWXG | S_IRWXO) == 0)
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    {
      <I><FONT COLOR="#B22222">/* note: local filename */</FONT></I>
      filename = url_savename_refname_fullpath(opt, src-&gt;url_adr, src-&gt;url_fil);
      fp = fopen(filename, <B><FONT COLOR="#BC8F8F">&quot;wb&quot;</FONT></B>);
    }
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (fp != NULL) {
    <B><FONT COLOR="#228B22">int</FONT></B> ser = back_serialize(fp, src);

    fclose(fp);
    <B><FONT COLOR="#A020F0">return</FONT></B> ser;
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> 1;
}

<I><FONT COLOR="#B22222">/* unserialize a reference ; used to store references of files being downloaded in case of broken download */</FONT></I>
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">back_unserialize_ref</FONT></B>(httrackp * opt, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *adr, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *fil,
                         lien_back ** dst) {
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *filename = url_savename_refname_fullpath(opt, adr, fil);
  FILE *fp = FOPEN(filename, <B><FONT COLOR="#BC8F8F">&quot;rb&quot;</FONT></B>);

  <B><FONT COLOR="#A020F0">if</FONT></B> (fp != NULL) {
    <B><FONT COLOR="#228B22">int</FONT></B> ser = back_unserialize(fp, dst);

    fclose(fp);
    <B><FONT COLOR="#A020F0">if</FONT></B> (ser != 0) {             <I><FONT COLOR="#B22222">/* back_unserialize_ref() != 0 does not need cleaning up */</FONT></I>
      back_clear_entry(*dst);   <I><FONT COLOR="#B22222">/* delete entry content */</FONT></I>
      freet(*dst);              <I><FONT COLOR="#B22222">/* delete item */</FONT></I>
      *dst = NULL;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> ser;
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> 1;
}

<I><FONT COLOR="#B22222">// clear, or leave for keep-alive
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">back_maydelete</FONT></B>(httrackp * opt, cache_back * cache, struct_back * sback,
                   <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> p) {
  lien_back *<B><FONT COLOR="#228B22">const</FONT></B> back = sback-&gt;lnk;
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> back_max = sback-&gt;count;

  assertf(p &gt;= 0 &amp;&amp; p &lt; back_max);
  <B><FONT COLOR="#A020F0">if</FONT></B> (p &gt;= 0 &amp;&amp; p &lt; back_max) { <I><FONT COLOR="#B22222">// on sait jamais..
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B> (
         <I><FONT COLOR="#B22222">/* Keep-alive authorized by user */</FONT></I>
         !opt-&gt;nokeepalive
         <I><FONT COLOR="#B22222">/* Socket currently is keep-alive! */</FONT></I>
         &amp;&amp; back[p].r.keep_alive
         <I><FONT COLOR="#B22222">/* Remaining authorized requests */</FONT></I>
         &amp;&amp; back[p].r.keep_alive_max &gt; 1
         <I><FONT COLOR="#B22222">/* Known keep-alive start (security) */</FONT></I>
         &amp;&amp; back[p].ka_time_start
         <I><FONT COLOR="#B22222">/* We're on time */</FONT></I>
         &amp;&amp; time_local() &lt; back[p].ka_time_start + back[p].r.keep_alive_t
         <I><FONT COLOR="#B22222">/* Connection delay must not exceed keep-alive timeout */</FONT></I>
         &amp;&amp; (opt-&gt;maxconn &lt;= 0
             || (back[p].r.keep_alive_t &gt; (1.0 / opt-&gt;maxconn)))
      ) {
      lien_back tmp;

      strcpybuff(tmp.url_adr, back[p].url_adr);
      tmp.ka_time_start = back[p].ka_time_start;
      <B><FONT COLOR="#A020F0">if</FONT></B> (back_letlive(opt, cache, sback, p)) {
        strcpybuff(back[p].url_adr, tmp.url_adr);
        back[p].ka_time_start = tmp.ka_time_start;
        back[p].status = STATUS_ALIVE;  <I><FONT COLOR="#B22222">// alive &amp; waiting
</FONT></I>        assertf(back[p].ka_time_start != 0);
        hts_log_print(opt, LOG_DEBUG,
                      <B><FONT COLOR="#BC8F8F">&quot;(Keep-Alive): successfully saved #%d (%s)&quot;</FONT></B>,
                      back[p].r.debugid, back[p].url_adr);
        <B><FONT COLOR="#A020F0">return</FONT></B> 1;
      }
    }
    back_delete(opt, cache, sback, p);
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}

<I><FONT COLOR="#B22222">// clear, or leave for keep-alive
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">back_maydeletehttp</FONT></B>(httrackp * opt, cache_back * cache, struct_back * sback,
                        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> p) {
  lien_back *<B><FONT COLOR="#228B22">const</FONT></B> back = sback-&gt;lnk;
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> back_max = sback-&gt;count;
  TStamp lt = 0;

  assertf(p &gt;= 0 &amp;&amp; p &lt; back_max);
  <B><FONT COLOR="#A020F0">if</FONT></B> (back[p].r.soc != INVALID_SOCKET) {
    <B><FONT COLOR="#228B22">int</FONT></B> q;

    <B><FONT COLOR="#A020F0">if</FONT></B> (back[p].r.soc != INVALID_SOCKET <I><FONT COLOR="#B22222">/* security check */</FONT></I>
        &amp;&amp; back[p].r.statuscode &gt;= 0    <I><FONT COLOR="#B22222">/* no timeout errors &amp; co */</FONT></I>
        &amp;&amp; back[p].r.keep_alive_trailers == 0   <I><FONT COLOR="#B22222">/* not yet supported (chunk trailers) */</FONT></I>
        <I><FONT COLOR="#B22222">/* Socket not in I/O error status */</FONT></I>
        &amp;&amp; !back[p].r.is_file &amp;&amp; !check_sockerror(back[p].r.soc)
        <I><FONT COLOR="#B22222">/* Keep-alive authorized by user */</FONT></I>
        &amp;&amp; !opt-&gt;nokeepalive
        <I><FONT COLOR="#B22222">/* Socket currently is keep-alive! */</FONT></I>
        &amp;&amp; back[p].r.keep_alive
        <I><FONT COLOR="#B22222">/* Remaining authorized requests */</FONT></I>
        &amp;&amp; back[p].r.keep_alive_max &gt; 1
        <I><FONT COLOR="#B22222">/* Known keep-alive start (security) */</FONT></I>
        &amp;&amp; back[p].ka_time_start
        <I><FONT COLOR="#B22222">/* We're on time */</FONT></I>
        &amp;&amp; (lt = time_local()) &lt; back[p].ka_time_start + back[p].r.keep_alive_t
        <I><FONT COLOR="#B22222">/* Connection delay must not exceed keep-alive timeout */</FONT></I>
        &amp;&amp; (opt-&gt;maxconn &lt;= 0
            || (back[p].r.keep_alive_t &gt; (1.0 / opt-&gt;maxconn)))
        <I><FONT COLOR="#B22222">/* Available slot in backing */</FONT></I>
        &amp;&amp; (q = back_search(opt, sback)) &gt;= 0) {
      lien_back tmp;

      strcpybuff(tmp.url_adr, back[p].url_adr);
      tmp.ka_time_start = back[p].ka_time_start;
      deletehttp(&amp;back[q].r);   <I><FONT COLOR="#B22222">// security check
</FONT></I>      back_connxfr(&amp;back[p].r, &amp;back[q].r);     <I><FONT COLOR="#B22222">// transfer live connection settings from p to q
</FONT></I>      back[q].ka_time_start = back[p].ka_time_start;    <I><FONT COLOR="#B22222">// refresh
</FONT></I>      back[p].r.soc = INVALID_SOCKET;
      strcpybuff(back[q].url_adr, tmp.url_adr); <I><FONT COLOR="#B22222">// address
</FONT></I>      back[q].ka_time_start = tmp.ka_time_start;
      back[q].status = STATUS_ALIVE;    <I><FONT COLOR="#B22222">// alive &amp; waiting
</FONT></I>      assertf(back[q].ka_time_start != 0);
      hts_log_print(opt, LOG_DEBUG,
                    <B><FONT COLOR="#BC8F8F">&quot;(Keep-Alive): successfully preserved #%d (%s)&quot;</FONT></B>,
                    back[q].r.debugid, back[q].url_adr);
    } <B><FONT COLOR="#A020F0">else</FONT></B> {
      deletehttp(&amp;back[p].r);
      back[p].r.soc = INVALID_SOCKET;
    }
  }
}

<I><FONT COLOR="#B22222">/* attempt to attach a live connection to this slot */</FONT></I>
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">back_trylive</FONT></B>(httrackp * opt, cache_back * cache, struct_back * sback,
                 <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> p) {
  lien_back *<B><FONT COLOR="#228B22">const</FONT></B> back = sback-&gt;lnk;
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> back_max = sback-&gt;count;

  assertf(p &gt;= 0 &amp;&amp; p &lt; back_max);
  <B><FONT COLOR="#A020F0">if</FONT></B> (p &gt;= 0 &amp;&amp; back[p].status != STATUS_ALIVE) {       <I><FONT COLOR="#B22222">// we never know..
</FONT></I>    <B><FONT COLOR="#228B22">int</FONT></B> i = back_searchlive(opt, sback, back[p].url_adr);       <I><FONT COLOR="#B22222">// search slot
</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B> (i &gt;= 0 &amp;&amp; i != p) {
      deletehttp(&amp;back[p].r);   <I><FONT COLOR="#B22222">// security check
</FONT></I>      back_connxfr(&amp;back[i].r, &amp;back[p].r);     <I><FONT COLOR="#B22222">// transfer live connection settings from i to p
</FONT></I>      back[p].ka_time_start = back[i].ka_time_start;
      back_delete(opt, cache, sback, i);        <I><FONT COLOR="#B22222">// delete old slot
</FONT></I>      back[p].status = STATUS_CONNECTING;       <I><FONT COLOR="#B22222">// ready to connect
</FONT></I>      <B><FONT COLOR="#A020F0">return</FONT></B> 1;                 <I><FONT COLOR="#B22222">// success: will reuse live connection
</FONT></I>    }
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}

<I><FONT COLOR="#B22222">/* search for a live position, or, if not possible, try to return a new one */</FONT></I>
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">back_searchlive</FONT></B>(httrackp * opt, struct_back * sback, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *search_addr) {
  lien_back *<B><FONT COLOR="#228B22">const</FONT></B> back = sback-&gt;lnk;
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> back_max = sback-&gt;count;
  <B><FONT COLOR="#228B22">int</FONT></B> i;

  <I><FONT COLOR="#B22222">/* search for a live socket */</FONT></I>
  <B><FONT COLOR="#A020F0">for</FONT></B>(i = 0; i &lt; back_max; i++) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status == STATUS_ALIVE) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (strfield2(back[i].url_adr, search_addr)) {    <I><FONT COLOR="#B22222">/* same location (xxc: check also virtual hosts?) */</FONT></I>
        <B><FONT COLOR="#A020F0">if</FONT></B> (time_local() &lt; back[i].ka_time_start + back[i].r.keep_alive_t) {
          <B><FONT COLOR="#A020F0">return</FONT></B> i;
        }
      }
    }
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> -1;
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">back_search_quick</FONT></B>(struct_back * sback) {
  lien_back *<B><FONT COLOR="#228B22">const</FONT></B> back = sback-&gt;lnk;
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> back_max = sback-&gt;count;
  <B><FONT COLOR="#228B22">int</FONT></B> i;

  <I><FONT COLOR="#B22222">/* try to find an empty place */</FONT></I>
  <B><FONT COLOR="#A020F0">for</FONT></B>(i = 0; i &lt; back_max; i++) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status == STATUS_FREE) {
      <B><FONT COLOR="#A020F0">return</FONT></B> i;
    }
  }

  <I><FONT COLOR="#B22222">/* oops, can't find a place */</FONT></I>
  <B><FONT COLOR="#A020F0">return</FONT></B> -1;
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">back_search</FONT></B>(httrackp * opt, struct_back * sback) {
  lien_back *<B><FONT COLOR="#228B22">const</FONT></B> back = sback-&gt;lnk;
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> back_max = sback-&gt;count;
  <B><FONT COLOR="#228B22">int</FONT></B> i;

  <I><FONT COLOR="#B22222">/* try to find an empty place */</FONT></I>
  <B><FONT COLOR="#A020F0">if</FONT></B> ((i = back_search_quick(sback)) != -1)
    <B><FONT COLOR="#A020F0">return</FONT></B> i;

  <I><FONT COLOR="#B22222">/* couldn't find an empty place, try to requisition a keep-alive place */</FONT></I>
  <B><FONT COLOR="#A020F0">for</FONT></B>(i = 0; i &lt; back_max; i++) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status == STATUS_ALIVE) {
      lien_back *<B><FONT COLOR="#228B22">const</FONT></B> back = sback-&gt;lnk;

      <I><FONT COLOR="#B22222">/* close this place */</FONT></I>
      back_clear_entry(&amp;back[i]);       <I><FONT COLOR="#B22222">/* Already finalized (this is the night of the living dead) */</FONT></I>
      <I><FONT COLOR="#B22222">/*back_delete(opt,cache,sback, i); */</FONT></I>
      <B><FONT COLOR="#A020F0">return</FONT></B> i;
    }
  }

  <I><FONT COLOR="#B22222">/* oops, can't find a place */</FONT></I>
  <B><FONT COLOR="#A020F0">return</FONT></B> -1;
}

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">back_set_finished</FONT></B>(struct_back * sback, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> p) {
  lien_back *<B><FONT COLOR="#228B22">const</FONT></B> back = sback-&gt;lnk;
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> back_max = sback-&gt;count;

  assertf(p &gt;= 0 &amp;&amp; p &lt; back_max);
  <B><FONT COLOR="#A020F0">if</FONT></B> (p &gt;= 0 &amp;&amp; p &lt; sback-&gt;count) {     <I><FONT COLOR="#B22222">// we never know..
</FONT></I>    <I><FONT COLOR="#B22222">/* status: finished (waiting to be validated) */</FONT></I>
    back[p].status = STATUS_READY;      <I><FONT COLOR="#B22222">/* finished */</FONT></I>
    <I><FONT COLOR="#B22222">/* close open r/w streams, if any */</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B> (back[p].r.fp != NULL) {
      fclose(back[p].r.fp);
      back[p].r.fp = NULL;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (back[p].r.out != NULL) {        <I><FONT COLOR="#B22222">// fermer fichier sortie
</FONT></I>      fclose(back[p].r.out);
      back[p].r.out = NULL;
    }
  }
}

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">back_set_locked</FONT></B>(struct_back * sback, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> p) {
  lien_back *<B><FONT COLOR="#228B22">const</FONT></B> back = sback-&gt;lnk;
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> back_max = sback-&gt;count;

  assertf(p &gt;= 0 &amp;&amp; p &lt; back_max);
  <B><FONT COLOR="#A020F0">if</FONT></B> (p &gt;= 0 &amp;&amp; p &lt; sback-&gt;count) {
    <I><FONT COLOR="#B22222">/* status: locked (in process, do not swap on disk) */</FONT></I>
    back[p].locked = 1;         <I><FONT COLOR="#B22222">/* locked */</FONT></I>
  }
}

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">back_set_unlocked</FONT></B>(struct_back * sback, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> p) {
  lien_back *<B><FONT COLOR="#228B22">const</FONT></B> back = sback-&gt;lnk;
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> back_max = sback-&gt;count;

  assertf(p &gt;= 0 &amp;&amp; p &lt; back_max);
  <B><FONT COLOR="#A020F0">if</FONT></B> (p &gt;= 0 &amp;&amp; p &lt; sback-&gt;count) {
    <I><FONT COLOR="#B22222">/* status: unlocked (can be swapped on disk) */</FONT></I>
    back[p].locked = 0;         <I><FONT COLOR="#B22222">/* unlocked */</FONT></I>
  }
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">back_flush_output</FONT></B>(httrackp * opt, cache_back * cache, struct_back * sback,
                      <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> p) {
  lien_back *<B><FONT COLOR="#228B22">const</FONT></B> back = sback-&gt;lnk;
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> back_max = sback-&gt;count;

  assertf(p &gt;= 0 &amp;&amp; p &lt; back_max);
  <B><FONT COLOR="#A020F0">if</FONT></B> (p &gt;= 0 &amp;&amp; p &lt; sback-&gt;count) {     <I><FONT COLOR="#B22222">// on sait jamais..
</FONT></I>    <I><FONT COLOR="#B22222">/* close input file */</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B> (back[p].r.fp != NULL) {
      fclose(back[p].r.fp);
      back[p].r.fp = NULL;
    }
    <I><FONT COLOR="#B22222">/* fichier de sortie */</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B> (back[p].r.out != NULL) {        <I><FONT COLOR="#B22222">// fermer fichier sortie
</FONT></I>      fclose(back[p].r.out);
      back[p].r.out = NULL;
    }
    <I><FONT COLOR="#B22222">/* set file time */</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B> (back[p].r.is_write) {   <I><FONT COLOR="#B22222">// ecriture directe
</FONT></I>      <I><FONT COLOR="#B22222">/* écrire date &quot;remote&quot; */</FONT></I>
      <B><FONT COLOR="#A020F0">if</FONT></B> (strnotempty(back[p].url_sav)
          &amp;&amp; strnotempty(back[p].r.lastmodified)
          &amp;&amp; fexist_utf8(back[p].url_sav))      <I><FONT COLOR="#B22222">// normalement existe si on a un fichier de sortie
</FONT></I>      {
        set_filetime_rfc822(back[p].url_sav, back[p].r.lastmodified);
      }
      <I><FONT COLOR="#B22222">/* executer commande utilisateur après chargement du fichier */</FONT></I>
      <I><FONT COLOR="#B22222">//xx usercommand(opt,0,NULL,back[p].url_sav, back[p].url_adr, back[p].url_fil);
</FONT></I>      back[p].r.is_write = 0;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> 1;
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}

<I><FONT COLOR="#B22222">// effacer entrée
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">back_delete</FONT></B>(httrackp * opt, cache_back * cache, struct_back * sback,
                <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> p) {
  lien_back *<B><FONT COLOR="#228B22">const</FONT></B> back = sback-&gt;lnk;
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> back_max = sback-&gt;count;

  assertf(p &gt;= 0 &amp;&amp; p &lt; back_max);
  <B><FONT COLOR="#A020F0">if</FONT></B> (p &gt;= 0 &amp;&amp; p &lt; sback-&gt;count) {     <I><FONT COLOR="#B22222">// on sait jamais..
</FONT></I>    <I><FONT COLOR="#B22222">// Vérificateur d'intégrité
</FONT></I>#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">DEBUG_CHECKINT</FONT>
    _CHECKINT(&amp;back[p], <B><FONT COLOR="#BC8F8F">&quot;Appel back_delete&quot;</FONT></B>)
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_DEBUG_CLOSESOCK</FONT>
      DEBUG_W(<B><FONT COLOR="#BC8F8F">&quot;back_delete: #%d\n&quot;</FONT></B> _(<B><FONT COLOR="#228B22">int</FONT></B>) p);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

    <I><FONT COLOR="#B22222">// Finalize
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B> (!back[p].finalized) {
      <B><FONT COLOR="#A020F0">if</FONT></B> ((back[p].status == STATUS_READY)      <I><FONT COLOR="#B22222">// ready
</FONT></I>          &amp;&amp; (!back[p].testmode)        <I><FONT COLOR="#B22222">// not test mode
</FONT></I>          &amp;&amp; (back[p].r.statuscode &gt; 0) <I><FONT COLOR="#B22222">// not internal error
</FONT></I>        ) {
        hts_log_print(opt, LOG_DEBUG,
                      <B><FONT COLOR="#BC8F8F">&quot;File '%s%s' -&gt; %s not yet saved in cache - saving now&quot;</FONT></B>,
                      back[p].url_adr, back[p].url_fil, back[p].url_sav);
      }
      <B><FONT COLOR="#A020F0">if</FONT></B> (cache != NULL) {
        <I><FONT COLOR="#B22222">//hts_log_print(opt, LOG_TRACE, &quot;finalizing from back_delete&quot;);
</FONT></I>        back_finalize(opt, cache, sback, p);
      }
    }
    back[p].finalized = 0;

    <I><FONT COLOR="#B22222">// flush output buffers
</FONT></I>    (<B><FONT COLOR="#228B22">void</FONT></B>) back_flush_output(opt, cache, sback, p);

    <B><FONT COLOR="#A020F0">return</FONT></B> back_clear_entry(&amp;back[p]);
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}

<I><FONT COLOR="#B22222">/* ensure that the entry is not locked */</FONT></I>
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">back_index_unlock</FONT></B>(struct_back * sback, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> p) {
  lien_back *<B><FONT COLOR="#228B22">const</FONT></B> back = sback-&gt;lnk;

  <B><FONT COLOR="#A020F0">if</FONT></B> (back[p].locked) {
    back[p].locked = 0;         <I><FONT COLOR="#B22222">/* not locked anymore */</FONT></I>
  }
}

<I><FONT COLOR="#B22222">/* the entry is available again */</FONT></I>
<B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">back_set_free</FONT></B>(lien_back * back) {
  back-&gt;locked = 0;
  back-&gt;status = STATUS_FREE;
}

<I><FONT COLOR="#B22222">/* delete entry content (clear the entry), but don't unallocate the entry itself */</FONT></I>
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">back_clear_entry</FONT></B>(lien_back * back) {
  <B><FONT COLOR="#A020F0">if</FONT></B> (back != NULL) {
    <I><FONT COLOR="#B22222">// Libérer tous les sockets, handles, buffers..
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B> (back-&gt;r.soc != INVALID_SOCKET) {
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_DEBUG_CLOSESOCK</FONT>
      DEBUG_W(<B><FONT COLOR="#BC8F8F">&quot;back_delete: deletehttp\n&quot;</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
      deletehttp(&amp;back-&gt;r);
      back-&gt;r.soc = INVALID_SOCKET;
    }

    <B><FONT COLOR="#A020F0">if</FONT></B> (back-&gt;r.adr != NULL) {  <I><FONT COLOR="#B22222">// reste un bloc à désallouer
</FONT></I>      freet(back-&gt;r.adr);
      back-&gt;r.adr = NULL;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (back-&gt;chunk_adr != NULL) {      <I><FONT COLOR="#B22222">// reste un bloc à désallouer
</FONT></I>      freet(back-&gt;chunk_adr);
      back-&gt;chunk_adr = NULL;
      back-&gt;chunk_size = 0;
      back-&gt;chunk_blocksize = 0;
      back-&gt;is_chunk = 0;
    }
    <I><FONT COLOR="#B22222">// only for security
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B> (back-&gt;tmpfile &amp;&amp; back-&gt;tmpfile[0] != <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>) {
      (<B><FONT COLOR="#228B22">void</FONT></B>) unlink(back-&gt;tmpfile);
      back-&gt;tmpfile = NULL;
    }
    <I><FONT COLOR="#B22222">// headers
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B> (back-&gt;r.headers != NULL) {
      freet(back-&gt;r.headers);
      back-&gt;r.headers = NULL;
    }
    <I><FONT COLOR="#B22222">// Tout nettoyer
</FONT></I>    memset(back, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(lien_back));
    back-&gt;r.soc = INVALID_SOCKET;
    back-&gt;r.location = back-&gt;location_buffer;

    <I><FONT COLOR="#B22222">// Le plus important: libérer le champ
</FONT></I>    back_set_free(back);

    <B><FONT COLOR="#A020F0">return</FONT></B> 1;
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}

<I><FONT COLOR="#B22222">/* Space left on backing stack */</FONT></I>
<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">back_stack_available</FONT></B>(struct_back * sback) {
  lien_back *<B><FONT COLOR="#228B22">const</FONT></B> back = sback-&gt;lnk;
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> back_max = sback-&gt;count;
  <B><FONT COLOR="#228B22">int</FONT></B> p = 0, n = 0;

  <B><FONT COLOR="#A020F0">for</FONT></B>(; p &lt; back_max; p++)
    <B><FONT COLOR="#A020F0">if</FONT></B> (back[p].status == STATUS_FREE)
      n++;
  <B><FONT COLOR="#A020F0">return</FONT></B> n;
}

<I><FONT COLOR="#B22222">// ajouter un lien en backing
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">back_add_if_not_exists</FONT></B>(struct_back * sback, httrackp * opt,
                           cache_back * cache, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *adr, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *fil, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *save,
                           <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *referer_adr, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *referer_fil, <B><FONT COLOR="#228B22">int</FONT></B> test) {
  back_clean(opt, cache, sback);        <I><FONT COLOR="#B22222">/* first cleanup the backlog to ensure that we have some entry left */</FONT></I>
  <B><FONT COLOR="#A020F0">if</FONT></B> (!back_exist(sback, opt, adr, fil, save)) {
    <B><FONT COLOR="#A020F0">return</FONT></B> back_add(sback, opt, cache, adr, fil, save, referer_adr, referer_fil,
                    test);
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> 0;
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">back_add</FONT></B>(struct_back * sback, httrackp * opt, cache_back * cache, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *adr,
             <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *fil, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *save, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *referer_adr, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *referer_fil,
             <B><FONT COLOR="#228B22">int</FONT></B> test) {
  lien_back *<B><FONT COLOR="#228B22">const</FONT></B> back = sback-&gt;lnk;
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> back_max = sback-&gt;count;
  <B><FONT COLOR="#228B22">int</FONT></B> p = 0;
  <B><FONT COLOR="#228B22">char</FONT></B> catbuff[CATBUFF_SIZE];
  <B><FONT COLOR="#228B22">char</FONT></B> catbuff2[CATBUFF_SIZE];
  lien_back *itemback = NULL;

#<B><FONT COLOR="#5F9EA0">if</FONT></B> (<B><FONT COLOR="#5F9EA0">defined</FONT></B>(<FONT COLOR="#B8860B">_DEBUG</FONT>) || <B><FONT COLOR="#5F9EA0">defined</FONT></B>(<FONT COLOR="#B8860B">DEBUG</FONT>))
  <B><FONT COLOR="#A020F0">if</FONT></B> (!test &amp;&amp; back_exist(sback, opt, adr, fil, save)) {
    <B><FONT COLOR="#228B22">int</FONT></B> already_there = 0;

    hts_log_print(opt, LOG_ERROR, <B><FONT COLOR="#BC8F8F">&quot;error: back_add(%s,%s,%s) duplicate&quot;</FONT></B>, adr,
                  fil, save);
  }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

  <I><FONT COLOR="#B22222">// vérifier cohérence de adr et fil (non vide!)
</FONT></I>  <B><FONT COLOR="#A020F0">if</FONT></B> (strnotempty(adr) == 0) {
    hts_log_print(opt, LOG_WARNING, <B><FONT COLOR="#BC8F8F">&quot;error: adr is empty for back_add&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">return</FONT></B> -1;                  <I><FONT COLOR="#B22222">// erreur!
</FONT></I>  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (strnotempty(fil) == 0) {
    hts_log_print(opt, LOG_WARNING, <B><FONT COLOR="#BC8F8F">&quot;error: fil is empty for back_add&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">return</FONT></B> -1;                  <I><FONT COLOR="#B22222">// erreur!
</FONT></I>  }
  <I><FONT COLOR="#B22222">// FIN vérifier cohérence de adr et fil (non vide!)
</FONT></I>
  <I><FONT COLOR="#B22222">// stats
</FONT></I>  opt-&gt;state.back_add_stats++;

  <I><FONT COLOR="#B22222">// rechercher emplacement
</FONT></I>  back_clean(opt, cache, sback);
  <B><FONT COLOR="#A020F0">if</FONT></B> ((p = back_search(opt, sback)) &gt;= 0) {
    back[p].send_too[0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>; <I><FONT COLOR="#B22222">// éventuels paramètres supplémentaires à transmettre au serveur
</FONT></I>
    <I><FONT COLOR="#B22222">// clear r
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B> (back[p].r.soc != INVALID_SOCKET) {      <I><FONT COLOR="#B22222">/* we never know */</FONT></I>
      deletehttp(&amp;back[p].r);
    }
    <I><FONT COLOR="#B22222">//memset(&amp;(back[p].r), 0, sizeof(htsblk)); 
</FONT></I>    hts_init_htsblk(&amp;back[p].r);
    back[p].r.location = back[p].location_buffer;

    <I><FONT COLOR="#B22222">// créer entrée
</FONT></I>    strcpybuff(back[p].url_adr, adr);
    strcpybuff(back[p].url_fil, fil);
    strcpybuff(back[p].url_sav, save);
    <I><FONT COLOR="#B22222">//back[p].links_index = links_index;
</FONT></I>    <I><FONT COLOR="#B22222">// copier referer si besoin
</FONT></I>    strcpybuff(back[p].referer_adr, <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>);
    strcpybuff(back[p].referer_fil, <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>);
    <B><FONT COLOR="#A020F0">if</FONT></B> ((referer_adr) &amp;&amp; (referer_fil)) {       <I><FONT COLOR="#B22222">// existe
</FONT></I>      <B><FONT COLOR="#A020F0">if</FONT></B> ((strnotempty(referer_adr)) &amp;&amp; (strnotempty(referer_fil))) {   <I><FONT COLOR="#B22222">// non vide
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (referer_adr[0] != <B><FONT COLOR="#BC8F8F">'!'</FONT></B>) {    <I><FONT COLOR="#B22222">// non détruit
</FONT></I>          <B><FONT COLOR="#A020F0">if</FONT></B> (strcmp(referer_adr, <B><FONT COLOR="#BC8F8F">&quot;file://&quot;</FONT></B>)) { <I><FONT COLOR="#B22222">// PAS file://
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B> (strcmp(referer_adr, <B><FONT COLOR="#BC8F8F">&quot;primary&quot;</FONT></B>)) {       <I><FONT COLOR="#B22222">// pas referer 1er lien
</FONT></I>              strcpybuff(back[p].referer_adr, referer_adr);
              strcpybuff(back[p].referer_fil, referer_fil);
            }
          }
        }
      }
    }
    <I><FONT COLOR="#B22222">// sav ne sert à rien pour le moment
</FONT></I>    back[p].r.size = 0;         <I><FONT COLOR="#B22222">// rien n'a encore été chargé
</FONT></I>    back[p].r.adr = NULL;       <I><FONT COLOR="#B22222">// pas de bloc de mémoire
</FONT></I>    back[p].r.is_write = 0;     <I><FONT COLOR="#B22222">// à priori stockage en mémoire
</FONT></I>    back[p].maxfile_html = opt-&gt;maxfile_html;
    back[p].maxfile_nonhtml = opt-&gt;maxfile_nonhtml;
    back[p].testmode = test;    <I><FONT COLOR="#B22222">// mode test?
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B> (!opt-&gt;http10)           <I><FONT COLOR="#B22222">// option &quot;forcer 1.0&quot; désactivée
</FONT></I>      back[p].http11 = 1;       <I><FONT COLOR="#B22222">// autoriser http/1.1
</FONT></I>    back[p].head_request = 0;
    <B><FONT COLOR="#A020F0">if</FONT></B> (strcmp(back[p].url_sav, BACK_ADD_TEST) == 0)    <I><FONT COLOR="#B22222">// HEAD
</FONT></I>      back[p].head_request = 1;
    <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (strcmp(back[p].url_sav, BACK_ADD_TEST2) == 0)      <I><FONT COLOR="#B22222">// test en GET
</FONT></I>      back[p].head_request = 2; <I><FONT COLOR="#B22222">// test en get
</FONT></I>
    <I><FONT COLOR="#B22222">/* Stop requested - abort backing */</FONT></I>
    <I><FONT COLOR="#B22222">/* For update mode: second check after cache lookup not to lose all previous cache data ! */</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;state.stop &amp;&amp; !opt-&gt;is_update) {
      back[p].r.statuscode = STATUSCODE_INVALID;        <I><FONT COLOR="#B22222">// fatal
</FONT></I>      strcpybuff(back[p].r.msg, <B><FONT COLOR="#BC8F8F">&quot;mirror stopped by user&quot;</FONT></B>);
      back[p].status = STATUS_READY;    <I><FONT COLOR="#B22222">// terminé
</FONT></I>      back_set_finished(sback, p);
      hts_log_print(opt, LOG_WARNING,
                    <B><FONT COLOR="#BC8F8F">&quot;File not added due to mirror cancel: %s%s&quot;</FONT></B>, adr, fil);
      <B><FONT COLOR="#A020F0">return</FONT></B> 0;
    }
    <I><FONT COLOR="#B22222">// test &quot;fast header&quot; cache ; that is, tests we did that lead to 3XX/4XX/5XX response codes
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B> (cache-&gt;cached_tests != NULL) {
      intptr_t ptr = 0;

      <B><FONT COLOR="#A020F0">if</FONT></B> (coucal_read(cache-&gt;cached_tests,
        concat(OPT_GET_BUFF(opt), OPT_GET_BUFF_SIZE(opt), adr, fil), &amp;ptr)) {       <I><FONT COLOR="#B22222">// gotcha
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (ptr != 0) {
          <B><FONT COLOR="#228B22">char</FONT></B> *text = (<B><FONT COLOR="#228B22">char</FONT></B> *) ptr;
          <B><FONT COLOR="#228B22">char</FONT></B> *lf = strchr(text, <B><FONT COLOR="#BC8F8F">'\n'</FONT></B>);
          <B><FONT COLOR="#228B22">int</FONT></B> code = 0;

          <B><FONT COLOR="#A020F0">if</FONT></B> (sscanf(text, <B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;code) == 1) { <I><FONT COLOR="#B22222">// got code
</FONT></I>            back[p].r.statuscode = code;
            back[p].status = STATUS_READY;      <I><FONT COLOR="#B22222">// terminé
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B> (lf != NULL &amp;&amp; *lf != <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>) {    <I><FONT COLOR="#B22222">// got location ?
</FONT></I>              strcpybuff(back[p].r.location, lf + 1);
            }
            <B><FONT COLOR="#A020F0">return</FONT></B> 0;
          }
        }
      }
    }
    <I><FONT COLOR="#B22222">// tester cache
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B> ((strcmp(adr, <B><FONT COLOR="#BC8F8F">&quot;file://&quot;</FONT></B>))        <I><FONT COLOR="#B22222">/* pas fichier */</FONT></I>
        &amp;&amp;((!test) || (cache-&gt;type == 1))       <I><FONT COLOR="#B22222">/* cache prioritaire, laisser passer en test! */</FONT></I>
        &amp;&amp;((strnotempty(save)) || (strcmp(fil, <B><FONT COLOR="#BC8F8F">&quot;/robots.txt&quot;</FONT></B>) == 0))) { <I><FONT COLOR="#B22222">// si en test on ne doit pas utiliser le cache sinon telescopage avec le 302..
</FONT></I>#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_FAST_CACHE</FONT>
      intptr_t hash_pos;
      <B><FONT COLOR="#228B22">int</FONT></B> hash_pos_return = 0;
#<B><FONT COLOR="#5F9EA0">else</FONT></B>
      <B><FONT COLOR="#228B22">char</FONT></B> *a = NULL;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_FAST_CACHE</FONT>
      <B><FONT COLOR="#A020F0">if</FONT></B> (cache-&gt;hashtable) {
#<B><FONT COLOR="#5F9EA0">else</FONT></B>
      <B><FONT COLOR="#A020F0">if</FONT></B> (cache-&gt;use) {
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
        <B><FONT COLOR="#228B22">char</FONT></B> BIGSTK buff[HTS_URLMAXSIZE * 4];

#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_FAST_CACHE</FONT>
        strcpybuff(buff, adr);
        strcatbuff(buff, fil);
        hash_pos_return = coucal_read(cache-&gt;hashtable, buff, &amp;hash_pos);
#<B><FONT COLOR="#5F9EA0">else</FONT></B>
        buff[0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
        strcatbuff(buff, <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>);
        strcatbuff(buff, adr);
        strcatbuff(buff, <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>);
        strcatbuff(buff, fil);
        strcatbuff(buff, <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>);
        a = strstr(cache-&gt;use, buff);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

        <I><FONT COLOR="#B22222">// Ok, noté en cache-&gt;. mais bien présent dans le cache ou sur disque?
</FONT></I>#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_FAST_CACHE</FONT>
        <I><FONT COLOR="#B22222">// negative values when data is not in cache
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (hash_pos_return &lt; 0) {
#<B><FONT COLOR="#5F9EA0">else</FONT></B>
        <B><FONT COLOR="#A020F0">if</FONT></B> (a) {
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
          <B><FONT COLOR="#A020F0">if</FONT></B> (!test) {          <I><FONT COLOR="#B22222">// non mode test
</FONT></I>#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_FAST_CACHE</FONT>==0
            <B><FONT COLOR="#228B22">int</FONT></B> pos = -1;

            a += strlen(buff);
            sscanf(a, <B><FONT COLOR="#BC8F8F">&quot;%d&quot;</FONT></B>, &amp;pos);      <I><FONT COLOR="#B22222">// lire position
</FONT></I>#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_FAST_CACHE</FONT>==0
            <B><FONT COLOR="#A020F0">if</FONT></B> (pos &lt; 0) {      <I><FONT COLOR="#B22222">// pas de mise en cache data, vérifier existence
</FONT></I>#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
              <I><FONT COLOR="#B22222">/* note: no check with IS_DELAYED_EXT() enabled - postcheck by client please! */</FONT></I>
              <B><FONT COLOR="#A020F0">if</FONT></B> (save[0] != <B><FONT COLOR="#BC8F8F">'\0'</FONT></B> &amp;&amp; !IS_DELAYED_EXT(save) &amp;&amp; fsize_utf8(fconv(catbuff, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(catbuff), save)) &lt;= 0) {  <I><FONT COLOR="#B22222">// fichier final n'existe pas ou est vide!
</FONT></I>                <B><FONT COLOR="#228B22">int</FONT></B> found = 0;

                <I><FONT COLOR="#B22222">/* It is possible that the file has been moved due to changes in build structure */</FONT></I>
                {
                  <B><FONT COLOR="#228B22">char</FONT></B> BIGSTK previous_save[HTS_URLMAXSIZE * 2];
                  htsblk r;

                  previous_save[0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
                  r =
                    cache_readex(opt, cache, adr, fil, <I><FONT COLOR="#B22222">/*head */</FONT></I> NULL,
                                 <I><FONT COLOR="#B22222">/*bound to back[p] (temporary) */</FONT></I>
                                 back[p].location_buffer, previous_save, <I><FONT COLOR="#B22222">/*ro */</FONT></I>
                                 1);
                  <I><FONT COLOR="#B22222">/* Is supposed to be on disk only */</FONT></I>
                  <B><FONT COLOR="#A020F0">if</FONT></B> (r.is_write &amp;&amp; previous_save[0] != <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>) {
                    <I><FONT COLOR="#B22222">/* Exists, but with another (old) filename: rename (almost) silently */</FONT></I>
                    <B><FONT COLOR="#A020F0">if</FONT></B> (strcmp(previous_save, save) != 0
                        &amp;&amp; fexist_utf8(fconv(catbuff, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(catbuff), previous_save))) {
                      rename(fconv(catbuff, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(catbuff), previous_save),
                             fconv(catbuff2, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(catbuff2), save));
                      <B><FONT COLOR="#A020F0">if</FONT></B> (fexist_utf8(fconv(catbuff, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(catbuff), save))) {
                        found = 1;
                        hts_log_print(opt, LOG_DEBUG,
                                      <B><FONT COLOR="#BC8F8F">&quot;File '%s' has been renamed since last mirror to '%s' ; applying changes&quot;</FONT></B>,
                                      previous_save, save);
                      } <B><FONT COLOR="#A020F0">else</FONT></B> {
                        hts_log_print(opt, LOG_ERROR,
                                      <B><FONT COLOR="#BC8F8F">&quot;Could not rename '%s' to '%s' ; will have to retransfer it&quot;</FONT></B>,
                                      previous_save, save);
                      }
                    }
                  }
                  back[p].location_buffer[0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
                }

                <I><FONT COLOR="#B22222">/* Not found ? */</FONT></I>
                <B><FONT COLOR="#A020F0">if</FONT></B> (!found) {
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_FAST_CACHE</FONT>
                  hash_pos_return = 0;
#<B><FONT COLOR="#5F9EA0">else</FONT></B>
                  a = NULL;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
                  <I><FONT COLOR="#B22222">// dévalider car non présent sur disque dans structure originale!!!
</FONT></I>                  <I><FONT COLOR="#B22222">// sinon, le fichier est ok à priori, mais on renverra un if-modified-since pour
</FONT></I>                  <I><FONT COLOR="#B22222">// en être sûr
</FONT></I>                  <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;norecatch) { <I><FONT COLOR="#B22222">// tester norecatch
</FONT></I>                    <B><FONT COLOR="#A020F0">if</FONT></B> (!fexist_utf8(fconv(catbuff, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(catbuff), save))) {   <I><FONT COLOR="#B22222">// fichier existe pas mais déclaré: on l'a effacé
</FONT></I>                      FILE *fp = FOPEN(fconv(catbuff, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(catbuff), save), <B><FONT COLOR="#BC8F8F">&quot;wb&quot;</FONT></B>);

                      <B><FONT COLOR="#A020F0">if</FONT></B> (fp)
                        fclose(fp);
                      hts_log_print(opt, LOG_WARNING,
                                    <B><FONT COLOR="#BC8F8F">&quot;Previous file '%s' not found (erased by user ?), ignoring: %s%s&quot;</FONT></B>,
                                    save, back[p].url_adr, back[p].url_fil);
                    }
                  } <B><FONT COLOR="#A020F0">else</FONT></B> {
                    hts_log_print(opt, LOG_WARNING,
                                  <B><FONT COLOR="#BC8F8F">&quot;Previous file '%s' not found (erased by user ?), recatching: %s%s&quot;</FONT></B>,
                                  save, back[p].url_adr, back[p].url_fil);
                  }
                }
              }                 <I><FONT COLOR="#B22222">// fsize() &lt;= 0
</FONT></I>#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_FAST_CACHE</FONT>==0
            }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
          }
        }
        <I><FONT COLOR="#B22222">//
</FONT></I>      } <B><FONT COLOR="#A020F0">else</FONT></B> {
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_FAST_CACHE</FONT>
        hash_pos_return = 0;
#<B><FONT COLOR="#5F9EA0">else</FONT></B>
        a = NULL;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
      }

      <I><FONT COLOR="#B22222">// Existe pas en cache, ou bien pas de cache présent
</FONT></I>#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_FAST_CACHE</FONT>
      <B><FONT COLOR="#A020F0">if</FONT></B> (hash_pos_return) {    <I><FONT COLOR="#B22222">// OK existe en cache (et données aussi)!
</FONT></I>#<B><FONT COLOR="#5F9EA0">else</FONT></B>
      <B><FONT COLOR="#A020F0">if</FONT></B> (a != NULL) {          <I><FONT COLOR="#B22222">// OK existe en cache (et données aussi)!
</FONT></I>#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> cache_is_prioritary = cache-&gt;type == 1
          || opt-&gt;state.stop != 0;
        <B><FONT COLOR="#A020F0">if</FONT></B> (cache_is_prioritary) {      <I><FONT COLOR="#B22222">// cache prioritaire (pas de test if-modified..)
</FONT></I>          <I><FONT COLOR="#B22222">// dans ce cas on peut également lire des réponses cachées comme 404,302...
</FONT></I>          <I><FONT COLOR="#B22222">// lire dans le cache
</FONT></I>          <B><FONT COLOR="#A020F0">if</FONT></B> (!test)
            back[p].r =
              cache_read(opt, cache, adr, fil, save, back[p].location_buffer);
          <B><FONT COLOR="#A020F0">else</FONT></B>
            back[p].r = cache_read(opt, cache, adr, fil, NULL, back[p].location_buffer);        <I><FONT COLOR="#B22222">// charger en tête uniquement du cache
</FONT></I>
          <I><FONT COLOR="#B22222">/* ensure correct location buffer set */</FONT></I>
          back[p].r.location = back[p].location_buffer;

          <I><FONT COLOR="#B22222">/* Interdiction taille par le wizard? --&gt; détruire */</FONT></I>
          <B><FONT COLOR="#A020F0">if</FONT></B> (back[p].r.statuscode != -1) {     <I><FONT COLOR="#B22222">// pas d'erreur de lecture
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B> (!back_checksize(opt, &amp;back[p], 0)) {
              back[p].status = STATUS_READY;    <I><FONT COLOR="#B22222">// FINI
</FONT></I>              back_set_finished(sback, p);
              back[p].r.statuscode = STATUSCODE_TOO_BIG;
              <B><FONT COLOR="#A020F0">if</FONT></B> (!back[p].testmode)
                strcpybuff(back[p].r.msg, <B><FONT COLOR="#BC8F8F">&quot;Cached file skipped (too big)&quot;</FONT></B>);
              <B><FONT COLOR="#A020F0">else</FONT></B>
                strcpybuff(back[p].r.msg,
                           <B><FONT COLOR="#BC8F8F">&quot;Test: Cached file skipped  (too big)&quot;</FONT></B>);
              <B><FONT COLOR="#A020F0">return</FONT></B> 0;
            }
          }

          <B><FONT COLOR="#A020F0">if</FONT></B> (back[p].r.statuscode != -1 || IS_DELAYED_EXT(save)) {     <I><FONT COLOR="#B22222">// pas d'erreur de lecture ou test retardé
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B> (!test) {
              hts_log_print(opt, LOG_DEBUG,
                            <B><FONT COLOR="#BC8F8F">&quot;File immediately loaded from cache: %s%s&quot;</FONT></B>,
                            back[p].url_adr, back[p].url_fil);
            } <B><FONT COLOR="#A020F0">else</FONT></B> {
              hts_log_print(opt, LOG_DEBUG,
                            <B><FONT COLOR="#BC8F8F">&quot;File immediately tested from cache: %s%s&quot;</FONT></B>,
                            back[p].url_adr, back[p].url_fil);
            }
            back[p].r.notmodified = 1;  <I><FONT COLOR="#B22222">// fichier non modifié
</FONT></I>            back[p].status = STATUS_READY;      <I><FONT COLOR="#B22222">// OK prêt
</FONT></I>            <I><FONT COLOR="#B22222">//file_notify(back[p].url_adr, back[p].url_fil, back[p].url_sav, 0, 0, back[p].r.notmodified);        // not modified
</FONT></I>            back_set_finished(sback, p);

            <I><FONT COLOR="#B22222">// finalize transfer
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B> (!test) {
              <B><FONT COLOR="#A020F0">if</FONT></B> (back[p].r.statuscode &gt; 0) {
                hts_log_print(opt, LOG_TRACE, <B><FONT COLOR="#BC8F8F">&quot;finalizing in back_add&quot;</FONT></B>);
                back_finalize(opt, cache, sback, p);
              }
            }

            <B><FONT COLOR="#A020F0">return</FONT></B> 0;
          } <B><FONT COLOR="#A020F0">else</FONT></B> {              <I><FONT COLOR="#B22222">// erreur
</FONT></I>            <I><FONT COLOR="#B22222">// effacer r
</FONT></I>            hts_init_htsblk(&amp;back[p].r);
            <I><FONT COLOR="#B22222">//memset(&amp;(back[p].r), 0, sizeof(htsblk)); 
</FONT></I>            back[p].r.location = back[p].location_buffer;
            <I><FONT COLOR="#B22222">// et continuer (chercher le fichier)
</FONT></I>          }

        } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (cache-&gt;type == 2) {  <I><FONT COLOR="#B22222">// si en cache, demander de tester If-Modified-Since
</FONT></I>          htsblk r;

          cache_header(opt, cache, adr, fil, &amp;r);

          <I><FONT COLOR="#B22222">/* Interdiction taille par le wizard? */</FONT></I>
          {
            LLint save_totalsize = back[p].r.totalsize;

            back[p].r.totalsize = r.totalsize;
            <B><FONT COLOR="#A020F0">if</FONT></B> (!back_checksize(opt, &amp;back[p], 1)) {
              r.statuscode = STATUSCODE_INVALID;
              <I><FONT COLOR="#B22222">//
</FONT></I>              back[p].status = STATUS_READY;    <I><FONT COLOR="#B22222">// FINI
</FONT></I>              back_set_finished(sback, p);
              back[p].r.statuscode = STATUSCODE_TOO_BIG;
              deletehttp(&amp;back[p].r);
              back[p].r.soc = INVALID_SOCKET;
              <B><FONT COLOR="#A020F0">if</FONT></B> (!back[p].testmode)
                strcpybuff(back[p].r.msg, <B><FONT COLOR="#BC8F8F">&quot;File too big&quot;</FONT></B>);
              <B><FONT COLOR="#A020F0">else</FONT></B>
                strcpybuff(back[p].r.msg, <B><FONT COLOR="#BC8F8F">&quot;Test: File too big&quot;</FONT></B>);
              <B><FONT COLOR="#A020F0">return</FONT></B> 0;
            }
            back[p].r.totalsize = save_totalsize;
          }

          <B><FONT COLOR="#A020F0">if</FONT></B> (r.statuscode != -1) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (r.statuscode == HTTP_OK) {      <I><FONT COLOR="#B22222">// uniquement des 200 (OK)
</FONT></I>              <B><FONT COLOR="#A020F0">if</FONT></B> (strnotempty(r.etag)) {        <I><FONT COLOR="#B22222">// ETag (RFC2616)
</FONT></I>                <I><FONT COLOR="#B22222">/*
                   - If both an entity tag and a Last-Modified value have been
                   provided by the origin server, SHOULD use both validators in
                   cache-conditional requests. This allows both HTTP/1.0 and
                   HTTP/1.1 caches to respond appropriately.
                 */</FONT></I>
                <B><FONT COLOR="#A020F0">if</FONT></B> (strnotempty(r.lastmodified))
                  sprintf(back[p].send_too,
                          <B><FONT COLOR="#BC8F8F">&quot;If-None-Match: %s\r\nIf-Modified-Since: %s\r\n&quot;</FONT></B>,
                          r.etag, r.lastmodified);
                <B><FONT COLOR="#A020F0">else</FONT></B>
                  sprintf(back[p].send_too, <B><FONT COLOR="#BC8F8F">&quot;If-None-Match: %s\r\n&quot;</FONT></B>, r.etag);
              } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (strnotempty(r.lastmodified))
                sprintf(back[p].send_too, <B><FONT COLOR="#BC8F8F">&quot;If-Modified-Since: %s\r\n&quot;</FONT></B>,
                        r.lastmodified);
              <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (strnotempty(cache-&gt;lastmodified))
                sprintf(back[p].send_too, <B><FONT COLOR="#BC8F8F">&quot;If-Modified-Since: %s\r\n&quot;</FONT></B>,
                        cache-&gt;lastmodified);

              <I><FONT COLOR="#B22222">/* this is an update of a file */</FONT></I>
              <B><FONT COLOR="#A020F0">if</FONT></B> (strnotempty(back[p].send_too))
                back[p].is_update = 1;
              back[p].r.req.nocompression = 1;  <I><FONT COLOR="#B22222">/* Do not compress when updating! */</FONT></I>

            }
          }
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">DEBUGCA</FONT>
          printf(<B><FONT COLOR="#BC8F8F">&quot;..is modified test %s\n&quot;</FONT></B>, back[p].send_too);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
        }
      }
      <I><FONT COLOR="#B22222">/* Not in cache ; maybe in temporary cache ? Warning: non-movable &quot;url_sav&quot; */</FONT></I>
      <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (back_unserialize_ref(opt, adr, fil, &amp;itemback) == 0) {
        <B><FONT COLOR="#228B22">const</FONT></B> off_t file_size = fsize_utf8(itemback-&gt;url_sav);

        <I><FONT COLOR="#B22222">/* Found file on disk */</FONT></I>
        <B><FONT COLOR="#A020F0">if</FONT></B> (file_size &gt; 0) {
          <B><FONT COLOR="#228B22">char</FONT></B> *send_too = back[p].send_too;

          sprintf(send_too, <B><FONT COLOR="#BC8F8F">&quot;Range: bytes=&quot;</FONT></B> LLintP <B><FONT COLOR="#BC8F8F">&quot;-\r\n&quot;</FONT></B>, (LLint) file_size);
          send_too += strlen(send_too);
          <I><FONT COLOR="#B22222">/* add etag information */</FONT></I>
          <B><FONT COLOR="#A020F0">if</FONT></B> (strnotempty(itemback-&gt;r.etag)) {
            sprintf(send_too, <B><FONT COLOR="#BC8F8F">&quot;If-Match: %s\r\n&quot;</FONT></B>, itemback-&gt;r.etag);
            send_too += strlen(send_too);
          }
          <I><FONT COLOR="#B22222">/* add date information */</FONT></I>
          <B><FONT COLOR="#A020F0">if</FONT></B> (strnotempty(itemback-&gt;r.lastmodified)) {
            sprintf(send_too, <B><FONT COLOR="#BC8F8F">&quot;If-Unmodified-Since: %s\r\n&quot;</FONT></B>,
                    itemback-&gt;r.lastmodified);
            send_too += strlen(send_too);
          }
          back[p].http11 = 1;   <I><FONT COLOR="#B22222">/* 1.1 */</FONT></I>
          back[p].range_req_size = (LLint) file_size;
          back[p].r.req.range_used = 1;
          back[p].is_update = 1;        <I><FONT COLOR="#B22222">/* this is an update of a file */</FONT></I>
          back[p].r.req.nocompression = 1;      <I><FONT COLOR="#B22222">/* Do not compress when updating! */</FONT></I>
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
          <I><FONT COLOR="#B22222">/* broken ; remove */</FONT></I>
          url_savename_refname_remove(opt, adr, fil);
        }
        <I><FONT COLOR="#B22222">/* cleanup */</FONT></I>
        back_clear_entry(itemback);     <I><FONT COLOR="#B22222">/* delete entry content */</FONT></I>
        freet(itemback);        <I><FONT COLOR="#B22222">/* delete item */</FONT></I>
        itemback = NULL;
      }
      <I><FONT COLOR="#B22222">/* Not in cache or temporary cache ; found on disk ? (hack) */</FONT></I>
      <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (fexist_utf8(save)) {
        <B><FONT COLOR="#228B22">const</FONT></B> off_t sz = fsize_utf8(save);

        <I><FONT COLOR="#B22222">// Bon, là il est possible que le fichier ait été partiellement transféré
</FONT></I>        <I><FONT COLOR="#B22222">// (s'il l'avait été en totalité il aurait été inscrit dans le cache ET existerait sur disque)
</FONT></I>        <I><FONT COLOR="#B22222">// PAS de If-Modified-Since, on a pas connaissance des données à la date du cache
</FONT></I>        <I><FONT COLOR="#B22222">// On demande juste les données restantes si le date est valide (206), tout sinon (200)
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> ((ishtml(opt, save) != 1) &amp;&amp; (ishtml(opt, back[p].url_fil) != 1)) {  <I><FONT COLOR="#B22222">// NON HTML (liens changés!!)
</FONT></I>          <B><FONT COLOR="#A020F0">if</FONT></B> (sz &gt; 0) {         <I><FONT COLOR="#B22222">// Fichier non vide? (question bête, sinon on transfert tout!)
</FONT></I>            <B><FONT COLOR="#228B22">char</FONT></B> lastmodified[256];

            get_filetime_rfc822(save, lastmodified);
            <B><FONT COLOR="#A020F0">if</FONT></B> (strnotempty(lastmodified)) {    <I><FONT COLOR="#B22222">/* pas de If-.. possible */</FONT></I>
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">DEBUGCA</FONT>
              printf(<B><FONT COLOR="#BC8F8F">&quot;..if unmodified since %s size &quot;</FONT></B> LLintP <B><FONT COLOR="#BC8F8F">&quot;\n&quot;</FONT></B>, lastmodified,
                     (LLint) sz);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
              hts_log_print(opt, LOG_DEBUG,
                            <B><FONT COLOR="#BC8F8F">&quot;File partially present (&quot;</FONT></B> LLintP <B><FONT COLOR="#BC8F8F">&quot; bytes): %s%s&quot;</FONT></B>,
                            (LLint) sz, back[p].url_adr, back[p].url_fil);

              <I><FONT COLOR="#B22222">/* impossible - don't have etag or date
                 if (strnotempty(back[p].r.etag)) {  // ETag (RFC2616)
                 sprintf(back[p].send_too,&quot;If-None-Match: %s\r\n&quot;,back[p].r.etag);
                 back[p].http11=1;    // En tête 1.1
                 } else if (strnotempty(back[p].r.lastmodified)) {
                 sprintf(back[p].send_too,&quot;If-Unmodified-Since: %s\r\n&quot;,back[p].r.lastmodified);
                 back[p].http11=1;    // En tête 1.1
                 } else 
               */</FONT></I>
              <B><FONT COLOR="#A020F0">if</FONT></B> (strlen(lastmodified)) {
                sprintf(back[p].send_too,
                        <B><FONT COLOR="#BC8F8F">&quot;If-Unmodified-Since: %s\r\nRange: bytes=&quot;</FONT></B> LLintP
                        <B><FONT COLOR="#BC8F8F">&quot;-\r\n&quot;</FONT></B>, lastmodified, (LLint) sz);
                back[p].http11 = 1;     <I><FONT COLOR="#B22222">// En tête 1.1
</FONT></I>                back[p].is_update = 1;  <I><FONT COLOR="#B22222">/* this is an update of a file */</FONT></I>
                back[p].range_req_size = sz;
                back[p].r.req.range_used = 1;
                back[p].r.req.nocompression = 1;
              } <B><FONT COLOR="#A020F0">else</FONT></B> {
                hts_log_print(opt, LOG_WARNING,
                              <B><FONT COLOR="#BC8F8F">&quot;Could not find timestamp for partially present file, restarting (lost &quot;</FONT></B>
                              LLintP <B><FONT COLOR="#BC8F8F">&quot; bytes): %s%s&quot;</FONT></B>, (LLint) sz,
                              back[p].url_adr, back[p].url_fil);
              }

            } <B><FONT COLOR="#A020F0">else</FONT></B> {
              hts_log_print(opt, LOG_NOTICE,
                            <B><FONT COLOR="#BC8F8F">&quot;File partially present (&quot;</FONT></B> LLintP
                            <B><FONT COLOR="#BC8F8F">&quot; bytes) retransferred due to lack of cache: %s%s&quot;</FONT></B>,
                            (LLint) sz, back[p].url_adr, back[p].url_fil);
              <I><FONT COLOR="#B22222">/* Sinon requête normale... */</FONT></I>
              back[p].http11 = 0;
            }
          } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;norecatch) {  <I><FONT COLOR="#B22222">// tester norecatch
</FONT></I>            filenote(&amp;opt-&gt;state.strc, save, NULL);     <I><FONT COLOR="#B22222">// ne pas purger tout de même
</FONT></I>            file_notify(opt, back[p].url_adr, back[p].url_fil, back[p].url_sav,
                        0, 0, back[p].r.notmodified);
            back[p].status = STATUS_READY;      <I><FONT COLOR="#B22222">// OK prêt
</FONT></I>            back_set_finished(sback, p);
            back[p].r.statuscode = STATUSCODE_INVALID;  <I><FONT COLOR="#B22222">// erreur
</FONT></I>            strcpybuff(back[p].r.msg, <B><FONT COLOR="#BC8F8F">&quot;Null-size file not recaught&quot;</FONT></B>);
            <B><FONT COLOR="#A020F0">return</FONT></B> 0;
          }
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
          hts_log_print(opt, LOG_NOTICE,
                        <B><FONT COLOR="#BC8F8F">&quot;HTML file (&quot;</FONT></B> LLintP
                        <B><FONT COLOR="#BC8F8F">&quot; bytes) retransferred due to lack of cache: %s%s&quot;</FONT></B>,
                        (LLint) sz, back[p].url_adr, back[p].url_fil);
          <I><FONT COLOR="#B22222">/* Sinon requête normale... */</FONT></I>
          back[p].http11 = 0;
        }
      }
    }

    <I><FONT COLOR="#B22222">/* Stop requested - abort backing */</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;state.stop) {
      back[p].r.statuscode = STATUSCODE_INVALID;        <I><FONT COLOR="#B22222">// fatal
</FONT></I>      strcpybuff(back[p].r.msg, <B><FONT COLOR="#BC8F8F">&quot;mirror stopped by user&quot;</FONT></B>);
      back[p].status = STATUS_READY;    <I><FONT COLOR="#B22222">// terminé
</FONT></I>      back_set_finished(sback, p);
      hts_log_print(opt, LOG_WARNING,
                    <B><FONT COLOR="#BC8F8F">&quot;File not added due to mirror cancel: %s%s&quot;</FONT></B>, adr, fil);
      <B><FONT COLOR="#A020F0">return</FONT></B> 0;
    }

    {
      <I><FONT COLOR="#B22222">///htsblk r;   non directement dans la structure-réponse!
</FONT></I>      T_SOC soc;

      <I><FONT COLOR="#B22222">// ouvrir liaison, envoyer requète
</FONT></I>      <I><FONT COLOR="#B22222">// ne pas traiter ou recevoir l'en tête immédiatement
</FONT></I>      hts_init_htsblk(&amp;back[p].r);
      <I><FONT COLOR="#B22222">//memset(&amp;(back[p].r), 0, sizeof(htsblk)); 
</FONT></I>      back[p].r.location = back[p].location_buffer;
      <I><FONT COLOR="#B22222">// recopier proxy
</FONT></I>      <B><FONT COLOR="#A020F0">if</FONT></B> ((back[p].r.req.proxy.active = opt-&gt;proxy.active)) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (StringBuff(opt-&gt;proxy.bindhost) != NULL)
          back[p].r.req.proxy.bindhost = StringBuff(opt-&gt;proxy.bindhost);
        <B><FONT COLOR="#A020F0">if</FONT></B> (StringBuff(opt-&gt;proxy.name) != NULL)
          back[p].r.req.proxy.name = StringBuff(opt-&gt;proxy.name);
        back[p].r.req.proxy.port = opt-&gt;proxy.port;
      }
      <I><FONT COLOR="#B22222">// et user-agent
</FONT></I>      back[p].r.req.user_agent = StringBuff(opt-&gt;user_agent);
      back[p].r.req.referer = StringBuff(opt-&gt;referer);
      back[p].r.req.from = StringBuff(opt-&gt;from);
      back[p].r.req.lang_iso = StringBuff(opt-&gt;lang_iso);
      back[p].r.req.accept = StringBuff(opt-&gt;accept);
      back[p].r.req.headers = StringBuff(opt-&gt;headers);
      back[p].r.req.user_agent_send = opt-&gt;user_agent_send;
      <I><FONT COLOR="#B22222">// et http11
</FONT></I>      back[p].r.req.http11 = back[p].http11;
      back[p].r.req.nocompression = opt-&gt;nocompression;
      back[p].r.req.nokeepalive = opt-&gt;nokeepalive;

      <I><FONT COLOR="#B22222">// mode ftp, court-circuit!
</FONT></I>      <B><FONT COLOR="#A020F0">if</FONT></B> (strfield(back[p].url_adr, <B><FONT COLOR="#BC8F8F">&quot;ftp://&quot;</FONT></B>)) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (back[p].testmode) {
          hts_log_print(opt, LOG_DEBUG,
                        <B><FONT COLOR="#BC8F8F">&quot;error: forbidden test with ftp link for back_add&quot;</FONT></B>);
          <B><FONT COLOR="#A020F0">return</FONT></B> -1;            <I><FONT COLOR="#B22222">// erreur pas de test permis
</FONT></I>        }
        <B><FONT COLOR="#A020F0">if</FONT></B> (!(back[p].r.req.proxy.active &amp;&amp; opt-&gt;ftp_proxy)) {  <I><FONT COLOR="#B22222">// connexion directe, gérée en thread
</FONT></I>          FTPDownloadStruct *str =
            (FTPDownloadStruct *) malloc(<B><FONT COLOR="#A020F0">sizeof</FONT></B>(FTPDownloadStruct));
          str-&gt;pBack = &amp;back[p];
          str-&gt;pOpt = opt;
          <I><FONT COLOR="#B22222">/* */</FONT></I>
          back[p].status = STATUS_FTP_TRANSFER; <I><FONT COLOR="#B22222">// connexion ftp
</FONT></I>#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">USE_BEGINTHREAD</FONT>
          launch_ftp(str);
#<B><FONT COLOR="#5F9EA0">else</FONT></B>
#<B><FONT COLOR="#5F9EA0">error</FONT></B> <FONT COLOR="#B8860B">Must</FONT> <FONT COLOR="#B8860B">have</FONT> <FONT COLOR="#B8860B">pthreads</FONT>
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
          <B><FONT COLOR="#A020F0">return</FONT></B> 0;
        }
      }
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_USEOPENSSL</FONT>
      <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (strfield(back[p].url_adr, <B><FONT COLOR="#BC8F8F">&quot;https://&quot;</FONT></B>)) {     <I><FONT COLOR="#B22222">// let's rock
</FONT></I>        back[p].r.ssl = 1;
        <I><FONT COLOR="#B22222">// back[p].r.ssl_soc = NULL;
</FONT></I>        back[p].r.ssl_con = NULL;
      }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

      <B><FONT COLOR="#A020F0">if</FONT></B> (!back_trylive(opt, cache, sback, p)) {
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_XGETHOST</FONT>
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HDEBUG</FONT>
        printf(<B><FONT COLOR="#BC8F8F">&quot;back_solve..\n&quot;</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
        back[p].status = STATUS_WAIT_DNS;       <I><FONT COLOR="#B22222">// tentative de résolution du nom de host
</FONT></I>        soc = INVALID_SOCKET;   <I><FONT COLOR="#B22222">// pas encore ouverte
</FONT></I>        back_solve(opt, &amp;back[p]);      <I><FONT COLOR="#B22222">// préparer
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (host_wait(opt, &amp;back[p])) { <I><FONT COLOR="#B22222">// prêt, par ex fichier ou dispo dans dns
</FONT></I>#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HDEBUG</FONT>
          printf(<B><FONT COLOR="#BC8F8F">&quot;ok, dns cache ready..\n&quot;</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
          soc =
            http_xfopen(opt, 0, 0, 0, back[p].send_too, adr, fil, &amp;back[p].r);
          <B><FONT COLOR="#A020F0">if</FONT></B> (soc == INVALID_SOCKET) {
            back[p].status = STATUS_READY;      <I><FONT COLOR="#B22222">// fini, erreur
</FONT></I>            back_set_finished(sback, p);
          }
        }
        <I><FONT COLOR="#B22222">//
</FONT></I>#<B><FONT COLOR="#5F9EA0">else</FONT></B>
        <I><FONT COLOR="#B22222">//
</FONT></I>#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">CNXDEBUG</FONT>
        printf(<B><FONT COLOR="#BC8F8F">&quot;XFopen..\n&quot;</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

        <B><FONT COLOR="#A020F0">if</FONT></B> (strnotempty(back[p].send_too))      <I><FONT COLOR="#B22222">// envoyer un if-modified-since
</FONT></I>#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_XCONN</FONT>
          soc = http_xfopen(0, 0, 0, back[p].send_too, adr, fil, &amp;(back[p].r));
#<B><FONT COLOR="#5F9EA0">else</FONT></B>
          soc = http_xfopen(0, 0, 1, back[p].send_too, adr, fil, &amp;(back[p].r));
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
        <B><FONT COLOR="#A020F0">else</FONT></B>
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_XCONN</FONT>
          soc = http_xfopen(test, 0, 0, NULL, adr, fil, &amp;(back[p].r));
#<B><FONT COLOR="#5F9EA0">else</FONT></B>
          soc = http_xfopen(test, 0, 1, NULL, adr, fil, &amp;(back[p].r));
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
      } <B><FONT COLOR="#A020F0">else</FONT></B> {
        soc = back[p].r.soc;

        hts_log_print(opt, LOG_DEBUG,
                      <B><FONT COLOR="#BC8F8F">&quot;(Keep-Alive): successfully linked #%d (for %s%s)&quot;</FONT></B>,
                      back[p].r.debugid, back[p].url_adr, back[p].url_fil);
      }

      <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;timeout &gt; 0) {   <I><FONT COLOR="#B22222">// gestion du opt-&gt;timeout
</FONT></I>        back[p].timeout = opt-&gt;timeout;
        back[p].timeout_refresh = time_local();
      } <B><FONT COLOR="#A020F0">else</FONT></B> {
        back[p].timeout = -1;   <I><FONT COLOR="#B22222">// pas de gestion (default)
</FONT></I>      }

      <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;rateout &gt; 0) {   <I><FONT COLOR="#B22222">// gestion d'un taux minimum de transfert toléré
</FONT></I>        back[p].rateout = opt-&gt;rateout;
        back[p].rateout_time = time_local();
      } <B><FONT COLOR="#A020F0">else</FONT></B> {
        back[p].rateout = -1;   <I><FONT COLOR="#B22222">// pas de gestion (default)
</FONT></I>      }

      <I><FONT COLOR="#B22222">// Note: on charge les code-page erreurs (erreur 404, etc) dans le cas où cela est
</FONT></I>      <I><FONT COLOR="#B22222">// rattrapable (exemple: 301,302 moved xxx -&gt; refresh sur la page!)
</FONT></I>      <I><FONT COLOR="#B22222">//if ((back[p].statuscode!=HTTP_OK) || (soc&lt;0)) { // ERREUR HTTP/autre
</FONT></I>
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">CNXDEBUG</FONT>
      printf(<B><FONT COLOR="#BC8F8F">&quot;Xfopen ok, poll..\n&quot;</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_XGETHOST</FONT>
      <B><FONT COLOR="#A020F0">if</FONT></B> (soc != INVALID_SOCKET)
        <B><FONT COLOR="#A020F0">if</FONT></B> (back[p].status == STATUS_WAIT_DNS) {        <I><FONT COLOR="#B22222">// pas d'erreur
</FONT></I>          <B><FONT COLOR="#A020F0">if</FONT></B> (!back[p].r.is_file)
            back[p].status = STATUS_CONNECTING; <I><FONT COLOR="#B22222">// connexion en cours
</FONT></I>          <B><FONT COLOR="#A020F0">else</FONT></B>
            back[p].status = 1; <I><FONT COLOR="#B22222">// fichier
</FONT></I>        }
#<B><FONT COLOR="#5F9EA0">else</FONT></B>
      <B><FONT COLOR="#A020F0">if</FONT></B> (soc == INVALID_SOCKET) {      <I><FONT COLOR="#B22222">// erreur socket
</FONT></I>        back[p].status = STATUS_READY;  <I><FONT COLOR="#B22222">// FINI
</FONT></I>        back_set_finished(sback, p);
        <I><FONT COLOR="#B22222">//if (back[p].soc!=INVALID_SOCKET) deletehttp(back[p].soc);
</FONT></I>        back[p].r.soc = INVALID_SOCKET;
      } <B><FONT COLOR="#A020F0">else</FONT></B> {
        <B><FONT COLOR="#A020F0">if</FONT></B> (!back[p].r.is_file)
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_XCONN</FONT>
          back[p].status = STATUS_CONNECTING;   <I><FONT COLOR="#B22222">// connexion en cours
</FONT></I>#<B><FONT COLOR="#5F9EA0">else</FONT></B>
          back[p].status = STATUS_WAIT_HEADERS;  <I><FONT COLOR="#B22222">// chargement en tête en cours
</FONT></I>#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
        <B><FONT COLOR="#A020F0">else</FONT></B>
          back[p].status = 1;   <I><FONT COLOR="#B22222">// chargement fichier
</FONT></I>#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">BDEBUG</FONT>==1
        printf(<B><FONT COLOR="#BC8F8F">&quot;..loading header\n&quot;</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
      }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

    }

    <I><FONT COLOR="#B22222">// note: si il y a erreur (404,etc) status=2 (terminé/échec) mais
</FONT></I>    <I><FONT COLOR="#B22222">// le lien est considéré comme traité
</FONT></I>    <I><FONT COLOR="#B22222">//if (back[p].soc&lt;0)  // erreur
</FONT></I>    <I><FONT COLOR="#B22222">//  return -1;
</FONT></I>
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
  } <B><FONT COLOR="#A020F0">else</FONT></B> {
    <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;log != NULL) {
      hts_log_print(opt, LOG_WARNING,
                    <B><FONT COLOR="#BC8F8F">&quot;error: no space left in stack for back_add&quot;</FONT></B>);
      <B><FONT COLOR="#A020F0">if</FONT></B> ((opt-&gt;state.debug_state &amp; 1) == 0) {  <I><FONT COLOR="#B22222">/* debug_state&lt;0&gt; == debug 'no space left in stack' */</FONT></I>
        <B><FONT COLOR="#228B22">int</FONT></B> i;

        hts_log_print(opt, LOG_WARNING, <B><FONT COLOR="#BC8F8F">&quot;debug: DUMPING %d BLOCKS&quot;</FONT></B>, back_max);
        opt-&gt;state.debug_state |= 1;    <I><FONT COLOR="#B22222">/* once */</FONT></I>
        <I><FONT COLOR="#B22222">/* OUTPUT FULL DEBUG INFORMATION THE FIRST TIME WE SEE THIS VERY ANNOYING BUG,
           HOPING THAT SOME USER REPORT WILL QUICKLY SOLVE THIS PROBLEM :p */</FONT></I>
        <B><FONT COLOR="#A020F0">for</FONT></B>(i = 0; i &lt; back_max; i++) {
          <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status != -1) {
            <B><FONT COLOR="#228B22">int</FONT></B> may_clean = slot_can_be_cleaned(&amp;back[i]);
            <B><FONT COLOR="#228B22">int</FONT></B> may_finalize = may_clean
              &amp;&amp; slot_can_be_finalized(opt, &amp;back[i]);
            <B><FONT COLOR="#228B22">int</FONT></B> may_serialize = slot_can_be_cached_on_disk(&amp;back[i]);

            hts_log_print(opt, LOG_DEBUG,
                          <B><FONT COLOR="#BC8F8F">&quot;back[%03d]: may_clean=%d, may_finalize_disk=%d, may_serialize=%d:&quot;</FONT></B>
                          LF <B><FONT COLOR="#BC8F8F">&quot;\t&quot;</FONT></B>
                          <B><FONT COLOR="#BC8F8F">&quot;finalized(%d), status(%d), locked(%d), delayed(%d), test(%d), &quot;</FONT></B>
                          LF <B><FONT COLOR="#BC8F8F">&quot;\t&quot;</FONT></B>
                          <B><FONT COLOR="#BC8F8F">&quot;statuscode(%d), size(%d), is_write(%d), may_hypertext(%d), &quot;</FONT></B>
                          LF <B><FONT COLOR="#BC8F8F">&quot;\t&quot;</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;contenttype(%s), url(%s%s), save(%s)&quot;</FONT></B>, i,
                          may_clean, may_finalize, may_serialize,
                          back[i].finalized, back[i].status, back[i].locked,
                          IS_DELAYED_EXT(back[i].url_sav), back[i].testmode,
                          back[i].r.statuscode, (<B><FONT COLOR="#228B22">int</FONT></B>) back[i].r.size,
                          back[i].r.is_write, may_be_hypertext_mime(opt,
                                                                    back[i].r.
                                                                    contenttype,
                                                                    back[i].
                                                                    url_fil),
                          <I><FONT COLOR="#B22222">/* */</FONT></I>
                          back[i].r.contenttype, back[i].url_adr,
                          back[i].url_fil,
                          back[i].url_sav ? back[i].url_sav : <B><FONT COLOR="#BC8F8F">&quot;&lt;null&gt;&quot;</FONT></B>);
          }
        }
      }

    }
    <B><FONT COLOR="#A020F0">return</FONT></B> -1;                  <I><FONT COLOR="#B22222">// plus de place
</FONT></I>  }
}

#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_XGETHOST</FONT>
<I><FONT COLOR="#B22222">// attendre que le host (ou celui du proxy) ait été résolu
</FONT></I><I><FONT COLOR="#B22222">// si c'est un fichier, la résolution est immédiate
</FONT></I><I><FONT COLOR="#B22222">// idem pour ftp://
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">back_solve</FONT></B>(httrackp * opt, lien_back * back) {
  assertf(opt != NULL);
  assertf(back != NULL);
  <B><FONT COLOR="#A020F0">if</FONT></B> ((!strfield(back-&gt;url_adr, <B><FONT COLOR="#BC8F8F">&quot;file://&quot;</FONT></B>))
      &amp;&amp; !strfield(back-&gt;url_adr, <B><FONT COLOR="#BC8F8F">&quot;ftp://&quot;</FONT></B>)
    ) {
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *a;

    <B><FONT COLOR="#A020F0">if</FONT></B> (!(back-&gt;r.req.proxy.active))
      a = back-&gt;url_adr;
    <B><FONT COLOR="#A020F0">else</FONT></B>
      a = back-&gt;r.req.proxy.name;
    assertf(a != NULL);
    a = jump_protocol_const(a);
    <B><FONT COLOR="#A020F0">if</FONT></B> (check_hostname_dns(a)) {
      hts_log_print(opt, LOG_DEBUG, <B><FONT COLOR="#BC8F8F">&quot;resolved: %s&quot;</FONT></B>, a);
    } <B><FONT COLOR="#A020F0">else</FONT></B> {
      hts_log_print(opt, LOG_DEBUG, <B><FONT COLOR="#BC8F8F">&quot;failed to resolve: %s&quot;</FONT></B>, a);
    }
    <I><FONT COLOR="#B22222">//if (hts_dnstest(opt, a, 1) == 2) { // non encore testé!..
</FONT></I>    <I><FONT COLOR="#B22222">//  hts_log_print(opt, LOG_DEBUG, &quot;resolving in background: %s&quot;, a);
</FONT></I>    <I><FONT COLOR="#B22222">//}
</FONT></I>  }
}

<I><FONT COLOR="#B22222">// détermine si le host a pu être résolu
</FONT></I><B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">host_wait</FONT></B>(httrackp * opt, lien_back * back) {
  <I><FONT COLOR="#B22222">// Always synchronous. No more background DNS resolution
</FONT></I>  <I><FONT COLOR="#B22222">// (does not really improve performances)
</FONT></I>  <B><FONT COLOR="#A020F0">return</FONT></B> 1;
}
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">// élimine les fichiers non html en backing (anticipation)
</FONT></I><I><FONT COLOR="#B22222">// cleanup non-html files in backing to save backing space
</FONT></I><I><FONT COLOR="#B22222">// and allow faster &quot;save in cache&quot; operation
</FONT></I><I><FONT COLOR="#B22222">// also cleanup keep-alive sockets and ensure that not too many sockets are being opened
</FONT></I>
<B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">slot_can_be_cleaned</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> lien_back * back) {
  <B><FONT COLOR="#A020F0">return</FONT></B> (back-&gt;status == STATUS_READY) <I><FONT COLOR="#B22222">// ready
</FONT></I>    <I><FONT COLOR="#B22222">/* Check autoclean */</FONT></I>
    &amp;&amp; (!back-&gt;testmode)        <I><FONT COLOR="#B22222">// not test mode
</FONT></I>    &amp;&amp; (strnotempty(back-&gt;url_sav))     <I><FONT COLOR="#B22222">// filename exists
</FONT></I>    &amp;&amp; (HTTP_IS_OK(back-&gt;r.statuscode)) <I><FONT COLOR="#B22222">// HTTP &quot;OK&quot;
</FONT></I>    &amp;&amp; (back-&gt;r.size &gt;= 0)      <I><FONT COLOR="#B22222">// size&gt;=0
</FONT></I>    ;
}

<B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">slot_can_be_finalized</FONT></B>(httrackp * opt, <B><FONT COLOR="#228B22">const</FONT></B> lien_back * back) {
  <B><FONT COLOR="#A020F0">return</FONT></B> back-&gt;r.is_write       <I><FONT COLOR="#B22222">// not in memory (on disk, ready)
</FONT></I>    &amp;&amp; !is_hypertext_mime(opt, back-&gt;r.contenttype, back-&gt;url_fil)      <I><FONT COLOR="#B22222">// not HTML/hypertext
</FONT></I>    &amp;&amp; !may_be_hypertext_mime(opt, back-&gt;r.contenttype, back-&gt;url_fil)  <I><FONT COLOR="#B22222">// may NOT be parseable mime type
</FONT></I>    <I><FONT COLOR="#B22222">/* Has not been added before the heap saw the link, or now exists on heap */</FONT></I>
    &amp;&amp; (!back-&gt;early_add
        || hash_read(opt-&gt;hash, back-&gt;url_sav, NULL, HASH_STRUCT_FILENAME) &gt;= 0);
}

<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">back_clean</FONT></B>(httrackp * opt, cache_back * cache, struct_back * sback) {
  lien_back *<B><FONT COLOR="#228B22">const</FONT></B> back = sback-&gt;lnk;
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> back_max = sback-&gt;count;
  <B><FONT COLOR="#228B22">int</FONT></B> oneMore = ((opt-&gt;state._hts_in_html_parsing == 2 &amp;&amp; opt-&gt;maxsoc &gt;= 2) || (opt-&gt;state._hts_in_html_parsing == 1 &amp;&amp; opt-&gt;maxsoc &gt;= 4)) ? 1 : 0;     <I><FONT COLOR="#B22222">// testing links
</FONT></I>  <B><FONT COLOR="#228B22">int</FONT></B> i;

  <B><FONT COLOR="#A020F0">for</FONT></B>(i = 0; i &lt; back_max; i++) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (slot_can_be_cleaned(&amp;back[i])) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (slot_can_be_finalized(opt, &amp;back[i])) {
        (<B><FONT COLOR="#228B22">void</FONT></B>) back_flush_output(opt, cache, sback, i); <I><FONT COLOR="#B22222">// flush output buffers
</FONT></I>        usercommand(opt, 0, NULL, back[i].url_sav, back[i].url_adr,
                    back[i].url_fil);
        <I><FONT COLOR="#B22222">//if (back[i].links_index &gt;= 0) {
</FONT></I>        <I><FONT COLOR="#B22222">//  assertf(back[i].links_index &lt; opt-&gt;hash-&gt;max_lien);
</FONT></I>        <I><FONT COLOR="#B22222">//  opt-&gt;hash-&gt;liens[back[i].links_index]-&gt;pass2 = -1;
</FONT></I>        <I><FONT COLOR="#B22222">//  // *back[i].pass2_ptr=-1;  // Done!
</FONT></I>        <I><FONT COLOR="#B22222">//}
</FONT></I>        <I><FONT COLOR="#B22222">/* MANDATORY if we don't want back_fill() to endlessly put the same file on download! */</FONT></I>
        {
          <B><FONT COLOR="#228B22">int</FONT></B> index = hash_read(opt-&gt;hash, back[i].url_sav, NULL, HASH_STRUCT_FILENAME );       <I><FONT COLOR="#B22222">// lecture type 0 (sav)
</FONT></I>
          <B><FONT COLOR="#A020F0">if</FONT></B> (index &gt;= 0) {
            opt-&gt;liens[index]-&gt;pass2 = -1;        <I><FONT COLOR="#B22222">/* DONE! */</FONT></I>
          } <B><FONT COLOR="#A020F0">else</FONT></B> {
            hts_log_print(opt, LOG_INFO,
                          <B><FONT COLOR="#BC8F8F">&quot;engine: warning: entry cleaned up, but no trace on heap: %s%s (%s)&quot;</FONT></B>,
                          back[i].url_adr, back[i].url_fil, back[i].url_sav);
          }
        }
        HTS_STAT.stat_background++;
        hts_log_print(opt, LOG_INFO,
                      <B><FONT COLOR="#BC8F8F">&quot;File successfully written in background: %s&quot;</FONT></B>,
                      back[i].url_sav);
        back_maydelete(opt, cache, sback, i);   <I><FONT COLOR="#B22222">// May delete backing entry
</FONT></I>      } <B><FONT COLOR="#A020F0">else</FONT></B> {
        <B><FONT COLOR="#A020F0">if</FONT></B> (!back[i].finalized) {
          <B><FONT COLOR="#A020F0">if</FONT></B> (1) {
            <I><FONT COLOR="#B22222">/* Ensure deleted or recycled socket */</FONT></I>
            <I><FONT COLOR="#B22222">/* BUT DO NOT YET WIPE back[i].r.adr */</FONT></I>
            hts_log_print(opt, LOG_DEBUG,
                          <B><FONT COLOR="#BC8F8F">&quot;file %s%s validated (cached, left in memory)&quot;</FONT></B>,
                          back[i].url_adr, back[i].url_fil);
            back_maydeletehttp(opt, cache, sback, i);
          } <B><FONT COLOR="#A020F0">else</FONT></B> {
            <I><FONT COLOR="#B22222">/*
               NOT YET HANDLED CORRECTLY (READ IN NEW CACHE TO DO)
             */</FONT></I>
            <I><FONT COLOR="#B22222">/* Lock the entry but do not keep the html data in memory (in cache) */</FONT></I>
            <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;cache) {
              htsblk r;

              <I><FONT COLOR="#B22222">/* Ensure deleted or recycled socket */</FONT></I>
              back_maydeletehttp(opt, cache, sback, i);
              assertf(back[i].r.soc == INVALID_SOCKET);

              <I><FONT COLOR="#B22222">/* Check header */</FONT></I>
              cache_header(opt, cache, back[i].url_adr, back[i].url_fil, &amp;r);
              <B><FONT COLOR="#A020F0">if</FONT></B> (r.statuscode == HTTP_OK) {
                <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.soc == INVALID_SOCKET) {
                  <I><FONT COLOR="#B22222">/* Delete buffer and sockets */</FONT></I>
                  deleteaddr(&amp;back[i].r);
                  deletehttp(&amp;back[i].r);
                  hts_log_print(opt, LOG_DEBUG,
                                <B><FONT COLOR="#BC8F8F">&quot;file %s%s temporarily left in cache to spare memory&quot;</FONT></B>,
                                back[i].url_adr, back[i].url_fil);
                }
              } <B><FONT COLOR="#A020F0">else</FONT></B> {
                hts_log_print(opt, LOG_WARNING,
                              <B><FONT COLOR="#BC8F8F">&quot;Unexpected html cache lookup error during back clean&quot;</FONT></B>);
              }
              <I><FONT COLOR="#B22222">// xxc xxc
</FONT></I>            }
          }
        }
      }
    } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status == STATUS_ALIVE) {        <I><FONT COLOR="#B22222">// waiting (keep-alive)
</FONT></I>      <B><FONT COLOR="#A020F0">if</FONT></B> (!back[i].r.keep_alive || back[i].r.soc == INVALID_SOCKET
          || back[i].r.keep_alive_max &lt; 1
          || time_local() &gt;= back[i].ka_time_start + back[i].r.keep_alive_t) {
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *reason = <B><FONT COLOR="#BC8F8F">&quot;unknown&quot;</FONT></B>;
        <B><FONT COLOR="#228B22">char</FONT></B> buffer[128];
        <B><FONT COLOR="#A020F0">if</FONT></B> (!back[i].r.keep_alive) {
          reason = <B><FONT COLOR="#BC8F8F">&quot;not keep-alive&quot;</FONT></B>;
        } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.soc == INVALID_SOCKET) {
          reason = <B><FONT COLOR="#BC8F8F">&quot;closed&quot;</FONT></B>;
        } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.keep_alive_max &lt; 1) {
          reason = <B><FONT COLOR="#BC8F8F">&quot;keep-alive-max reached&quot;</FONT></B>;
        } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (time_local() &gt;= back[i].ka_time_start + back[i].r.keep_alive_t) {
          assertf(back[i].ka_time_start != 0);
          snprintf(buffer, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(buffer), <B><FONT COLOR="#BC8F8F">&quot;keep-alive timeout = %ds)&quot;</FONT></B>,
                   (<B><FONT COLOR="#228B22">int</FONT></B>) back[i].r.keep_alive_t);
          reason = buffer;
        }
        hts_log_print(opt, LOG_DEBUG,
                      <B><FONT COLOR="#BC8F8F">&quot;(Keep-Alive): live socket #%d (%s) closed (%s)&quot;</FONT></B>,
                      back[i].r.debugid, back[i].url_adr, reason);
        back_delete(opt, cache, sback, i);      <I><FONT COLOR="#B22222">// delete backing entry
</FONT></I>      }
    }
  }
  <I><FONT COLOR="#B22222">/* switch connections to live ones */</FONT></I>
  <B><FONT COLOR="#A020F0">for</FONT></B>(i = 0; i &lt; back_max; i++) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status == STATUS_READY) {       <I><FONT COLOR="#B22222">// ready
</FONT></I>      <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.soc != INVALID_SOCKET) {
        back_maydeletehttp(opt, cache, sback, i);
      }
    }
  }
  <I><FONT COLOR="#B22222">/* delete sockets if too many keep-alive'd sockets in background */</FONT></I>
  <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;maxsoc &gt; 0) {
    <B><FONT COLOR="#228B22">int</FONT></B> max = opt-&gt;maxsoc + oneMore;
    <B><FONT COLOR="#228B22">int</FONT></B> curr = back_nsoc_overall(sback);

    <B><FONT COLOR="#A020F0">if</FONT></B> (curr &gt; max) {
      hts_log_print(opt, LOG_DEBUG, <B><FONT COLOR="#BC8F8F">&quot;(Keep-Alive): deleting #%d sockets&quot;</FONT></B>,
                    curr - max);
    }
    <B><FONT COLOR="#A020F0">for</FONT></B>(i = 0; i &lt; back_max &amp;&amp; curr &gt; max; i++) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status == STATUS_ALIVE) {
        back_delete(opt, cache, sback, i);      <I><FONT COLOR="#B22222">// delete backing entry
</FONT></I>        curr--;
      }
    }
  }
  <I><FONT COLOR="#B22222">/* transfer ready slots to the storage hashtable */</FONT></I>
  {
    <B><FONT COLOR="#228B22">int</FONT></B> nxfr = back_cleanup_background(opt, cache, sback);

    <B><FONT COLOR="#A020F0">if</FONT></B> (nxfr &gt; 0) {
      hts_log_print(opt, LOG_DEBUG,
                    <B><FONT COLOR="#BC8F8F">&quot;(htsback): %d slots ready moved to background&quot;</FONT></B>, nxfr);
    }
  }
}

<I><FONT COLOR="#B22222">// attente (gestion des buffers des sockets)
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">back_wait</FONT></B>(struct_back * sback, httrackp * opt, cache_back * cache,
               TStamp stat_timestart) {
  <B><FONT COLOR="#228B22">char</FONT></B> catbuff[CATBUFF_SIZE];
  lien_back *<B><FONT COLOR="#228B22">const</FONT></B> back = sback-&gt;lnk;
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> back_max = sback-&gt;count;
  <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i_mod;
  T_SOC nfds = INVALID_SOCKET;
  fd_set fds, fds_c, fds_e;     <I><FONT COLOR="#B22222">// fds pour lecture, connect (write), et erreur
</FONT></I>  <B><FONT COLOR="#228B22">int</FONT></B> nsockets;                 <I><FONT COLOR="#B22222">// nbre sockets
</FONT></I>  LLint max_read_bytes;         <I><FONT COLOR="#B22222">// max bytes read per sockets
</FONT></I>  <B><FONT COLOR="#228B22">struct</FONT></B> timeval tv;
  <B><FONT COLOR="#228B22">int</FONT></B> do_wait = 0;
  <B><FONT COLOR="#228B22">int</FONT></B> gestion_timeout = 0;
  <B><FONT COLOR="#228B22">int</FONT></B> busy_recv = 0;            <I><FONT COLOR="#B22222">// pas de données pour le moment   
</FONT></I>  <B><FONT COLOR="#228B22">int</FONT></B> busy_state = 0;           <I><FONT COLOR="#B22222">// pas de connexions
</FONT></I>  <B><FONT COLOR="#228B22">int</FONT></B> max_loop;                 <I><FONT COLOR="#B22222">// nombre de boucles max à parcourir..
</FONT></I>  <B><FONT COLOR="#228B22">int</FONT></B> max_loop_chk = 0;
  <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> mod_random =
    (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>) (time_local() + HTS_STAT.HTS_TOTAL_RECV);

  <I><FONT COLOR="#B22222">// max. number of loops
</FONT></I>  max_loop = 8;

#<B><FONT COLOR="#5F9EA0">if</FONT></B> 1
  <I><FONT COLOR="#B22222">// Cleanup the stack to save space!
</FONT></I>  back_clean(opt, cache, sback);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

  <I><FONT COLOR="#B22222">// recevoir tant qu'il y a des données (avec un maximum de max_loop boucles)
</FONT></I>  do_wait = 0;
  gestion_timeout = 0;
  <B><FONT COLOR="#A020F0">do</FONT></B> {
    <B><FONT COLOR="#228B22">int</FONT></B> max_c;

    busy_state = busy_recv = 0;

#<B><FONT COLOR="#5F9EA0">if</FONT></B> 0
    check_rate(stat_timestart, opt-&gt;maxrate);   <I><FONT COLOR="#B22222">// vérifier taux de transfert
</FONT></I>#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    <I><FONT COLOR="#B22222">// inscrire les sockets actuelles, et rechercher l'ID la plus élevée
</FONT></I>    FD_ZERO(&amp;fds);
    FD_ZERO(&amp;fds_c);
    FD_ZERO(&amp;fds_e);
    nsockets = 0;
    max_read_bytes = TAILLE_BUFFER;     <I><FONT COLOR="#B22222">// maximum bytes that can be read
</FONT></I>    nfds = INVALID_SOCKET;

    max_c = 1;
    <B><FONT COLOR="#A020F0">for</FONT></B>(i_mod = 0; i_mod &lt; (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>) back_max; i_mod++) {
      <I><FONT COLOR="#B22222">// for(i=0;i&lt;back_max;i++) {
</FONT></I>      <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i = (i_mod + mod_random) % (back_max);

      <I><FONT COLOR="#B22222">// en cas de gestion du connect préemptif
</FONT></I>#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_XCONN</FONT>
      <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status == STATUS_CONNECTING) {        <I><FONT COLOR="#B22222">// connexion
</FONT></I>        do_wait = 1;

        <I><FONT COLOR="#B22222">// noter socket write
</FONT></I>        FD_SET(back[i].r.soc, &amp;fds_c);

        <I><FONT COLOR="#B22222">// noter socket erreur
</FONT></I>        FD_SET(back[i].r.soc, &amp;fds_e);

        <I><FONT COLOR="#B22222">// calculer max
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (max_c) {
          max_c = 0;
          nfds = back[i].r.soc;
        } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.soc &gt; nfds) {
          <I><FONT COLOR="#B22222">// ID socket la plus élevée
</FONT></I>          nfds = back[i].r.soc;
        }

      } <B><FONT COLOR="#A020F0">else</FONT></B>
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_XGETHOST</FONT>
      <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status == STATUS_WAIT_DNS) {  <I><FONT COLOR="#B22222">// attente
</FONT></I>        <I><FONT COLOR="#B22222">// rien à faire..
</FONT></I>      } <B><FONT COLOR="#A020F0">else</FONT></B>
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
        <I><FONT COLOR="#B22222">// poll pour la lecture sur les sockets
</FONT></I>      <B><FONT COLOR="#A020F0">if</FONT></B> ((back[i].status &gt; 0) &amp;&amp; (back[i].status &lt; 100)) {     <I><FONT COLOR="#B22222">// en réception http
</FONT></I>
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">BDEBUG</FONT>==1
        <I><FONT COLOR="#B22222">//printf(&quot;....socket in progress: %d\n&quot;,back[i].r.soc);
</FONT></I>#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
        <I><FONT COLOR="#B22222">// non local et non ftp
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (!back[i].r.is_file) {
          <I><FONT COLOR="#B22222">//## if (back[i].url_adr[0]!=lOCAL_CHAR) {
</FONT></I>
          <I><FONT COLOR="#B22222">// vérification de sécurité
</FONT></I>          <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.soc != INVALID_SOCKET) {        <I><FONT COLOR="#B22222">// hey, you never know..
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B> (
                <I><FONT COLOR="#B22222">// Do not endlessly wait when receiving SSL http data (Patrick Pfeifer)
</FONT></I>#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_USEOPENSSL</FONT>
                !back[i].r.ssl &amp;&amp; 
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
                back[i].status &gt; 0 &amp;&amp; back[i].status &lt; 1000) {
              do_wait = 1;

              <I><FONT COLOR="#B22222">// noter socket read
</FONT></I>              FD_SET(back[i].r.soc, &amp;fds);

              <I><FONT COLOR="#B22222">// noter socket error
</FONT></I>              FD_SET(back[i].r.soc, &amp;fds_e);

              <I><FONT COLOR="#B22222">// incrémenter nombre de sockets
</FONT></I>              nsockets++;

              <I><FONT COLOR="#B22222">// calculer max
</FONT></I>              <B><FONT COLOR="#A020F0">if</FONT></B> (max_c) {
                max_c = 0;
                nfds = back[i].r.soc;
              } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.soc &gt; nfds) {
                <I><FONT COLOR="#B22222">// ID socket la plus élevée
</FONT></I>                nfds = back[i].r.soc;
              }
            }
          } <B><FONT COLOR="#A020F0">else</FONT></B> {
            back[i].r.statuscode = STATUSCODE_CONNERROR;
            <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status == STATUS_CONNECTING)
              strcpybuff(back[i].r.msg, <B><FONT COLOR="#BC8F8F">&quot;Connect Error&quot;</FONT></B>);
            <B><FONT COLOR="#A020F0">else</FONT></B>
              strcpybuff(back[i].r.msg, <B><FONT COLOR="#BC8F8F">&quot;Receive Error&quot;</FONT></B>);
            back[i].status = STATUS_READY;      <I><FONT COLOR="#B22222">// terminé
</FONT></I>            back_set_finished(sback, i);
            hts_log_print(opt, LOG_WARNING,
                          <B><FONT COLOR="#BC8F8F">&quot;Unexpected socket error during pre-loop&quot;</FONT></B>);
          }
        }

      }
    }
    nfds++;

    <B><FONT COLOR="#A020F0">if</FONT></B> (do_wait) {              <I><FONT COLOR="#B22222">// attendre
</FONT></I>      <I><FONT COLOR="#B22222">// temps d'attente max: 2.5 seconde
</FONT></I>      tv.tv_sec = HTS_SOCK_SEC;
      tv.tv_usec = HTS_SOCK_MS;

#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">BDEBUG</FONT>==1
      printf(<B><FONT COLOR="#BC8F8F">&quot;..select\n&quot;</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

      <I><FONT COLOR="#B22222">// poller les sockets-attention au noyau sous Unix..
</FONT></I>#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_WIDE_DEBUG</FONT>
      DEBUG_W(<B><FONT COLOR="#BC8F8F">&quot;select\n&quot;</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
      select((<B><FONT COLOR="#228B22">int</FONT></B>) nfds, &amp;fds, &amp;fds_c, &amp;fds_e, &amp;tv);
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_WIDE_DEBUG</FONT>
      DEBUG_W(<B><FONT COLOR="#BC8F8F">&quot;select done\n&quot;</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    }
    <I><FONT COLOR="#B22222">// maximum data which can be received for a socket, if limited
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B> (nsockets) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;maxrate &gt; 0) {
        max_read_bytes = (check_downloadable_bytes(opt-&gt;maxrate) / nsockets);
        <B><FONT COLOR="#A020F0">if</FONT></B> (max_read_bytes &gt; TAILLE_BUFFER) {
          <I><FONT COLOR="#B22222">/* limit size */</FONT></I>
          max_read_bytes = TAILLE_BUFFER;
        } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (max_read_bytes &lt; TAILLE_BUFFER) {
          <I><FONT COLOR="#B22222">/* a small pause */</FONT></I>
          Sleep(10);
        }
      }
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (!max_read_bytes)
      busy_recv = 0;

    <I><FONT COLOR="#B22222">// recevoir les données arrivées
</FONT></I>    <B><FONT COLOR="#A020F0">for</FONT></B>(i_mod = 0; i_mod &lt; (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>) back_max; i_mod++) {
      <I><FONT COLOR="#B22222">// for(i=0;i&lt;back_max;i++) {
</FONT></I>      <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i = (i_mod + mod_random) % (back_max);

      <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status &gt; 0) {
        <B><FONT COLOR="#A020F0">if</FONT></B> (!back[i].r.is_file) {       <I><FONT COLOR="#B22222">// not file..
</FONT></I>          <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.soc != INVALID_SOCKET) {        <I><FONT COLOR="#B22222">// hey, you never know..
</FONT></I>            <B><FONT COLOR="#228B22">int</FONT></B> err = FD_ISSET(back[i].r.soc, &amp;fds_e);

            <B><FONT COLOR="#A020F0">if</FONT></B> (err) {
              <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.soc != INVALID_SOCKET) {
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_DEBUG_CLOSESOCK</FONT>
                DEBUG_W(<B><FONT COLOR="#BC8F8F">&quot;back_wait: deletehttp\n&quot;</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
                deletehttp(&amp;back[i].r);
              }
              back[i].r.soc = INVALID_SOCKET;
              back[i].r.statuscode = STATUSCODE_CONNERROR;
              <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status == STATUS_CONNECTING)
                strcpybuff(back[i].r.msg, <B><FONT COLOR="#BC8F8F">&quot;Connect Error&quot;</FONT></B>);
              <B><FONT COLOR="#A020F0">else</FONT></B>
                strcpybuff(back[i].r.msg, <B><FONT COLOR="#BC8F8F">&quot;Receive Error&quot;</FONT></B>);
              <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status == STATUS_ALIVE) {     <I><FONT COLOR="#B22222">/* Keep-alive socket */</FONT></I>
                back_delete(opt, cache, sback, i);
              } <B><FONT COLOR="#A020F0">else</FONT></B> {
                back[i].status = STATUS_READY;  <I><FONT COLOR="#B22222">// terminé
</FONT></I>                back_set_finished(sback, i);
              }
            }
          }
        }
      }
      <I><FONT COLOR="#B22222">// ---- FLAG WRITE MIS A UN?: POUR LE CONNECT
</FONT></I>      <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status == STATUS_CONNECTING) {        <I><FONT COLOR="#B22222">// attendre connect
</FONT></I>        <B><FONT COLOR="#228B22">int</FONT></B> dispo = 0;

        <I><FONT COLOR="#B22222">// vérifier l'existance de timeout-check
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (!gestion_timeout)
          <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].timeout &gt; 0)
            gestion_timeout = 1;

        <I><FONT COLOR="#B22222">// connecté?
</FONT></I>        dispo = FD_ISSET(back[i].r.soc, &amp;fds_c);
        <B><FONT COLOR="#A020F0">if</FONT></B> (dispo) {            <I><FONT COLOR="#B22222">// ok connected!!
</FONT></I>          busy_state = 1;

#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_USEOPENSSL</FONT>
          <I><FONT COLOR="#B22222">/* SSL mode */</FONT></I>
          <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.ssl) {
            <I><FONT COLOR="#B22222">// handshake not yet launched
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B> (!back[i].r.ssl_con) {
              SSL_CTX_set_options(openssl_ctx, SSL_OP_ALL);
              <I><FONT COLOR="#B22222">// new session
</FONT></I>              back[i].r.ssl_con = SSL_new(openssl_ctx);
              <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.ssl_con) {
                SSL_clear(back[i].r.ssl_con);
                <B><FONT COLOR="#A020F0">if</FONT></B> (SSL_set_fd(back[i].r.ssl_con, (<B><FONT COLOR="#228B22">int</FONT></B>) back[i].r.soc) == 1) {
                  SSL_set_connect_state(back[i].r.ssl_con);
                  back[i].status = STATUS_SSL_WAIT_HANDSHAKE;   <I><FONT COLOR="#B22222">/* handshake wait */</FONT></I>
                } <B><FONT COLOR="#A020F0">else</FONT></B>
                  back[i].r.statuscode = STATUSCODE_SSL_HANDSHAKE;
              } <B><FONT COLOR="#A020F0">else</FONT></B>
                back[i].r.statuscode = STATUSCODE_SSL_HANDSHAKE;
            }
            <I><FONT COLOR="#B22222">/* Error */</FONT></I>
            <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.statuscode == STATUSCODE_SSL_HANDSHAKE) {
              strcpybuff(back[i].r.msg, <B><FONT COLOR="#BC8F8F">&quot;bad SSL/TLS handshake&quot;</FONT></B>);
              deletehttp(&amp;back[i].r);
              back[i].r.soc = INVALID_SOCKET;
              back[i].r.statuscode = STATUSCODE_NON_FATAL;
              back[i].status = STATUS_READY;
              back_set_finished(sback, i);
            }
          }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">BDEBUG</FONT>==1
          printf(<B><FONT COLOR="#BC8F8F">&quot;..connect ok on socket %d\n&quot;</FONT></B>, back[i].r.soc);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

          <B><FONT COLOR="#A020F0">if</FONT></B> ((back[i].r.soc != INVALID_SOCKET)
              &amp;&amp; (back[i].status == STATUS_CONNECTING)) {
            <I><FONT COLOR="#B22222">/* limit nb. connections/seconds to avoid server overload */</FONT></I>
            <I><FONT COLOR="#B22222">/*if (opt-&gt;maxconn&gt;0) {
               Sleep(1000/opt-&gt;maxconn);
               } */</FONT></I>

            back[i].ka_time_start = time_local();
            <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].timeout &gt; 0) {  <I><FONT COLOR="#B22222">// refresh timeout si besoin est
</FONT></I>              back[i].timeout_refresh = back[i].ka_time_start;
            }
            <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].rateout &gt; 0) {  <I><FONT COLOR="#B22222">// le taux de transfert de base sur le début de la connexion
</FONT></I>              back[i].rateout_time = back[i].ka_time_start;
            }
            <I><FONT COLOR="#B22222">// envoyer header
</FONT></I>            <I><FONT COLOR="#B22222">//if (strcmp(back[i].url_sav,BACK_ADD_TEST)!=0)    // vrai get
</FONT></I>            HTS_STAT.stat_nrequests++;
            <B><FONT COLOR="#A020F0">if</FONT></B> (!back[i].head_request)
              http_sendhead(opt, opt-&gt;cookie, 0, back[i].send_too,
                            back[i].url_adr, back[i].url_fil,
                            back[i].referer_adr, back[i].referer_fil,
                            &amp;back[i].r);
            <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].head_request == 2) <I><FONT COLOR="#B22222">// test en GET!
</FONT></I>              http_sendhead(opt, opt-&gt;cookie, 0, back[i].send_too,
                            back[i].url_adr, back[i].url_fil,
                            back[i].referer_adr, back[i].referer_fil,
                            &amp;back[i].r);
            <B><FONT COLOR="#A020F0">else</FONT></B>                <I><FONT COLOR="#B22222">// test!
</FONT></I>              http_sendhead(opt, opt-&gt;cookie, 1, back[i].send_too,
                            back[i].url_adr, back[i].url_fil,
                            back[i].referer_adr, back[i].referer_fil,
                            &amp;back[i].r);
            back[i].status = STATUS_WAIT_HEADERS;        <I><FONT COLOR="#B22222">// attendre en tête maintenant
</FONT></I>          }
        }
        <I><FONT COLOR="#B22222">// attente gethostbyname
</FONT></I>      }
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_USEOPENSSL</FONT>
      <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status == STATUS_SSL_WAIT_HANDSHAKE) {       <I><FONT COLOR="#B22222">// wait for SSL handshake
</FONT></I>        <I><FONT COLOR="#B22222">/* SSL mode */</FONT></I>
        <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.ssl) {
          <B><FONT COLOR="#228B22">int</FONT></B> conn_code;

          <B><FONT COLOR="#A020F0">if</FONT></B> ((conn_code = SSL_connect(back[i].r.ssl_con)) &lt;= 0) {
            <I><FONT COLOR="#B22222">/* non blocking I/O, will retry */</FONT></I>
            <B><FONT COLOR="#228B22">int</FONT></B> err_code = SSL_get_error(back[i].r.ssl_con, conn_code);

            <B><FONT COLOR="#A020F0">if</FONT></B> ((err_code != SSL_ERROR_WANT_READ)
                &amp;&amp; (err_code != SSL_ERROR_WANT_WRITE)
              ) {
              <B><FONT COLOR="#228B22">char</FONT></B> tmp[256];

              tmp[0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
              ERR_error_string(err_code, tmp);
              back[i].r.msg[0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
              strncatbuff(back[i].r.msg, tmp, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(back[i].r.msg) - 2);
              <B><FONT COLOR="#A020F0">if</FONT></B> (!strnotempty(back[i].r.msg)) {
                sprintf(back[i].r.msg, <B><FONT COLOR="#BC8F8F">&quot;SSL/TLS error %d&quot;</FONT></B>, err_code);
              }
              deletehttp(&amp;back[i].r);
              back[i].r.soc = INVALID_SOCKET;
              back[i].r.statuscode = STATUSCODE_NON_FATAL;
              back[i].status = STATUS_READY;
              back_set_finished(sback, i);
            }
          } <B><FONT COLOR="#A020F0">else</FONT></B> {              <I><FONT COLOR="#B22222">/* got it! */</FONT></I>
            back[i].status = STATUS_CONNECTING; <I><FONT COLOR="#B22222">// back to waitconnect
</FONT></I>          }
        } <B><FONT COLOR="#A020F0">else</FONT></B> {
          strcpybuff(back[i].r.msg, <B><FONT COLOR="#BC8F8F">&quot;unexpected SSL/TLS error&quot;</FONT></B>);
          deletehttp(&amp;back[i].r);
          back[i].r.soc = INVALID_SOCKET;
          back[i].r.statuscode = STATUSCODE_NON_FATAL;
          back[i].status = STATUS_READY;
          back_set_finished(sback, i);
        }

      }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_XGETHOST</FONT>
      <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status == STATUS_WAIT_DNS) {     <I><FONT COLOR="#B22222">// attendre gethostbyname
</FONT></I>#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">DEBUGDNS</FONT>
        <I><FONT COLOR="#B22222">//printf(&quot;status 101 for %s\n&quot;,back[i].url_adr);
</FONT></I>#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

        <B><FONT COLOR="#A020F0">if</FONT></B> (!gestion_timeout)
          <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].timeout &gt; 0)
            gestion_timeout = 1;

        <B><FONT COLOR="#A020F0">if</FONT></B> (host_wait(opt, &amp;back[i])) { <I><FONT COLOR="#B22222">// prêt
</FONT></I>          back[i].status = STATUS_CONNECTING;   <I><FONT COLOR="#B22222">// attente connexion
</FONT></I>          <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].timeout &gt; 0) {    <I><FONT COLOR="#B22222">// refresh timeout si besoin est
</FONT></I>            back[i].timeout_refresh = time_local();
          }
          <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].rateout &gt; 0) {    <I><FONT COLOR="#B22222">// le taux de transfert de base sur le début de la connexion
</FONT></I>            back[i].rateout_time = time_local();
          }

          back[i].r.soc =
            http_xfopen(opt, 0, 0, 0, back[i].send_too, back[i].url_adr,
                        back[i].url_fil, &amp;(back[i].r));
          <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.soc == INVALID_SOCKET) {
            back[i].status = STATUS_READY;      <I><FONT COLOR="#B22222">// fini, erreur
</FONT></I>            back_set_finished(sback, i);
            <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.soc != INVALID_SOCKET) {
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_DEBUG_CLOSESOCK</FONT>
              DEBUG_W(<B><FONT COLOR="#BC8F8F">&quot;back_wait(2): deletehttp\n&quot;</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
              deletehttp(&amp;back[i].r);
            }
            back[i].r.soc = INVALID_SOCKET;
            back[i].r.statuscode = STATUSCODE_NON_FATAL;
            <B><FONT COLOR="#A020F0">if</FONT></B> (strnotempty(back[i].r.msg) == 0)
              strcpybuff(back[i].r.msg, <B><FONT COLOR="#BC8F8F">&quot;Unable to resolve host name&quot;</FONT></B>);
          }
        }

        <I><FONT COLOR="#B22222">// ---- FLAG READ MIS A UN?: POUR LA RECEPTION
</FONT></I>      }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">USE_BEGINTHREAD</FONT>
      <I><FONT COLOR="#B22222">// ..rien à faire, c'est magic les threads
</FONT></I>#<B><FONT COLOR="#5F9EA0">else</FONT></B>
      <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status == STATUS_FTP_TRANSFER) { <I><FONT COLOR="#B22222">// en réception ftp
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (!fexist(back[i].location_buffer)) { <I><FONT COLOR="#B22222">// terminé
</FONT></I>          FILE *fp;

          fp =
            FOPEN(fconcat(OPT_GET_BUFF(opt), back[i].location_buffer, <B><FONT COLOR="#BC8F8F">&quot;.ok&quot;</FONT></B>),
                  <B><FONT COLOR="#BC8F8F">&quot;rb&quot;</FONT></B>);
          <B><FONT COLOR="#A020F0">if</FONT></B> (fp) {
            <B><FONT COLOR="#228B22">int</FONT></B> j = 0;

            fscanf(fp, <B><FONT COLOR="#BC8F8F">&quot;%d &quot;</FONT></B>, &amp;(back[i].r.statuscode));
            <B><FONT COLOR="#A020F0">while</FONT></B>(!feof(fp)) {
              <B><FONT COLOR="#228B22">int</FONT></B> c = fgetc(fp);

              <B><FONT COLOR="#A020F0">if</FONT></B> (c != EOF)
                back[i].r.msg[j++] = c;
            }
            back[i].r.msg[j++] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
            fclose(fp);
            UNLINK(fconcat(OPT_GET_BUFF(opt), back[i].location_buffer, <B><FONT COLOR="#BC8F8F">&quot;.ok&quot;</FONT></B>));
            strcpybuff(fconcat
                       (OPT_GET_BUFF(opt), back[i].location_buffer, <B><FONT COLOR="#BC8F8F">&quot;.ok&quot;</FONT></B>), <B><FONT COLOR="#BC8F8F">&quot;&quot;</FONT></B>);
          } <B><FONT COLOR="#A020F0">else</FONT></B> {
            strcpybuff(back[i].r.msg,
                       <B><FONT COLOR="#BC8F8F">&quot;Unknown ftp result, check if file is ok&quot;</FONT></B>);
            back[i].r.statuscode = STATUSCODE_INVALID;
          }
          back[i].status = STATUS_READY;
          back_set_finished(sback, i);
          <I><FONT COLOR="#B22222">// finalize transfer
</FONT></I>          <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.statuscode &gt; 0) {
            hts_log_print(opt, LOG_TRACE, <B><FONT COLOR="#BC8F8F">&quot;finalizing ftp&quot;</FONT></B>);
            back_finalize(opt, cache, sback, i);
          }
        }
      }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
      <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status == STATUS_FTP_READY) {    <I><FONT COLOR="#B22222">// ftp ready
</FONT></I>        back[i].status = STATUS_READY;
        back_set_finished(sback, i);
        <I><FONT COLOR="#B22222">// finalize transfer
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.statuscode &gt; 0) {
          hts_log_print(opt, LOG_TRACE, <B><FONT COLOR="#BC8F8F">&quot;finalizing ftp&quot;</FONT></B>);
          back_finalize(opt, cache, sback, i);
        }
      } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> ((back[i].status &gt; 0) &amp;&amp; (back[i].status &lt; 1000)) {     <I><FONT COLOR="#B22222">// en réception http
</FONT></I>        <B><FONT COLOR="#228B22">int</FONT></B> dispo = 0;

        <I><FONT COLOR="#B22222">// vérifier l'existance de timeout-check
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (!gestion_timeout)
          <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].timeout &gt; 0)
            gestion_timeout = 1;

        <I><FONT COLOR="#B22222">// données dispo?
</FONT></I>        <I><FONT COLOR="#B22222">//## if (back[i].url_adr[0]!=lOCAL_CHAR)
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.is_file)
          dispo = 1;
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_USEOPENSSL</FONT>
        <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.ssl)
          dispo = 1;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
        <B><FONT COLOR="#A020F0">else</FONT></B>
          dispo = FD_ISSET(back[i].r.soc, &amp;fds);

        <I><FONT COLOR="#B22222">// Check transfer rate!
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (!max_read_bytes)
          dispo = 0;            <I><FONT COLOR="#B22222">// limit transfer rate
</FONT></I>
        <B><FONT COLOR="#A020F0">if</FONT></B> (dispo) {            <I><FONT COLOR="#B22222">// données dispo
</FONT></I>          LLint retour_fread;

          busy_recv = 1;        <I><FONT COLOR="#B22222">// on récupère encore
</FONT></I>#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">BDEBUG</FONT>==1
          printf(<B><FONT COLOR="#BC8F8F">&quot;..data available on socket %d\n&quot;</FONT></B>, back[i].r.soc);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

          <I><FONT COLOR="#B22222">// range size hack old location
</FONT></I>
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_DIRECTDISK</FONT>
          <I><FONT COLOR="#B22222">// Court-circuit:
</FONT></I>          <I><FONT COLOR="#B22222">// Peut-on stocker le fichier directement sur disque?
</FONT></I>          <I><FONT COLOR="#B22222">// Ahh que ca serait vachement mieux et que ahh que la mémoire vous dit merci!
</FONT></I>          <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.is_write == 0) {      <I><FONT COLOR="#B22222">// mode mémoire
</FONT></I>              <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.adr == NULL) {      <I><FONT COLOR="#B22222">// rien n'a été écrit
</FONT></I>                <B><FONT COLOR="#A020F0">if</FONT></B> (!back[i].testmode) {        <I><FONT COLOR="#B22222">// pas mode test
</FONT></I>                  <B><FONT COLOR="#A020F0">if</FONT></B> (strnotempty(back[i].url_sav)) {
                    <B><FONT COLOR="#A020F0">if</FONT></B> (strcmp(back[i].url_fil, <B><FONT COLOR="#BC8F8F">&quot;/robots.txt&quot;</FONT></B>)) {
                      <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.statuscode == HTTP_OK) {    <I><FONT COLOR="#B22222">// 'OK'
</FONT></I>                        <B><FONT COLOR="#A020F0">if</FONT></B> (!is_hypertext_mime(opt, back[i].r.contenttype, back[i].url_fil)) {  <I><FONT COLOR="#B22222">// pas HTML
</FONT></I>                          <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;getmode &amp; 2) {       <I><FONT COLOR="#B22222">// on peut ecrire des non html
</FONT></I>                            <B><FONT COLOR="#228B22">int</FONT></B> fcheck = 0;
                            <B><FONT COLOR="#228B22">int</FONT></B> last_errno = 0;

                            back[i].r.is_write = 1;     <I><FONT COLOR="#B22222">// écrire
</FONT></I>                            <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.compressed &amp;&amp;
                                <I><FONT COLOR="#B22222">/* .gz are *NOT* depacked!! */</FONT></I>
                                strfield(get_ext(catbuff, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(catbuff), back[i].url_sav), <B><FONT COLOR="#BC8F8F">&quot;gz&quot;</FONT></B>) == 0
                                &amp;&amp; strfield(get_ext(catbuff, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(catbuff), back[i].url_sav), <B><FONT COLOR="#BC8F8F">&quot;tgz&quot;</FONT></B>) == 0
                              ) {
                              <B><FONT COLOR="#A020F0">if</FONT></B> (create_back_tmpfile(opt, &amp;back[i]) == 0) {
                                assertf(back[i].tmpfile != NULL);
                                <I><FONT COLOR="#B22222">/* note: tmpfile is utf-8 */</FONT></I>
                                <B><FONT COLOR="#A020F0">if</FONT></B> ((back[i].r.out =
                                     FOPEN(back[i].tmpfile, <B><FONT COLOR="#BC8F8F">&quot;wb&quot;</FONT></B>)) == NULL) {
                                  last_errno = errno;
                                }
                              }
                            } <B><FONT COLOR="#A020F0">else</FONT></B> {
                              file_notify(opt, back[i].url_adr, back[i].url_fil,
                                          back[i].url_sav, 1, 1,
                                          back[i].r.notmodified);
                              back[i].r.compressed = 0;
                              <B><FONT COLOR="#A020F0">if</FONT></B> ((back[i].r.out =
                                   filecreate(&amp;opt-&gt;state.strc,
                                              back[i].url_sav)) == NULL) {
                                last_errno = errno;
                              }
                            }
                            <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.out == NULL) {
                              errno = last_errno;
                              <B><FONT COLOR="#A020F0">if</FONT></B> ((fcheck = check_fatal_io_errno())) {
                                hts_log_print(opt, LOG_ERROR,
                                              <B><FONT COLOR="#BC8F8F">&quot;Mirror aborted: disk full or filesystem problems&quot;</FONT></B>);
                                opt-&gt;state.exit_xh = -1;        <I><FONT COLOR="#B22222">/* fatal error */</FONT></I>
                              }
                            }
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HDEBUG</FONT>
                            printf(<B><FONT COLOR="#BC8F8F">&quot;direct-disk: %s\n&quot;</FONT></B>, back[i].url_sav);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
                            hts_log_print(opt, LOG_DEBUG,
                                          <B><FONT COLOR="#BC8F8F">&quot;File received from net to disk: %s%s&quot;</FONT></B>,
                                          back[i].url_adr, back[i].url_fil);

                            <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.out == NULL) {
                              hts_log_print(opt, LOG_ERROR | LOG_ERRNO,
                                            <B><FONT COLOR="#BC8F8F">&quot;Unable to save file %s&quot;</FONT></B>,
                                            back[i].url_sav);
                              <B><FONT COLOR="#A020F0">if</FONT></B> (fcheck) {
                                hts_log_print(opt, LOG_ERROR,
                                              <B><FONT COLOR="#BC8F8F">&quot;* * Fatal write error, giving up&quot;</FONT></B>);
                              }
                              back[i].r.is_write = 0;   <I><FONT COLOR="#B22222">// erreur, abandonner
</FONT></I>                              back[i].status = STATUS_READY;      <I><FONT COLOR="#B22222">// terminé
</FONT></I>                              back_set_finished(sback, i);
                              <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.soc != INVALID_SOCKET) {
                                deletehttp(&amp;back[i].r);
                                back[i].r.soc = INVALID_SOCKET;
                              }
                            } <B><FONT COLOR="#A020F0">else</FONT></B> {
#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">_WIN32</FONT>
                              chmod(back[i].url_sav, HTS_ACCESS_FILE);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
                              <I><FONT COLOR="#B22222">/* create a temporary reference file in case of broken mirror */</FONT></I>
                              <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.out != NULL &amp;&amp; opt-&gt;cache != 0) {
                                <B><FONT COLOR="#A020F0">if</FONT></B> (back_serialize_ref(opt, &amp;back[i]) != 0) {
                                  hts_log_print(opt, LOG_WARNING,
                                                <B><FONT COLOR="#BC8F8F">&quot;Could not create temporary reference file for %s%s&quot;</FONT></B>,
                                                back[i].url_adr,
                                                back[i].url_fil);
                                }
                              }
                            }
                          } <B><FONT COLOR="#A020F0">else</FONT></B> {      <I><FONT COLOR="#B22222">// on coupe tout!
</FONT></I>                            hts_log_print(opt, LOG_DEBUG,
                                          <B><FONT COLOR="#BC8F8F">&quot;File cancelled (non HTML): %s%s&quot;</FONT></B>,
                                          back[i].url_adr, back[i].url_fil);
                            back[i].status = STATUS_READY;      <I><FONT COLOR="#B22222">// terminé
</FONT></I>                            back_set_finished(sback, i);
                            <B><FONT COLOR="#A020F0">if</FONT></B> (!back[i].testmode)
                              back[i].r.statuscode = STATUSCODE_INVALID;        <I><FONT COLOR="#B22222">// EUHH CANCEL
</FONT></I>                            <B><FONT COLOR="#A020F0">else</FONT></B>
                              back[i].r.statuscode = STATUSCODE_TEST_OK;        <I><FONT COLOR="#B22222">// &quot;TEST OK&quot;
</FONT></I>                            <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.soc != INVALID_SOCKET) {
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_DEBUG_CLOSESOCK</FONT>
                              DEBUG_W(<B><FONT COLOR="#BC8F8F">&quot;back_wait(3): deletehttp\n&quot;</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
                              deletehttp(&amp;back[i].r);
                            }
                            back[i].r.soc = INVALID_SOCKET;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

          <I><FONT COLOR="#B22222">// réception de données depuis socket ou fichier
</FONT></I>          <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status == STATUS_WAIT_HEADERS)  <I><FONT COLOR="#B22222">// recevoir par bloc de lignes
</FONT></I>              retour_fread = http_xfread1(&amp;(back[i].r), 0);
            <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status == STATUS_CHUNK_WAIT || back[i].status == STATUS_CHUNK_CR) {        <I><FONT COLOR="#B22222">// recevoir longueur chunk en hexa caractère par caractère
</FONT></I>              <I><FONT COLOR="#B22222">// backuper pour lire dans le buffer chunk
</FONT></I>              htsblk r;

              memcpy(&amp;r, &amp;(back[i].r), <B><FONT COLOR="#A020F0">sizeof</FONT></B>(htsblk));
              back[i].r.is_write = 0;   <I><FONT COLOR="#B22222">// mémoire
</FONT></I>              back[i].r.adr = back[i].chunk_adr;        <I><FONT COLOR="#B22222">// adresse
</FONT></I>              back[i].r.size = back[i].chunk_size;      <I><FONT COLOR="#B22222">// taille taille chunk
</FONT></I>              back[i].r.totalsize = -1; <I><FONT COLOR="#B22222">// total inconnu
</FONT></I>              back[i].r.out = NULL;
              back[i].r.is_file = 0;
              <I><FONT COLOR="#B22222">//
</FONT></I>              <I><FONT COLOR="#B22222">// ligne par ligne
</FONT></I>              retour_fread = http_xfread1(&amp;(back[i].r), -1);
              <I><FONT COLOR="#B22222">// modifier et restaurer
</FONT></I>              back[i].chunk_adr = back[i].r.adr;        <I><FONT COLOR="#B22222">// adresse
</FONT></I>              back[i].chunk_size = back[i].r.size;      <I><FONT COLOR="#B22222">// taille taille chunk
</FONT></I>              memcpy(&amp;(back[i].r), &amp;r, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(htsblk)); <I><FONT COLOR="#B22222">// restaurer véritable r
</FONT></I>            } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].is_chunk) {      <I><FONT COLOR="#B22222">// attention chunk, limiter taille à lire
</FONT></I>#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">CHUNKDEBUG</FONT>==1
              printf(<B><FONT COLOR="#BC8F8F">&quot;[%d] read %d bytes\n&quot;</FONT></B>, (<B><FONT COLOR="#228B22">int</FONT></B>) back[i].r.soc,
                     (<B><FONT COLOR="#228B22">int</FONT></B>) min(back[i].r.totalsize - back[i].r.size,
                               max_read_bytes));
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
              retour_fread =
                (<B><FONT COLOR="#228B22">int</FONT></B>) http_xfread1(&amp;(back[i].r),
                                   (<B><FONT COLOR="#228B22">int</FONT></B>) min(back[i].r.totalsize -
                                             back[i].r.size, max_read_bytes));
            } <B><FONT COLOR="#A020F0">else</FONT></B>
              retour_fread =
                (<B><FONT COLOR="#228B22">int</FONT></B>) http_xfread1(&amp;(back[i].r), (<B><FONT COLOR="#228B22">int</FONT></B>) max_read_bytes);
          } <B><FONT COLOR="#A020F0">else</FONT></B>
            retour_fread = READ_EOF;    <I><FONT COLOR="#B22222">// interruption ou annulation interne (peut ne pas être une erreur)
</FONT></I>
          <I><FONT COLOR="#B22222">// Si réception chunk, tester si on est pas à la fin!
</FONT></I>          <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status == 1) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].is_chunk) {     <I><FONT COLOR="#B22222">// attendre prochain chunk
</FONT></I>              <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.size == back[i].r.totalsize) {      <I><FONT COLOR="#B22222">// fin chunk!
</FONT></I>                <I><FONT COLOR="#B22222">//printf(&quot;chunk end at %d\n&quot;,back[i].r.size);
</FONT></I>                back[i].status = STATUS_CHUNK_CR;       <I><FONT COLOR="#B22222">/* fetch ending CRLF */</FONT></I>
                <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].chunk_adr != NULL) {
                  freet(back[i].chunk_adr);
                  back[i].chunk_adr = NULL;
                }
                back[i].chunk_size = 0;
                retour_fread = 0;       <I><FONT COLOR="#B22222">// pas d'erreur
</FONT></I>#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">CHUNKDEBUG</FONT>==1
                printf(<B><FONT COLOR="#BC8F8F">&quot;[%d] waiting for current chunk CRLF..\n&quot;</FONT></B>,
                       (<B><FONT COLOR="#228B22">int</FONT></B>) back[i].r.soc);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
              }
            } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.keep_alive) {
              <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.size == back[i].r.totalsize) {      <I><FONT COLOR="#B22222">// fin!
</FONT></I>                retour_fread = READ_EOF;        <I><FONT COLOR="#B22222">// end
</FONT></I>              }
            }
          }

          <B><FONT COLOR="#A020F0">if</FONT></B> (retour_fread &lt; 0) {       <I><FONT COLOR="#B22222">// fin réception
</FONT></I>            back[i].status = STATUS_READY;      <I><FONT COLOR="#B22222">// terminé
</FONT></I>            back_set_finished(sback, i);
            <I><FONT COLOR="#B22222">/*KA back[i].r.soc=INVALID_SOCKET; */</FONT></I>
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">CHUNKDEBUG</FONT>==1
            <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].is_chunk)
              printf
                (<B><FONT COLOR="#BC8F8F">&quot;[%d] must be the last chunk for %s (connection closed) - %d/%d\n&quot;</FONT></B>,
                 (<B><FONT COLOR="#228B22">int</FONT></B>) back[i].r.soc, back[i].url_fil, back[i].r.size,
                 back[i].r.totalsize);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
            <B><FONT COLOR="#A020F0">if</FONT></B> (retour_fread &lt; 0 &amp;&amp; retour_fread != READ_EOF) {
              <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.size &gt; 0)
                strcpybuff(back[i].r.msg, <B><FONT COLOR="#BC8F8F">&quot;Interrupted transfer&quot;</FONT></B>);
              <B><FONT COLOR="#A020F0">else</FONT></B>
                strcpybuff(back[i].r.msg, <B><FONT COLOR="#BC8F8F">&quot;No data (connection closed)&quot;</FONT></B>);
              back[i].r.statuscode = STATUSCODE_CONNERROR;
            } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> ((back[i].r.statuscode &lt;= 0)
                       &amp;&amp; (strnotempty(back[i].r.msg) == 0)) {
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HDEBUG</FONT>
              printf(<B><FONT COLOR="#BC8F8F">&quot;error interruped: %s\n&quot;</FONT></B>, back[i].r.adr);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
              <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.size &gt; 0)
                strcpybuff(back[i].r.msg, <B><FONT COLOR="#BC8F8F">&quot;Interrupted transfer&quot;</FONT></B>);
              <B><FONT COLOR="#A020F0">else</FONT></B>
                strcpybuff(back[i].r.msg, <B><FONT COLOR="#BC8F8F">&quot;No data (connection closed)&quot;</FONT></B>);
              back[i].r.statuscode = STATUSCODE_CONNERROR;
            }
            <I><FONT COLOR="#B22222">// Close socket
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.soc != INVALID_SOCKET) {
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_DEBUG_CLOSESOCK</FONT>
              DEBUG_W(<B><FONT COLOR="#BC8F8F">&quot;back_wait(4): deletehttp\n&quot;</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
              <I><FONT COLOR="#B22222">/*KA deletehttp(&amp;back[i].r); */</FONT></I>
              back_maydeletehttp(opt, cache, sback, i);
            }
            <I><FONT COLOR="#B22222">// finalize transfer
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.statuscode &gt; 0 &amp;&amp; !IS_DELAYED_EXT(back[i].url_sav)
              ) {
              hts_log_print(opt, LOG_TRACE, <B><FONT COLOR="#BC8F8F">&quot;finalizing regular file&quot;</FONT></B>);
              back_finalize(opt, cache, sback, i);
            }

            <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.totalsize &gt;= 0) {     <I><FONT COLOR="#B22222">// tester totalsize
</FONT></I>              <I><FONT COLOR="#B22222">//if ((back[i].r.totalsize&gt;=0) &amp;&amp; (back[i].status==STATUS_WAIT_HEADERS)) {    // tester totalsize
</FONT></I>              <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.totalsize != back[i].r.size) {      <I><FONT COLOR="#B22222">// pas la même!
</FONT></I>                <B><FONT COLOR="#A020F0">if</FONT></B> (!opt-&gt;tolerant) {
                  <I><FONT COLOR="#B22222">//#if HTS_CL_IS_FATAL
</FONT></I>                  deleteaddr(&amp;back[i].r);
                  <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.size &lt; back[i].r.totalsize)
                    back[i].r.statuscode = STATUSCODE_CONNERROR;        <I><FONT COLOR="#B22222">// recatch
</FONT></I>                  sprintf(back[i].r.msg,
                          <B><FONT COLOR="#BC8F8F">&quot;Incorrect length (&quot;</FONT></B> LLintP <B><FONT COLOR="#BC8F8F">&quot; Bytes, &quot;</FONT></B> LLintP
                          <B><FONT COLOR="#BC8F8F">&quot; expected)&quot;</FONT></B>, (LLint) back[i].r.size,
                          (LLint) back[i].r.totalsize);
                } <B><FONT COLOR="#A020F0">else</FONT></B> {
                  <I><FONT COLOR="#B22222">//#else
</FONT></I>                  <I><FONT COLOR="#B22222">// Un warning suffira..
</FONT></I>                  hts_log_print(opt, LOG_WARNING,
                                <B><FONT COLOR="#BC8F8F">&quot;Incorrect length (&quot;</FONT></B> LLintP <B><FONT COLOR="#BC8F8F">&quot;!=&quot;</FONT></B> LLintP
                                <B><FONT COLOR="#BC8F8F">&quot; expected) for %s%s&quot;</FONT></B>, (LLint) back[i].r.size,
                                (LLint) back[i].r.totalsize, back[i].url_adr,
                                back[i].url_fil);
                  <I><FONT COLOR="#B22222">//#endif
</FONT></I>                }
              }
            }
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">BDEBUG</FONT>==1
            printf(<B><FONT COLOR="#BC8F8F">&quot;transfer ok\n&quot;</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
          } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (retour_fread &gt; 0) {        <I><FONT COLOR="#B22222">// pas d'erreur de réception et data
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].timeout &gt; 0) {  <I><FONT COLOR="#B22222">// refresh timeout si besoin est
</FONT></I>              back[i].timeout_refresh = time_local();
            }
            <I><FONT COLOR="#B22222">// Traitement des en têtes chunks ou en têtes
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status == STATUS_CHUNK_WAIT || back[i].status == STATUS_CHUNK_CR) {     <I><FONT COLOR="#B22222">// réception taille chunk en hexa (  après les en têtes, peut ne pas
</FONT></I>              <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].chunk_size &gt; 0
                  &amp;&amp; back[i].chunk_adr[back[i].chunk_size - 1] == 10) {
                <B><FONT COLOR="#228B22">int</FONT></B> chunk_size = -1;
                <B><FONT COLOR="#228B22">char</FONT></B> chunk_data[64];

                <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].chunk_size &lt; 32) {  <I><FONT COLOR="#B22222">// pas trop gros
</FONT></I>                  <B><FONT COLOR="#228B22">char</FONT></B> *chstrip = back[i].chunk_adr;

                  back[i].chunk_adr[back[i].chunk_size - 1] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;     <I><FONT COLOR="#B22222">// octet nul 
</FONT></I>                  <I><FONT COLOR="#B22222">// skip leading spaces or cr
</FONT></I>                  <B><FONT COLOR="#A020F0">while</FONT></B>(isspace(*chstrip))
                    chstrip++;
                  chunk_data[0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
                  strncatbuff(chunk_data, chstrip, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(chunk_data) - 2);
                  <I><FONT COLOR="#B22222">// strip chunk-extension
</FONT></I>                  <B><FONT COLOR="#A020F0">while</FONT></B>((chstrip = strchr(chunk_data, <B><FONT COLOR="#BC8F8F">';'</FONT></B>)))
                    *chstrip = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
                  <B><FONT COLOR="#A020F0">while</FONT></B>((chstrip = strchr(chunk_data, <B><FONT COLOR="#BC8F8F">' '</FONT></B>)))
                    *chstrip = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
                  <B><FONT COLOR="#A020F0">while</FONT></B>((chstrip = strchr(chunk_data, <B><FONT COLOR="#BC8F8F">'\r'</FONT></B>)))
                    *chstrip = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">CHUNKDEBUG</FONT>==1
                  printf(<B><FONT COLOR="#BC8F8F">&quot;[%d] chunk received and read: %s\n&quot;</FONT></B>,
                         (<B><FONT COLOR="#228B22">int</FONT></B>) back[i].r.soc, chunk_data);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
                  <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.totalsize &lt; 0)
                    back[i].r.totalsize = 0;    <I><FONT COLOR="#B22222">// initialiser à 0 (-1 == unknown)
</FONT></I>                  <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status == STATUS_CHUNK_WAIT) {    <I><FONT COLOR="#B22222">// &quot;real&quot; chunk
</FONT></I>                    <B><FONT COLOR="#A020F0">if</FONT></B> (sscanf(chunk_data, <B><FONT COLOR="#BC8F8F">&quot;%x&quot;</FONT></B>, &amp;chunk_size) == 1) {
                      <B><FONT COLOR="#A020F0">if</FONT></B> (chunk_size &gt; 0)
                        back[i].chunk_blocksize = chunk_size;   <I><FONT COLOR="#B22222">/* the data block chunk size */</FONT></I>
                      <B><FONT COLOR="#A020F0">else</FONT></B>
                        back[i].chunk_blocksize = -1;   <I><FONT COLOR="#B22222">/* ending */</FONT></I>
                      back[i].r.totalsize += chunk_size;        <I><FONT COLOR="#B22222">// noter taille
</FONT></I>                      <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.adr != NULL || !back[i].r.is_write) {       <I><FONT COLOR="#B22222">// Not to disk
</FONT></I>                        back[i].r.adr =
                          (<B><FONT COLOR="#228B22">char</FONT></B> *) realloct(back[i].r.adr,
                                            (size_t) back[i].r.totalsize + 1);
                        <B><FONT COLOR="#A020F0">if</FONT></B> (!back[i].r.adr) {
                          <B><FONT COLOR="#A020F0">if</FONT></B> (cache-&gt;log != NULL) {
                            hts_log_print(opt, LOG_ERROR,
                                          <B><FONT COLOR="#BC8F8F">&quot;not enough memory (&quot;</FONT></B> LLintP
                                          <B><FONT COLOR="#BC8F8F">&quot;) for %s%s&quot;</FONT></B>,
                                          (LLint) back[i].r.totalsize,
                                          back[i].url_adr, back[i].url_fil);
                          }
                        }
                      }
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">CHUNKDEBUG</FONT>==1
                      printf(<B><FONT COLOR="#BC8F8F">&quot;[%d] chunk length: %d - next total &quot;</FONT></B> LLintP <B><FONT COLOR="#BC8F8F">&quot;:\n&quot;</FONT></B>,
                             (<B><FONT COLOR="#228B22">int</FONT></B>) back[i].r.soc, (<B><FONT COLOR="#228B22">int</FONT></B>) chunk_size,
                             (LLint) back[i].r.totalsize);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
                    } <B><FONT COLOR="#A020F0">else</FONT></B> {
                      hts_log_print(opt, LOG_WARNING,
                                    <B><FONT COLOR="#BC8F8F">&quot;Illegal chunk (%s) for %s%s&quot;</FONT></B>,
                                    back[i].chunk_adr, back[i].url_adr,
                                    back[i].url_fil);
                    }
                  } <B><FONT COLOR="#A020F0">else</FONT></B> {      <I><FONT COLOR="#B22222">/* back[i].status==STATUS_CHUNK_CR : just receiving ending CRLF after data */</FONT></I>
                    <B><FONT COLOR="#A020F0">if</FONT></B> (chunk_data[0] == <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>) {
                      <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].chunk_blocksize &gt; 0)
                        chunk_size = (<B><FONT COLOR="#228B22">int</FONT></B>) back[i].chunk_blocksize;     <I><FONT COLOR="#B22222">/* recent data chunk size */</FONT></I>
                      <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].chunk_blocksize == -1)
                        chunk_size = 0; <I><FONT COLOR="#B22222">/* ending chunk */</FONT></I>
                      <B><FONT COLOR="#A020F0">else</FONT></B>
                        chunk_size = 1; <I><FONT COLOR="#B22222">/* fake positive size for 1st chunk history */</FONT></I>
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">CHUNKDEBUG</FONT>==1
                      printf(<B><FONT COLOR="#BC8F8F">&quot;[%d] chunk CRLF seen\n&quot;</FONT></B>, (<B><FONT COLOR="#228B22">int</FONT></B>) back[i].r.soc);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
                    } <B><FONT COLOR="#A020F0">else</FONT></B> {
                      hts_log_print(opt, LOG_WARNING,
                                    <B><FONT COLOR="#BC8F8F">&quot;illegal chunk CRLF (%s) for %s%s&quot;</FONT></B>,
                                    back[i].chunk_adr, back[i].url_adr,
                                    back[i].url_fil);
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">CHUNKDEBUG</FONT>==1
                      printf(<B><FONT COLOR="#BC8F8F">&quot;[%d] chunk CRLF ERROR!! : '%s'\n&quot;</FONT></B>,
                             (<B><FONT COLOR="#228B22">int</FONT></B>) back[i].r.soc, chunk_data);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
                    }
                  }
                } <B><FONT COLOR="#A020F0">else</FONT></B> {
                  hts_log_print(opt, LOG_WARNING,
                                <B><FONT COLOR="#BC8F8F">&quot;chunk too big (&quot;</FONT></B> LLintP <B><FONT COLOR="#BC8F8F">&quot;) for %s%s&quot;</FONT></B>,
                                (LLint) back[i].chunk_size, back[i].url_adr,
                                back[i].url_fil);
                }

                <I><FONT COLOR="#B22222">// ok, continuer sur le body
</FONT></I>
                <I><FONT COLOR="#B22222">// si chunk non nul continuer (ou commencer)
</FONT></I>                <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status == STATUS_CHUNK_CR &amp;&amp; chunk_size &gt; 0) {
                  back[i].status = STATUS_CHUNK_WAIT;   <I><FONT COLOR="#B22222">/* waiting for next chunk (NN\r\n&lt;data&gt;\r\nNN\r\n&lt;data&gt;..\r\n0\r\n\r\n) */</FONT></I>
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">CHUNKDEBUG</FONT>==1
                  printf(<B><FONT COLOR="#BC8F8F">&quot;[%d] waiting for next chunk\n&quot;</FONT></B>, (<B><FONT COLOR="#228B22">int</FONT></B>) back[i].r.soc);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
                } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status == STATUS_CHUNK_WAIT &amp;&amp; chunk_size == 0) {    <I><FONT COLOR="#B22222">/* final chunk */</FONT></I>
                  back[i].status = STATUS_CHUNK_CR;     <I><FONT COLOR="#B22222">/* final CRLF */</FONT></I>
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">CHUNKDEBUG</FONT>==1
                  printf(<B><FONT COLOR="#BC8F8F">&quot;[%d] waiting for final CRLF (chunk)\n&quot;</FONT></B>,
                         (<B><FONT COLOR="#228B22">int</FONT></B>) back[i].r.soc);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
                } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status == STATUS_CHUNK_WAIT &amp;&amp; chunk_size &gt;= 0) {    <I><FONT COLOR="#B22222">/* will fetch data now */</FONT></I>
                  back[i].status = 1;   <I><FONT COLOR="#B22222">// continuer body    
</FONT></I>#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">CHUNKDEBUG</FONT>==1
                  printf(<B><FONT COLOR="#BC8F8F">&quot;[%d] waiting for body (chunk)\n&quot;</FONT></B>,
                         (<B><FONT COLOR="#228B22">int</FONT></B>) back[i].r.soc);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
                } <B><FONT COLOR="#A020F0">else</FONT></B> {        <I><FONT COLOR="#B22222">/* zero-size-chunk-CRLF (end) or error */</FONT></I>
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">CHUNKDEBUG</FONT>==1
                  printf(<B><FONT COLOR="#BC8F8F">&quot;[%d] chunk end, total: %d\n&quot;</FONT></B>, (<B><FONT COLOR="#228B22">int</FONT></B>) back[i].r.soc,
                         back[i].r.size);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
                  <I><FONT COLOR="#B22222">/* End */</FONT></I>
                  <I><FONT COLOR="#B22222">//if (back[i].status==STATUS_CHUNK_CR) {
</FONT></I>                  back[i].status = STATUS_READY;        <I><FONT COLOR="#B22222">// fin  
</FONT></I>                  back_set_finished(sback, i);
                  <I><FONT COLOR="#B22222">//}
</FONT></I>
                  <I><FONT COLOR="#B22222">// finalize transfer if not temporary
</FONT></I>                  <B><FONT COLOR="#A020F0">if</FONT></B> (!IS_DELAYED_EXT(back[i].url_sav)) {
                    hts_log_print(opt, LOG_TRACE, <B><FONT COLOR="#BC8F8F">&quot;finalizing at chunk end&quot;</FONT></B>);
                    back_finalize(opt, cache, sback, i);
                  } <B><FONT COLOR="#A020F0">else</FONT></B> {
                    <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.statuscode == HTTP_OK) {
                      hts_log_print(opt, LOG_WARNING,
                                    <B><FONT COLOR="#BC8F8F">&quot;unexpected incomplete type with 200 code at %s%s&quot;</FONT></B>,
                                    back[i].url_adr, back[i].url_fil);
                    }
                  }
                  <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.soc != INVALID_SOCKET) {
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_DEBUG_CLOSESOCK</FONT>
                    DEBUG_W(<B><FONT COLOR="#BC8F8F">&quot;back_wait(5): deletehttp\n&quot;</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
                    <I><FONT COLOR="#B22222">/* Error */</FONT></I>
                    <B><FONT COLOR="#A020F0">if</FONT></B> (chunk_size &lt; 0) {
                      deletehttp(&amp;back[i].r);
                      back[i].r.soc = INVALID_SOCKET;
                      deleteaddr(&amp;back[i].r);
                      back[i].r.statuscode = STATUSCODE_INVALID;
                      strcpybuff(back[i].r.msg, <B><FONT COLOR="#BC8F8F">&quot;Invalid chunk&quot;</FONT></B>);
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">CHUNKDEBUG</FONT>==1
                      printf(<B><FONT COLOR="#BC8F8F">&quot;[%d] chunk error\n&quot;</FONT></B>, (<B><FONT COLOR="#228B22">int</FONT></B>) back[i].r.soc);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
                    } <B><FONT COLOR="#A020F0">else</FONT></B> {    <I><FONT COLOR="#B22222">/* if chunk_size == 0 */</FONT></I>

#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">CHUNKDEBUG</FONT>==1
                      printf(<B><FONT COLOR="#BC8F8F">&quot;[%d] all chunks now received\n&quot;</FONT></B>,
                             (<B><FONT COLOR="#228B22">int</FONT></B>) back[i].r.soc);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

                      <I><FONT COLOR="#B22222">/* Tester totalsize en fin de chunk */</FONT></I>
                      <B><FONT COLOR="#A020F0">if</FONT></B> ((back[i].r.totalsize &gt;= 0)) { <I><FONT COLOR="#B22222">// tester totalsize
</FONT></I>                        <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.totalsize != back[i].r.size) {    <I><FONT COLOR="#B22222">// pas la même!
</FONT></I>                          <B><FONT COLOR="#A020F0">if</FONT></B> (!opt-&gt;tolerant) {
                            deleteaddr(&amp;back[i].r);
                            back[i].r.statuscode = STATUSCODE_INVALID;
                            strcpybuff(back[i].r.msg, <B><FONT COLOR="#BC8F8F">&quot;Incorrect length&quot;</FONT></B>);
                          } <B><FONT COLOR="#A020F0">else</FONT></B> {
                            <I><FONT COLOR="#B22222">// Un warning suffira..
</FONT></I>                            hts_log_print(opt, LOG_WARNING,
                                          <B><FONT COLOR="#BC8F8F">&quot;Incorrect length (&quot;</FONT></B> LLintP <B><FONT COLOR="#BC8F8F">&quot;!=&quot;</FONT></B>
                                          LLintP <B><FONT COLOR="#BC8F8F">&quot; expected) for %s%s&quot;</FONT></B>,
                                          (LLint) back[i].r.size,
                                          (LLint) back[i].r.totalsize,
                                          back[i].url_adr, back[i].url_fil);
                          }
                        }
                      }

                      <I><FONT COLOR="#B22222">/* Oops, trailers! */</FONT></I>
                      <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.keep_alive_trailers) {
                        <I><FONT COLOR="#B22222">/* fixme (not yet supported) */</FONT></I>
                      }

                    }

                  }
                }

                <I><FONT COLOR="#B22222">// effacer buffer (chunk en tete)
</FONT></I>                <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].chunk_adr != NULL) {
                  freet(back[i].chunk_adr);
                  back[i].chunk_adr = NULL;
                  back[i].chunk_size = 0;
                  <I><FONT COLOR="#B22222">// NO! xxback[i].chunk_blocksize = 0;
</FONT></I>                }

              }                 <I><FONT COLOR="#B22222">// taille buffer chunk &gt; 1 &amp;&amp; LF
</FONT></I>              <I><FONT COLOR="#B22222">//
</FONT></I>            } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status == STATUS_WAIT_HEADERS) { <I><FONT COLOR="#B22222">// en têtes (avant le chunk si il est présent)
</FONT></I>              <I><FONT COLOR="#B22222">//
</FONT></I>              <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.size &gt;= 2) {
                <I><FONT COLOR="#B22222">// double LF
</FONT></I>                <B><FONT COLOR="#A020F0">if</FONT></B> (((back[i].r.adr[back[i].r.size - 1] == 10)
                     &amp;&amp; (back[i].r.adr[back[i].r.size - 2] == 10))
                    || (back[i].r.adr[0] == <B><FONT COLOR="#BC8F8F">'&lt;'</FONT></B>)        <I><FONT COLOR="#B22222">/* bogus server */</FONT></I>
                  ) {
                  <B><FONT COLOR="#228B22">char</FONT></B> rcvd[2048];
                  <B><FONT COLOR="#228B22">int</FONT></B> ptr = 0;
                  <B><FONT COLOR="#228B22">int</FONT></B> noFreebuff = 0;

#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">BDEBUG</FONT>==1
                  printf(<B><FONT COLOR="#BC8F8F">&quot;..ok, header received\n&quot;</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

                  <I><FONT COLOR="#B22222">/* Hack for zero-length headers */</FONT></I>
                  <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status != 0 &amp;&amp; back[i].r.adr[0] != <B><FONT COLOR="#BC8F8F">'&lt;'</FONT></B>) {

                    <I><FONT COLOR="#B22222">// ----------------------------------------
</FONT></I>                    <I><FONT COLOR="#B22222">// traiter en-tête!
</FONT></I>                    <I><FONT COLOR="#B22222">// status-line à récupérer
</FONT></I>                    ptr += binput(back[i].r.adr + ptr, rcvd, 2000);
                    <B><FONT COLOR="#A020F0">if</FONT></B> (strnotempty(rcvd) == 0) {
                      <I><FONT COLOR="#B22222">/* Bogus CRLF, OR recycled connection and trailing chunk CRLF */</FONT></I>
                      ptr += binput(back[i].r.adr + ptr, rcvd, 2000);
                    }
                    <I><FONT COLOR="#B22222">// traiter status-line
</FONT></I>                    treatfirstline(&amp;back[i].r, rcvd);

#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HDEBUG</FONT>
                    printf(<B><FONT COLOR="#BC8F8F">&quot;(Buffer) Status-Code=%d\n&quot;</FONT></B>, back[i].r.statuscode);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
                    <B><FONT COLOR="#A020F0">if</FONT></B> (_DEBUG_HEAD) {
                      <B><FONT COLOR="#A020F0">if</FONT></B> (ioinfo) {
                        fprintf(ioinfo,
                                <B><FONT COLOR="#BC8F8F">&quot;[%d] response for %s%s:\r\ncode=%d\r\n&quot;</FONT></B>,
                                back[i].r.debugid,
                                jump_identification_const(back[i].url_adr),
                                back[i].url_fil, back[i].r.statuscode);
                        fprintfio(ioinfo, back[i].r.adr, <B><FONT COLOR="#BC8F8F">&quot;&gt;&gt;&gt; &quot;</FONT></B>);
                        fprintf(ioinfo, <B><FONT COLOR="#BC8F8F">&quot;\r\n&quot;</FONT></B>);
                        fflush(ioinfo);
                      }         <I><FONT COLOR="#B22222">// en-tête
</FONT></I>                    }
                    <I><FONT COLOR="#B22222">// header // ** !attention! HTTP/0.9 non supporté
</FONT></I>                    <B><FONT COLOR="#A020F0">do</FONT></B> {
                      ptr += binput(back[i].r.adr + ptr, rcvd, 2000);
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HDEBUG</FONT>
                      printf(<B><FONT COLOR="#BC8F8F">&quot;(buffer)&gt;%s\n&quot;</FONT></B>, rcvd);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
                      <I><FONT COLOR="#B22222">/*
                         if (_DEBUG_HEAD) {
                         if (ioinfo) {
                         fprintf(ioinfo,&quot;(buffer)&gt;%s\r\n&quot;,rcvd);      
                         fflush(ioinfo);
                         }
                         }
                       */</FONT></I>

                      <B><FONT COLOR="#A020F0">if</FONT></B> (strnotempty(rcvd))
                        treathead(opt-&gt;cookie, back[i].url_adr, back[i].url_fil, &amp;back[i].r, rcvd);     <I><FONT COLOR="#B22222">// traiter
</FONT></I>
                      <I><FONT COLOR="#B22222">// parfois les serveurs buggés renvoient un content-range avec un 200
</FONT></I>                      <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.statuscode == HTTP_OK)      <I><FONT COLOR="#B22222">// 'OK'
</FONT></I>                        <B><FONT COLOR="#A020F0">if</FONT></B> (strfield(rcvd, <B><FONT COLOR="#BC8F8F">&quot;content-range:&quot;</FONT></B>)) { <I><FONT COLOR="#B22222">// Avec un content-range: relisez les RFC..
</FONT></I>                          <I><FONT COLOR="#B22222">// Fake range (the file is complete)
</FONT></I>                          <B><FONT COLOR="#A020F0">if</FONT></B> (!
                              (back[i].r.crange_start == 0
                               &amp;&amp; back[i].r.crange_end ==
                               back[i].r.crange - 1)) {
                            back[i].r.statuscode = HTTP_PARTIAL_CONTENT;        <I><FONT COLOR="#B22222">// FORCER A 206 !!!!!
</FONT></I>                          }
                        }

                    } <B><FONT COLOR="#A020F0">while</FONT></B>(strnotempty(rcvd));
                    <I><FONT COLOR="#B22222">// ----------------------------------------                    
</FONT></I>
                  } <B><FONT COLOR="#A020F0">else</FONT></B> {
                    <I><FONT COLOR="#B22222">// assume text/html, OK
</FONT></I>                    treatfirstline(&amp;back[i].r, back[i].r.adr);
                    noFreebuff = 1;
                  }

                  <I><FONT COLOR="#B22222">// Callback
</FONT></I>                  {
                    <B><FONT COLOR="#228B22">int</FONT></B> test_head = RUN_CALLBACK6(opt, receivehead,
                                                  back[i].r.adr,
                                                  back[i].url_adr,
                                                  back[i].url_fil,
                                                  back[i].referer_adr,
                                                  back[i].referer_fil,
                                                  &amp;back[i].r);
                    <B><FONT COLOR="#A020F0">if</FONT></B> (test_head != 1) {
                      hts_log_print(opt, LOG_WARNING,
                                    <B><FONT COLOR="#BC8F8F">&quot;External wrapper aborted transfer, breaking connection: %s%s&quot;</FONT></B>,
                                    back[i].url_adr, back[i].url_fil);
                      back[i].status = STATUS_READY;    <I><FONT COLOR="#B22222">// FINI
</FONT></I>                      back_set_finished(sback, i);
                      deletehttp(&amp;back[i].r);
                      back[i].r.soc = INVALID_SOCKET;
                      strcpybuff(back[i].r.msg,
                                 <B><FONT COLOR="#BC8F8F">&quot;External wrapper aborted transfer&quot;</FONT></B>);
                      back[i].r.statuscode = STATUSCODE_INVALID;
                    }
                  }

                  <I><FONT COLOR="#B22222">// Free headers memory now
</FONT></I>                  <I><FONT COLOR="#B22222">// Actually, save them for informational purpose
</FONT></I>                  <B><FONT COLOR="#A020F0">if</FONT></B> (!noFreebuff) {
                    <B><FONT COLOR="#228B22">char</FONT></B> *block = back[i].r.adr;

                    back[i].r.adr = NULL;
                    deleteaddr(&amp;back[i].r);
                    back[i].r.headers = block;
                  }

                  <I><FONT COLOR="#B22222">/* 
                     Status code and header-response hacks
                   */</FONT></I>

                  <I><FONT COLOR="#B22222">// Check response : 203 == 200
</FONT></I>                  <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.statuscode ==
                      HTTP_NON_AUTHORITATIVE_INFORMATION) {
                    back[i].r.statuscode = HTTP_OK;     <I><FONT COLOR="#B22222">// forcer &quot;OK&quot;
</FONT></I>                  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.statuscode == HTTP_CONTINUE) {
                    back[i].status = STATUS_WAIT_HEADERS;
                    back[i].r.size = 0;
                    back[i].r.totalsize = -1;
                    back[i].chunk_size = 0;
                    back[i].r.statuscode = STATUSCODE_INVALID;
                    back[i].r.msg[0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
                    hts_log_print(opt, LOG_DEBUG,
                                  <B><FONT COLOR="#BC8F8F">&quot;Status 100 detected for %s%s, continuing headers&quot;</FONT></B>,
                                  back[i].url_adr, back[i].url_fil);
                    <B><FONT COLOR="#A020F0">continue</FONT></B>;
                  }

                  <I><FONT COLOR="#B22222">/*
                     Solve &quot;false&quot; 416 problems
                   */</FONT></I>
                  <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.statuscode == HTTP_REQUESTED_RANGE_NOT_SATISFIABLE) {   <I><FONT COLOR="#B22222">// 'Requested Range Not Satisfiable'
</FONT></I>                    <I><FONT COLOR="#B22222">// Example:
</FONT></I>                    <I><FONT COLOR="#B22222">// Range: bytes=2830-
</FONT></I>                    <I><FONT COLOR="#B22222">// -&gt;
</FONT></I>                    <I><FONT COLOR="#B22222">// Content-Range: bytes */2830
</FONT></I>                    <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].range_req_size == back[i].r.crange) {
                      filenote(&amp;opt-&gt;state.strc, back[i].url_sav, NULL);
                      file_notify(opt, back[i].url_adr, back[i].url_fil,
                                  back[i].url_sav, 0, 0, back[i].r.notmodified);
                      deletehttp(&amp;back[i].r);
                      back[i].r.soc = INVALID_SOCKET;
                      back[i].status = STATUS_READY;    <I><FONT COLOR="#B22222">// READY
</FONT></I>                      back_set_finished(sback, i);
                      back[i].r.size = back[i].r.totalsize =
                        back[i].range_req_size;
                      back[i].r.statuscode = HTTP_NOT_MODIFIED; <I><FONT COLOR="#B22222">// NOT MODIFIED
</FONT></I>                      hts_log_print(opt, LOG_DEBUG,
                                    <B><FONT COLOR="#BC8F8F">&quot;File seems complete (good 416 message), breaking connection: %s%s&quot;</FONT></B>,
                                    back[i].url_adr, back[i].url_fil);
                    }
                  }
                  <I><FONT COLOR="#B22222">// transform 406 into 200 ; we'll catch embedded links inside the choice page
</FONT></I>                  <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.statuscode == 406) {    <I><FONT COLOR="#B22222">// 'Not Acceptable'
</FONT></I>                    back[i].r.statuscode = HTTP_OK;
                  }
                  <I><FONT COLOR="#B22222">// 'do not erase already downloaded file'
</FONT></I>                  <I><FONT COLOR="#B22222">// on an updated file
</FONT></I>                  <I><FONT COLOR="#B22222">// with an error : consider a 304 error
</FONT></I>                  <B><FONT COLOR="#A020F0">if</FONT></B> (!opt-&gt;delete_old) {
                    <B><FONT COLOR="#A020F0">if</FONT></B> (HTTP_IS_ERROR(back[i].r.statuscode) &amp;&amp; back[i].is_update
                        &amp;&amp; !back[i].testmode) {
                      <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].url_sav[0] &amp;&amp; fexist_utf8(back[i].url_sav)) {
                        hts_log_print(opt, LOG_DEBUG,
                                      <B><FONT COLOR="#BC8F8F">&quot;Error ignored %d (%s) because of 'no purge' option for %s%s&quot;</FONT></B>,
                                      back[i].r.statuscode, back[i].r.msg,
                                      back[i].url_adr, back[i].url_fil);
                        back[i].r.statuscode = HTTP_NOT_MODIFIED;
                        deletehttp(&amp;back[i].r);
                        back[i].r.soc = INVALID_SOCKET;
                      }
                    }
                  }
                  <I><FONT COLOR="#B22222">// Various hacks to limit re-transfers when updating a mirror
</FONT></I>                  <I><FONT COLOR="#B22222">// Force update if same size detected
</FONT></I>                  <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;sizehack) {
                    <I><FONT COLOR="#B22222">// We already have the file
</FONT></I>                    <I><FONT COLOR="#B22222">// and ask the remote server for an update
</FONT></I>                    <I><FONT COLOR="#B22222">// Some servers, especially dynamic pages severs, always
</FONT></I>                    <I><FONT COLOR="#B22222">// answer that the page has been modified since last visit
</FONT></I>                    <I><FONT COLOR="#B22222">// And answer with a 200 (OK) response, and the same page
</FONT></I>                    <I><FONT COLOR="#B22222">// If the size is the same, and the option has been set, we assume
</FONT></I>                    <I><FONT COLOR="#B22222">// that the file is identical - and therefore let's break the connection
</FONT></I>                    <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].is_update) {    <I><FONT COLOR="#B22222">// mise à jour
</FONT></I>                      <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.statuscode == HTTP_OK &amp;&amp; !back[i].testmode) {       <I><FONT COLOR="#B22222">// 'OK'
</FONT></I>                        htsblk r = cache_read(opt, cache, back[i].url_adr, back[i].url_fil, NULL, NULL);        <I><FONT COLOR="#B22222">// lire entrée cache
</FONT></I>
                        <B><FONT COLOR="#A020F0">if</FONT></B> (r.statuscode == HTTP_OK) {  <I><FONT COLOR="#B22222">// OK pas d'erreur cache
</FONT></I>                          LLint len1, len2;

                          len1 = r.totalsize;
                          len2 = back[i].r.totalsize;
                          <B><FONT COLOR="#A020F0">if</FONT></B> (r.size &gt; 0)
                            len1 = r.size;
                          <B><FONT COLOR="#A020F0">if</FONT></B> (len1 &gt;= 0) {
                            <B><FONT COLOR="#A020F0">if</FONT></B> (len1 == len2) { <I><FONT COLOR="#B22222">// tailles identiques
</FONT></I>                              back[i].r.statuscode = HTTP_NOT_MODIFIED; <I><FONT COLOR="#B22222">// forcer NOT MODIFIED
</FONT></I>                              deletehttp(&amp;back[i].r);
                              back[i].r.soc = INVALID_SOCKET;
                              hts_log_print(opt, LOG_DEBUG,
                                            <B><FONT COLOR="#BC8F8F">&quot;File seems complete (same size), breaking connection: %s%s&quot;</FONT></B>,
                                            back[i].url_adr, back[i].url_fil);
                            }
                          }
                        } <B><FONT COLOR="#A020F0">else</FONT></B> {
                          hts_log_print(opt, LOG_WARNING,
                                        <B><FONT COLOR="#BC8F8F">&quot;File seems complete (same size), but there was a cache read error (%u): %s%s&quot;</FONT></B>,
                                        r.statuscode, back[i].url_adr,
                                        back[i].url_fil);
                        }
                        <B><FONT COLOR="#A020F0">if</FONT></B> (r.adr) {
                          freet(r.adr);
                          r.adr = NULL;
                        }
                      }
                    }
                  }
                  <I><FONT COLOR="#B22222">// Various hacks to limit re-transfers when updating a mirror
</FONT></I>                  <I><FONT COLOR="#B22222">// Detect already downloaded file (with another browser, for example)
</FONT></I>                  <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;sizehack) {
                    <B><FONT COLOR="#A020F0">if</FONT></B> (!back[i].is_update) {   <I><FONT COLOR="#B22222">// mise à jour
</FONT></I>                      <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.statuscode == HTTP_OK &amp;&amp; !back[i].testmode) {       <I><FONT COLOR="#B22222">// 'OK'
</FONT></I>                        <B><FONT COLOR="#A020F0">if</FONT></B> (!is_hypertext_mime(opt, back[i].r.contenttype, back[i].url_fil)) {  <I><FONT COLOR="#B22222">// not HTML
</FONT></I>                          <B><FONT COLOR="#A020F0">if</FONT></B> (strnotempty(back[i].url_sav)) {   <I><FONT COLOR="#B22222">// target found
</FONT></I>                            <B><FONT COLOR="#228B22">int</FONT></B> size = fsize_utf8(back[i].url_sav);     <I><FONT COLOR="#B22222">// target size
</FONT></I>
                            <B><FONT COLOR="#A020F0">if</FONT></B> (size &gt;= 0) {
                              <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.totalsize == size) {        <I><FONT COLOR="#B22222">// same size!
</FONT></I>                                deletehttp(&amp;back[i].r);
                                back[i].r.soc = INVALID_SOCKET;
                                back[i].status = STATUS_READY;  <I><FONT COLOR="#B22222">// READY
</FONT></I>                                back_set_finished(sback, i);
                                back[i].r.size = back[i].r.totalsize;
                                filenote(&amp;opt-&gt;state.strc, back[i].url_sav,
                                         NULL);
                                file_notify(opt, back[i].url_adr,
                                            back[i].url_fil, back[i].url_sav, 0,
                                            0, back[i].r.notmodified);
                                back[i].r.statuscode = HTTP_NOT_MODIFIED;       <I><FONT COLOR="#B22222">// NOT MODIFIED
</FONT></I>                                hts_log_print(opt, LOG_DEBUG,
                                              <B><FONT COLOR="#BC8F8F">&quot;File seems complete (same size file discovered), breaking connection: %s%s&quot;</FONT></B>,
                                              back[i].url_adr, back[i].url_fil);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  <I><FONT COLOR="#B22222">// Various hacks to limit re-transfers when updating a mirror
</FONT></I>                  <I><FONT COLOR="#B22222">// Detect bad range: header
</FONT></I>                  <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;sizehack) {
                    <I><FONT COLOR="#B22222">// We have request for a partial file (with a 'Range: NNN-' header)
</FONT></I>                    <I><FONT COLOR="#B22222">// and received a complete file notification (200), with 'Content-length: NNN'
</FONT></I>                    <I><FONT COLOR="#B22222">// it might be possible that we had the complete file
</FONT></I>                    <I><FONT COLOR="#B22222">// this is the case in *most* cases, so break the connection
</FONT></I>                    <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.is_write == 0) {      <I><FONT COLOR="#B22222">// mode mémoire
</FONT></I>                      <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.adr == NULL) {      <I><FONT COLOR="#B22222">// rien n'a été écrit
</FONT></I>                        <B><FONT COLOR="#A020F0">if</FONT></B> (!back[i].testmode) {        <I><FONT COLOR="#B22222">// pas mode test
</FONT></I>                          <B><FONT COLOR="#A020F0">if</FONT></B> (strnotempty(back[i].url_sav)) {
                            <B><FONT COLOR="#A020F0">if</FONT></B> (strcmp(back[i].url_fil, <B><FONT COLOR="#BC8F8F">&quot;/robots.txt&quot;</FONT></B>)) {
                              <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.statuscode == HTTP_OK) {    <I><FONT COLOR="#B22222">// 'OK'
</FONT></I>                                <B><FONT COLOR="#A020F0">if</FONT></B> (!is_hypertext_mime(opt, back[i].r.contenttype, back[i].url_fil)) {  <I><FONT COLOR="#B22222">// pas HTML
</FONT></I>                                  <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.statuscode == HTTP_OK) {        <I><FONT COLOR="#B22222">// &quot;OK&quot;
</FONT></I>                                    <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].range_req_size &gt; 0) {   <I><FONT COLOR="#B22222">// but Range: requested
</FONT></I>                                      <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].range_req_size == back[i].r.totalsize) {      <I><FONT COLOR="#B22222">// And same size
</FONT></I>#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_DEBUG_CLOSESOCK</FONT>
                                        DEBUG_W
                                          (<B><FONT COLOR="#BC8F8F">&quot;back_wait(skip_range): deletehttp\n&quot;</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
                                        deletehttp(&amp;back[i].r);
                                        back[i].r.soc = INVALID_SOCKET;
                                        back[i].status = STATUS_READY;  <I><FONT COLOR="#B22222">// READY
</FONT></I>                                        back_set_finished(sback, i);
                                        back[i].r.size = back[i].r.totalsize;
                                        filenote(&amp;opt-&gt;state.strc,
                                                 back[i].url_sav, NULL);
                                        file_notify(opt, back[i].url_adr,
                                                    back[i].url_fil,
                                                    back[i].url_sav, 0, 0,
                                                    back[i].r.notmodified);
                                        back[i].r.statuscode = HTTP_NOT_MODIFIED;       <I><FONT COLOR="#B22222">// NOT MODIFIED
</FONT></I>                                        hts_log_print(opt, LOG_DEBUG,
                                                      <B><FONT COLOR="#BC8F8F">&quot;File seems complete (reget failed), breaking connection: %s%s&quot;</FONT></B>,
                                                      back[i].url_adr,
                                                      back[i].url_fil);
                                      }
                                    }
                                  }

                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                  <I><FONT COLOR="#B22222">// END - Various hacks to limit re-transfers when updating a mirror
</FONT></I>
                  <I><FONT COLOR="#B22222">/* 
                     End of status code and header-response hacks
                   */</FONT></I>

                  <I><FONT COLOR="#B22222">/* Interdiction taille par le wizard? */</FONT></I>
                  <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.soc != INVALID_SOCKET) {
                    <B><FONT COLOR="#A020F0">if</FONT></B> (!back_checksize(opt, &amp;back[i], 1)) {
                      back[i].status = STATUS_READY;    <I><FONT COLOR="#B22222">// FINI
</FONT></I>                      back_set_finished(sback, i);
                      back[i].r.statuscode = STATUSCODE_TOO_BIG;
                      deletehttp(&amp;back[i].r);
                      back[i].r.soc = INVALID_SOCKET;
                      <B><FONT COLOR="#A020F0">if</FONT></B> (!back[i].testmode)
                        strcpybuff(back[i].r.msg, <B><FONT COLOR="#BC8F8F">&quot;File too big&quot;</FONT></B>);
                      <B><FONT COLOR="#A020F0">else</FONT></B>
                        strcpybuff(back[i].r.msg, <B><FONT COLOR="#BC8F8F">&quot;Test: File too big&quot;</FONT></B>);
                    }
                  }

                  <I><FONT COLOR="#B22222">/* sinon, continuer */</FONT></I>
                  <I><FONT COLOR="#B22222">/* if (back[i].r.soc!=INVALID_SOCKET) {   // ok récupérer body? */</FONT></I>
                  <I><FONT COLOR="#B22222">// head: terminé
</FONT></I>                  <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].head_request) {
                    hts_log_print(opt, LOG_DEBUG, <B><FONT COLOR="#BC8F8F">&quot;Tested file: %s%s&quot;</FONT></B>,
                                  back[i].url_adr, back[i].url_fil);
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_DEBUG_CLOSESOCK</FONT>
                    DEBUG_W(<B><FONT COLOR="#BC8F8F">&quot;back_wait(head request): deletehttp\n&quot;</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
                    <I><FONT COLOR="#B22222">// Couper connexion
</FONT></I>                    <B><FONT COLOR="#A020F0">if</FONT></B> (!back[i].http11) {      <I><FONT COLOR="#B22222">/* NO KA */</FONT></I>
                      deletehttp(&amp;back[i].r);
                      back[i].r.soc = INVALID_SOCKET;
                    }
                    back[i].status = STATUS_READY;      <I><FONT COLOR="#B22222">// terminé
</FONT></I>                    back_set_finished(sback, i);
                  }
                  <I><FONT COLOR="#B22222">// traiter une éventuelle erreur 304 (cache à jour utilisable)
</FONT></I>                  <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.statuscode == HTTP_NOT_MODIFIED) { <I><FONT COLOR="#B22222">// document à jour dans le cache
</FONT></I>                    <I><FONT COLOR="#B22222">// lire dans le cache
</FONT></I>                    <I><FONT COLOR="#B22222">// ** NOTE: pas de vérif de la taille ici!!
</FONT></I>#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_DEBUG_CLOSESOCK</FONT>
                    DEBUG_W(<B><FONT COLOR="#BC8F8F">&quot;back_wait(file is not modified): deletehttp\n&quot;</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
                    <I><FONT COLOR="#B22222">/* clear everything but connection: switch, close, and reswitch */</FONT></I>
                    {
                      htsblk tmp;

                      memset(&amp;tmp, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(tmp));
                      back_connxfr(&amp;back[i].r, &amp;tmp);
                      back[i].r =
                        cache_read(opt, cache, back[i].url_adr, back[i].url_fil,
                                   back[i].url_sav, back[i].location_buffer);
                      back[i].r.location = back[i].location_buffer;
                      back_connxfr(&amp;tmp, &amp;back[i].r);
                    }

                    <I><FONT COLOR="#B22222">// hack:
</FONT></I>                    <I><FONT COLOR="#B22222">// In case of 'if-unmodified-since' hack, a 304 status can be sent
</FONT></I>                    <I><FONT COLOR="#B22222">// then, force 'ok' status
</FONT></I>                    <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.statuscode == STATUSCODE_INVALID) {
                      <B><FONT COLOR="#A020F0">if</FONT></B> (fexist_utf8(back[i].url_sav)) {
                        back[i].r.statuscode = HTTP_OK; <I><FONT COLOR="#B22222">// OK
</FONT></I>                        strcpybuff(back[i].r.msg, <B><FONT COLOR="#BC8F8F">&quot;OK (cached)&quot;</FONT></B>);
                        back[i].r.is_file = 1;
                        back[i].r.totalsize = back[i].r.size =
                          fsize_utf8(back[i].url_sav);
                        get_httptype(opt, back[i].r.contenttype,
                                     back[i].url_sav, 1);
                        hts_log_print(opt, LOG_DEBUG,
                                      <B><FONT COLOR="#BC8F8F">&quot;Not-modified status without cache guessed: %s%s&quot;</FONT></B>,
                                      back[i].url_adr, back[i].url_fil);
                      }
                    }
                    <I><FONT COLOR="#B22222">// Status is okay?
</FONT></I>                    <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.statuscode != -1) {   <I><FONT COLOR="#B22222">// pas d'erreur de lecture
</FONT></I>                      back[i].status = STATUS_READY;    <I><FONT COLOR="#B22222">// OK prêt
</FONT></I>                      back_set_finished(sback, i);
                      back[i].r.notmodified = 1;        <I><FONT COLOR="#B22222">// NON modifié!
</FONT></I>                      hts_log_print(opt, LOG_DEBUG,
                                    <B><FONT COLOR="#BC8F8F">&quot;File loaded after test from cache: %s%s&quot;</FONT></B>,
                                    back[i].url_adr, back[i].url_fil);

                      <I><FONT COLOR="#B22222">// finalize
</FONT></I>                      <I><FONT COLOR="#B22222">//file_notify(back[i].url_adr, back[i].url_fil, back[i].url_sav, 0, 0, back[i].r.notmodified);        // not modified
</FONT></I>                      <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.statuscode &gt; 0) {
                        hts_log_print(opt, LOG_TRACE, <B><FONT COLOR="#BC8F8F">&quot;finalizing after cache load&quot;</FONT></B>);
                        back_finalize(opt, cache, sback, i);
                      }
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">DEBUGCA</FONT>
                      printf(<B><FONT COLOR="#BC8F8F">&quot;..document à jour après requète: %s%s\n&quot;</FONT></B>,
                             back[i].url_adr, back[i].url_fil);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

                      <I><FONT COLOR="#B22222">//printf(&quot;&gt;%s status %d\n&quot;,back[p].r.contenttype,back[p].r.statuscode);
</FONT></I>                    } <B><FONT COLOR="#A020F0">else</FONT></B> {    <I><FONT COLOR="#B22222">// erreur
</FONT></I>                      back[i].status = STATUS_READY;    <I><FONT COLOR="#B22222">// terminé
</FONT></I>                      back_set_finished(sback, i);
                      <I><FONT COLOR="#B22222">//printf(&quot;erreur cache\n&quot;);
</FONT></I>
                    }

<I><FONT COLOR="#B22222">/********** NO - must complete the body! ********** */</FONT></I>
#<B><FONT COLOR="#5F9EA0">if</FONT></B> 0
                  } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (HTTP_IS_REDIRECT(back[i].r.statuscode)
                             || (back[i].r.statuscode == 412)
                             || (back[i].r.statuscode == 416)
                    ) {         <I><FONT COLOR="#B22222">// Ne pas prendre le html, erreurs connues et gérées
</FONT></I>#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_DEBUG_CLOSESOCK</FONT>
                    DEBUG_W
                      (<B><FONT COLOR="#BC8F8F">&quot;back_wait(301,302,303,307,412,416..): deletehttp\n&quot;</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
                    <I><FONT COLOR="#B22222">// Couper connexion
</FONT></I>                    <I><FONT COLOR="#B22222">/*KA deletehttp(&amp;back[i].r); back[i].r.soc=INVALID_SOCKET; */</FONT></I>
                    back_maydeletehttp(opt, cache, sback, i);

                    back[i].status = STATUS_READY;      <I><FONT COLOR="#B22222">// terminé
</FONT></I>                    back_set_finished(sback, i);
                    <I><FONT COLOR="#B22222">// finalize
</FONT></I>                    <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.statuscode &gt; 0) {
                      hts_log_print(opt, LOG_TRACE, <B><FONT COLOR="#BC8F8F">&quot;finalizing redirect &amp; 4xx&quot;</FONT></B>);
                      back_finalize(opt, cache, sback, i);
                    }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
<I><FONT COLOR="#B22222">/********** **************************** ********** */</FONT></I>
                  } <B><FONT COLOR="#A020F0">else</FONT></B> {      <I><FONT COLOR="#B22222">// il faut aller le chercher
</FONT></I>
                    <I><FONT COLOR="#B22222">// effacer buffer (requète)
</FONT></I>                    <B><FONT COLOR="#A020F0">if</FONT></B> (!noFreebuff) {
                      deleteaddr(&amp;back[i].r);
                      back[i].r.size = 0;
                    }
                    <I><FONT COLOR="#B22222">// traiter 206 (partial content)
</FONT></I>                    <I><FONT COLOR="#B22222">// xxc SI CHUNK VERIFIER QUE CA MARCHE??
</FONT></I>                    <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.statuscode == 206) {  <I><FONT COLOR="#B22222">// on nous envoie un morceau (la fin) coz une partie sur disque!
</FONT></I>                      off_t sz = fsize_utf8(back[i].url_sav);

#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HDEBUG</FONT>
                      printf(<B><FONT COLOR="#BC8F8F">&quot;partial content: &quot;</FONT></B> LLintP <B><FONT COLOR="#BC8F8F">&quot; on disk..\n&quot;</FONT></B>,
                             (LLint) sz);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
                      <B><FONT COLOR="#A020F0">if</FONT></B> (sz &gt;= 0) {
                        <B><FONT COLOR="#A020F0">if</FONT></B> (!is_hypertext_mime(opt, back[i].r.contenttype, back[i].url_sav)) {  <I><FONT COLOR="#B22222">// pas HTML
</FONT></I>                          <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;getmode &amp; 2) {       <I><FONT COLOR="#B22222">// on peut ecrire des non html  **sinon ben euhh sera intercepté plus loin, donc rap sur ce qui va sortir**
</FONT></I>                            filenote(&amp;opt-&gt;state.strc, back[i].url_sav, NULL);  <I><FONT COLOR="#B22222">// noter fichier comme connu
</FONT></I>                            file_notify(opt, back[i].url_adr, back[i].url_fil,
                                        back[i].url_sav, 0, 1,
                                        back[i].r.notmodified);
                            back[i].r.out = FOPEN(fconv(catbuff, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(catbuff), back[i].url_sav), <B><FONT COLOR="#BC8F8F">&quot;ab&quot;</FONT></B>);       <I><FONT COLOR="#B22222">// append
</FONT></I>                            <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.out &amp;&amp; opt-&gt;cache != 0) {
                              back[i].r.is_write = 1;   <I><FONT COLOR="#B22222">// écrire
</FONT></I>                              back[i].r.size = sz;      <I><FONT COLOR="#B22222">// déja écrit
</FONT></I>                              back[i].r.statuscode = HTTP_OK;   <I><FONT COLOR="#B22222">// Forcer 'OK'
</FONT></I>                              <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.totalsize &gt;= 0)
                                back[i].r.totalsize += sz;      <I><FONT COLOR="#B22222">// plus en fait
</FONT></I>                              fseek(back[i].r.out, 0, SEEK_END);        <I><FONT COLOR="#B22222">// à la fin
</FONT></I>                              <I><FONT COLOR="#B22222">/* create a temporary reference file in case of broken mirror */</FONT></I>
                              <B><FONT COLOR="#A020F0">if</FONT></B> (back_serialize_ref(opt, &amp;back[i]) != 0) {
                                hts_log_print(opt, LOG_WARNING,
                                              <B><FONT COLOR="#BC8F8F">&quot;Could not create temporary reference file for %s%s&quot;</FONT></B>,
                                              back[i].url_adr, back[i].url_fil);
                              }
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HDEBUG</FONT>
                              printf(<B><FONT COLOR="#BC8F8F">&quot;continue interrupted file\n&quot;</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
                            } <B><FONT COLOR="#A020F0">else</FONT></B> {    <I><FONT COLOR="#B22222">// On est dans la m**
</FONT></I>                              back[i].status = STATUS_READY;    <I><FONT COLOR="#B22222">// terminé (voir plus loin)
</FONT></I>                              back_set_finished(sback, i);
                              strcpybuff(back[i].r.msg,
                                         <B><FONT COLOR="#BC8F8F">&quot;Can not open partial file&quot;</FONT></B>);
                            }
                          }
                        } <B><FONT COLOR="#A020F0">else</FONT></B> {        <I><FONT COLOR="#B22222">// mémoire
</FONT></I>                          FILE *fp =
                            FOPEN(fconv(catbuff, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(catbuff), back[i].url_sav), <B><FONT COLOR="#BC8F8F">&quot;rb&quot;</FONT></B>);
                          <B><FONT COLOR="#A020F0">if</FONT></B> (fp) {
                            LLint alloc_mem = sz + 1;

                            <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.totalsize &gt;= 0)
                              alloc_mem += back[i].r.totalsize; <I><FONT COLOR="#B22222">// AJOUTER RESTANT!
</FONT></I>                            <B><FONT COLOR="#A020F0">if</FONT></B> (deleteaddr(&amp;back[i].r)
                                &amp;&amp; (back[i].r.adr =
                                    (<B><FONT COLOR="#228B22">char</FONT></B> *) malloct((size_t) alloc_mem))) {
                              back[i].r.size = sz;
                              <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.totalsize &gt;= 0)
                                back[i].r.totalsize += sz;      <I><FONT COLOR="#B22222">// plus en fait
</FONT></I>                              <B><FONT COLOR="#A020F0">if</FONT></B> ((fread(back[i].r.adr, 1, sz, fp)) != sz) {
                                back[i].status = STATUS_READY;  <I><FONT COLOR="#B22222">// terminé (voir plus loin)
</FONT></I>                                back_set_finished(sback, i);
                                strcpybuff(back[i].r.msg,
                                           <B><FONT COLOR="#BC8F8F">&quot;Can not read partial file&quot;</FONT></B>);
                              } <B><FONT COLOR="#A020F0">else</FONT></B> {
                                back[i].r.statuscode = HTTP_OK; <I><FONT COLOR="#B22222">// Forcer 'OK'
</FONT></I>#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HDEBUG</FONT>
                                printf(<B><FONT COLOR="#BC8F8F">&quot;continue in mem interrupted file\n&quot;</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
                              }
                            } <B><FONT COLOR="#A020F0">else</FONT></B> {
                              back[i].status = STATUS_READY;    <I><FONT COLOR="#B22222">// terminé (voir plus loin)
</FONT></I>                              back_set_finished(sback, i);
                              strcpybuff(back[i].r.msg,
                                         <B><FONT COLOR="#BC8F8F">&quot;No memory for partial file&quot;</FONT></B>);
                            }
                            fclose(fp);
                          } <B><FONT COLOR="#A020F0">else</FONT></B> {      <I><FONT COLOR="#B22222">// Argh.. 
</FONT></I>                            back[i].status = STATUS_READY;      <I><FONT COLOR="#B22222">// terminé (voir plus loin)
</FONT></I>                            back_set_finished(sback, i);
                            strcpybuff(back[i].r.msg,
                                       <B><FONT COLOR="#BC8F8F">&quot;Can not open partial file&quot;</FONT></B>);
                          }
                        }
                      } <B><FONT COLOR="#A020F0">else</FONT></B> {  <I><FONT COLOR="#B22222">// Non trouvé??
</FONT></I>                        back[i].status = STATUS_READY;  <I><FONT COLOR="#B22222">// terminé (voir plus loin)
</FONT></I>                        back_set_finished(sback, i);
                        strcpybuff(back[i].r.msg, <B><FONT COLOR="#BC8F8F">&quot;Can not find partial file&quot;</FONT></B>);
                      }
                      <I><FONT COLOR="#B22222">// Erreur?
</FONT></I>                      <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status == STATUS_READY) {
                        <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.soc != INVALID_SOCKET) {
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_DEBUG_CLOSESOCK</FONT>
                          DEBUG_W
                            (<B><FONT COLOR="#BC8F8F">&quot;back_wait(206 solve problems): deletehttp\n&quot;</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
                          deletehttp(&amp;back[i].r);
                        }
                        back[i].r.soc = INVALID_SOCKET;
                        <I><FONT COLOR="#B22222">//back[i].r.statuscode=206;  ????????
</FONT></I>                        back[i].r.statuscode = STATUSCODE_NON_FATAL;
                        <B><FONT COLOR="#A020F0">if</FONT></B> (strnotempty(back[i].r.msg))
                          strcpybuff(back[i].r.msg,
                                     <B><FONT COLOR="#BC8F8F">&quot;Error attempting to solve status 206 (partial file)&quot;</FONT></B>);
                      }
                    }

                    <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status != 0) {  <I><FONT COLOR="#B22222">// non terminé (erreur)
</FONT></I>                      <B><FONT COLOR="#A020F0">if</FONT></B> (!back[i].testmode) {  <I><FONT COLOR="#B22222">// fichier normal
</FONT></I>
                        <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.empty <I><FONT COLOR="#B22222">/* ?? &amp;&amp; back[i].r.statuscode==HTTP_OK */</FONT></I> ) {       <I><FONT COLOR="#B22222">// empty response
</FONT></I>                          <I><FONT COLOR="#B22222">// Couper connexion
</FONT></I>                          back_maydeletehttp(opt, cache, sback, i);
                          <I><FONT COLOR="#B22222">/* KA deletehttp(&amp;back[i].r); back[i].r.soc=INVALID_SOCKET; */</FONT></I>
                          back[i].status = STATUS_READY;        <I><FONT COLOR="#B22222">// terminé
</FONT></I>                          back_set_finished(sback, i);
                          <B><FONT COLOR="#A020F0">if</FONT></B> (deleteaddr(&amp;back[i].r)
                              &amp;&amp; (back[i].r.adr = (<B><FONT COLOR="#228B22">char</FONT></B> *) malloct(2))) {
                            back[i].r.adr[0] = 0;
                          }
                          hts_log_print(opt, LOG_TRACE, <B><FONT COLOR="#BC8F8F">&quot;finalizing empty&quot;</FONT></B>);
                          back_finalize(opt, cache, sback, i);
                        } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (!back[i].r.is_chunk) {       <I><FONT COLOR="#B22222">// pas de chunk
</FONT></I>                          <I><FONT COLOR="#B22222">//if (back[i].r.http11!=2) {    // pas de chunk
</FONT></I>                          back[i].is_chunk = 0;
                          back[i].status = 1;   <I><FONT COLOR="#B22222">// start body
</FONT></I>                        } <B><FONT COLOR="#A020F0">else</FONT></B> {
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">CHUNKDEBUG</FONT>==1
                          printf(<B><FONT COLOR="#BC8F8F">&quot;[%d] chunk encoding detected %s..\n&quot;</FONT></B>,
                                 (<B><FONT COLOR="#228B22">int</FONT></B>) back[i].r.soc, back[i].url_fil);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
                          back[i].is_chunk = 1;
                          back[i].chunk_adr = NULL;
                          back[i].chunk_size = 0;
                          back[i].chunk_blocksize = 0;
                          back[i].status = STATUS_CHUNK_WAIT;   <I><FONT COLOR="#B22222">// start body wait chunk
</FONT></I>                          back[i].r.totalsize = -1;     <I><FONT COLOR="#B22222">/* devalidate size! (rfc) */</FONT></I>
                        }
                        <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].rateout &gt; 0) {
                          back[i].rateout_time = time_local();  <I><FONT COLOR="#B22222">// refresh pour transfer rate
</FONT></I>                        }
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HDEBUG</FONT>
                        printf(<B><FONT COLOR="#BC8F8F">&quot;(buffer) start body!\n&quot;</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
                      } <B><FONT COLOR="#A020F0">else</FONT></B> {  <I><FONT COLOR="#B22222">// mode test, ne pas passer en 1!!
</FONT></I>                        back[i].status = STATUS_READY;  <I><FONT COLOR="#B22222">// READY
</FONT></I>                        back_set_finished(sback, i);
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_DEBUG_CLOSESOCK</FONT>
                        DEBUG_W(<B><FONT COLOR="#BC8F8F">&quot;back_wait(test ok): deletehttp\n&quot;</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
                        deletehttp(&amp;back[i].r);
                        back[i].r.soc = INVALID_SOCKET;
                        <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.statuscode == HTTP_OK) {
                          strcpybuff(back[i].r.msg, <B><FONT COLOR="#BC8F8F">&quot;Test: OK&quot;</FONT></B>);
                          back[i].r.statuscode = STATUSCODE_TEST_OK;    <I><FONT COLOR="#B22222">// test réussi
</FONT></I>                        } <B><FONT COLOR="#A020F0">else</FONT></B> {        <I><FONT COLOR="#B22222">// test a échoué, on ne change rien sauf que l'erreur est à titre indicatif
</FONT></I>                          <B><FONT COLOR="#228B22">char</FONT></B> tempo[1000];

                          strcpybuff(tempo, back[i].r.msg);
                          strcpybuff(back[i].r.msg, <B><FONT COLOR="#BC8F8F">&quot;Test: &quot;</FONT></B>);
                          strcatbuff(back[i].r.msg, tempo);
                        }

                      }
                    }

                  }

                  <I><FONT COLOR="#B22222">/*} */</FONT></I>

                }               <I><FONT COLOR="#B22222">// si LF
</FONT></I>              }                 <I><FONT COLOR="#B22222">// r.size&gt;2
</FONT></I>            }                   <I><FONT COLOR="#B22222">// si == 99
</FONT></I>
          }                     <I><FONT COLOR="#B22222">// si pas d'erreurs
</FONT></I>#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">BDEBUG</FONT>==1
          printf(<B><FONT COLOR="#BC8F8F">&quot;bytes overall: %d\n&quot;</FONT></B>, back[i].r.size);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
        }                       <I><FONT COLOR="#B22222">// données dispo
</FONT></I>
        <I><FONT COLOR="#B22222">// en cas d'erreur cl, supprimer éventuel fichier sur disque
</FONT></I>#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_REMOVE_BAD_FILES</FONT>
        <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status &lt; 0) {
          <B><FONT COLOR="#A020F0">if</FONT></B> (!back[i].testmode) {      <I><FONT COLOR="#B22222">// pas en test
</FONT></I>            UNLINK(back[i].url_sav);    <I><FONT COLOR="#B22222">// éliminer fichier (endommagé)
</FONT></I>            <I><FONT COLOR="#B22222">//printf(&quot;&amp;&amp; %s\n&quot;,back[i].url_sav);
</FONT></I>          }
        }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

        <I><FONT COLOR="#B22222">/* funny log for commandline users */</FONT></I>
        <I><FONT COLOR="#B22222">//if (!opt-&gt;quiet) {  
</FONT></I>        <I><FONT COLOR="#B22222">// petite animation
</FONT></I>        <B><FONT COLOR="#A020F0">if</FONT></B> (opt-&gt;verbosedisplay == 1) {
          <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status == STATUS_READY) {
            <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.statuscode == HTTP_OK)
              printf(<B><FONT COLOR="#BC8F8F">&quot;* %s%s (&quot;</FONT></B> LLintP <B><FONT COLOR="#BC8F8F">&quot; bytes) - OK&quot;</FONT></B> VT_CLREOL <B><FONT COLOR="#BC8F8F">&quot;\r&quot;</FONT></B>,
                     back[i].url_adr, back[i].url_fil, (LLint) back[i].r.size);
            <B><FONT COLOR="#A020F0">else</FONT></B>
              printf(<B><FONT COLOR="#BC8F8F">&quot;* %s%s (&quot;</FONT></B> LLintP <B><FONT COLOR="#BC8F8F">&quot; bytes) - %d&quot;</FONT></B> VT_CLREOL <B><FONT COLOR="#BC8F8F">&quot;\r&quot;</FONT></B>,
                     back[i].url_adr, back[i].url_fil, (LLint) back[i].r.size,
                     back[i].r.statuscode);
            fflush(stdout);
          }
        }
        <I><FONT COLOR="#B22222">//}
</FONT></I>
      }                         <I><FONT COLOR="#B22222">// status&gt;0
</FONT></I>    }                           <I><FONT COLOR="#B22222">// for
</FONT></I>
    <I><FONT COLOR="#B22222">// vérifier timeouts
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B> (gestion_timeout) {
      TStamp act;

      act = time_local();       <I><FONT COLOR="#B22222">// temps en secondes
</FONT></I>      <B><FONT COLOR="#A020F0">for</FONT></B>(i_mod = 0; i_mod &lt; (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>) back_max; i_mod++) {
        <I><FONT COLOR="#B22222">// for(i=0;i&lt;back_max;i++) {
</FONT></I>        <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i = (i_mod + mod_random) % (back_max);

        <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status &gt; 0) {       <I><FONT COLOR="#B22222">// réception/connexion/..
</FONT></I>          <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].timeout &gt; 0) {
            <I><FONT COLOR="#B22222">//printf(&quot;time check %d\n&quot;,((int) (act-back[i].timeout_refresh))-back[i].timeout);
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B> (((<B><FONT COLOR="#228B22">int</FONT></B>) (act - back[i].timeout_refresh)) &gt;= back[i].timeout) {
              hts_log_print(opt, LOG_DEBUG, <B><FONT COLOR="#BC8F8F">&quot;connection timed out for %s%s&quot;</FONT></B>, back[i].url_adr,
                back[i].url_fil);
              <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.soc != INVALID_SOCKET) {
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_DEBUG_CLOSESOCK</FONT>
                DEBUG_W(<B><FONT COLOR="#BC8F8F">&quot;back_wait(timeout): deletehttp\n&quot;</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
                deletehttp(&amp;back[i].r);
              }
              back[i].r.soc = INVALID_SOCKET;
              back[i].r.statuscode = STATUSCODE_TIMEOUT;
              <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status == STATUS_CONNECTING)
                strcpybuff(back[i].r.msg, <B><FONT COLOR="#BC8F8F">&quot;Connect Time Out&quot;</FONT></B>);
              <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status == STATUS_WAIT_DNS)
                strcpybuff(back[i].r.msg, <B><FONT COLOR="#BC8F8F">&quot;DNS Time Out&quot;</FONT></B>);
              <B><FONT COLOR="#A020F0">else</FONT></B>
                strcpybuff(back[i].r.msg, <B><FONT COLOR="#BC8F8F">&quot;Receive Time Out&quot;</FONT></B>);
              back[i].status = STATUS_READY;    <I><FONT COLOR="#B22222">// terminé
</FONT></I>              back_set_finished(sback, i);
            } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> ((back[i].rateout &gt; 0) &amp;&amp; (back[i].status &lt; 99)) {
              <B><FONT COLOR="#A020F0">if</FONT></B> (((<B><FONT COLOR="#228B22">int</FONT></B>) (act - back[i].rateout_time)) &gt;= HTS_WATCHRATE) {      <I><FONT COLOR="#B22222">// checker au bout de 15s
</FONT></I>                <B><FONT COLOR="#A020F0">if</FONT></B> ((<B><FONT COLOR="#228B22">int</FONT></B>) ((back[i].r.size) / (act - back[i].rateout_time)) &lt; back[i].rateout) {        <I><FONT COLOR="#B22222">// trop lent
</FONT></I>                  back[i].status = STATUS_READY;        <I><FONT COLOR="#B22222">// terminé
</FONT></I>                  back_set_finished(sback, i);
                  <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].r.soc != INVALID_SOCKET) {
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">HTS_DEBUG_CLOSESOCK</FONT>
                    DEBUG_W(<B><FONT COLOR="#BC8F8F">&quot;back_wait(rateout): deletehttp\n&quot;</FONT></B>);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
                    deletehttp(&amp;back[i].r);
                  }
                  back[i].r.soc = INVALID_SOCKET;
                  back[i].r.statuscode = STATUSCODE_SLOW;
                  strcpybuff(back[i].r.msg, <B><FONT COLOR="#BC8F8F">&quot;Transfer Rate Too Low&quot;</FONT></B>);
                }
              }
            }
          }
        }
      }
    }
    max_loop--;
    max_loop_chk++;
  } <B><FONT COLOR="#A020F0">while</FONT></B>((busy_state) &amp;&amp; (busy_recv) &amp;&amp; (max_loop &gt; 0));
  <B><FONT COLOR="#A020F0">if</FONT></B> ((!busy_recv) &amp;&amp; (!busy_state)) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (max_loop_chk &gt;= 1) {
      Sleep(10);                <I><FONT COLOR="#B22222">// un tite pause pour éviter les lag..
</FONT></I>    }
  }
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">back_checksize</FONT></B>(httrackp * opt, lien_back * eback, <B><FONT COLOR="#228B22">int</FONT></B> check_only_totalsize) {
  LLint size_to_test;

  <B><FONT COLOR="#A020F0">if</FONT></B> (check_only_totalsize)
    size_to_test = eback-&gt;r.totalsize;
  <B><FONT COLOR="#A020F0">else</FONT></B>
    size_to_test = max(eback-&gt;r.totalsize, eback-&gt;r.size);
  <B><FONT COLOR="#A020F0">if</FONT></B> (size_to_test &gt;= 0) {

    <I><FONT COLOR="#B22222">/* Interdiction taille par le wizard? */</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B> (hts_testlinksize(opt, eback-&gt;url_adr, eback-&gt;url_fil,
                         size_to_test / 1024) == -1) {
      <B><FONT COLOR="#A020F0">return</FONT></B> 0;                 <I><FONT COLOR="#B22222">/* interdit */</FONT></I>
    }

    <I><FONT COLOR="#B22222">/* vérifier taille classique (heml et non html) */</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B> ((istoobig
         (opt, size_to_test, eback-&gt;maxfile_html, eback-&gt;maxfile_nonhtml,
          eback-&gt;r.contenttype))) {
      <B><FONT COLOR="#A020F0">return</FONT></B> 0;                 <I><FONT COLOR="#B22222">/* interdit */</FONT></I>
    }
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> 1;
}

<B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">back_checkmirror</FONT></B>(httrackp * opt) {
  <I><FONT COLOR="#B22222">// Check max size
</FONT></I>  <B><FONT COLOR="#A020F0">if</FONT></B> ((opt-&gt;maxsite &gt; 0) &amp;&amp; (HTS_STAT.stat_bytes &gt;= opt-&gt;maxsite)) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (!opt-&gt;state.stop) {     <I><FONT COLOR="#B22222">/* not yet stopped */</FONT></I>
      hts_log_print(opt, LOG_ERROR,
                    <B><FONT COLOR="#BC8F8F">&quot;More than &quot;</FONT></B> LLintP
                    <B><FONT COLOR="#BC8F8F">&quot; bytes have been transferred.. giving up&quot;</FONT></B>,
                    (LLint) opt-&gt;maxsite);
      <I><FONT COLOR="#B22222">/* cancel mirror smoothly */</FONT></I>
      hts_request_stop(opt, 0);
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> 1;                   <I><FONT COLOR="#B22222">/* don'k break mirror too sharply for size limits, but stop requested */</FONT></I>
    <I><FONT COLOR="#B22222">/*return 0;
     */</FONT></I>
  }
  <I><FONT COLOR="#B22222">// Check max time
</FONT></I>  <B><FONT COLOR="#A020F0">if</FONT></B> ((opt-&gt;maxtime &gt; 0)
      &amp;&amp; ((time_local() - HTS_STAT.stat_timestart) &gt;= opt-&gt;maxtime)) {
    <B><FONT COLOR="#A020F0">if</FONT></B> (!opt-&gt;state.stop) {     <I><FONT COLOR="#B22222">/* not yet stopped */</FONT></I>
      hts_log_print(opt, LOG_ERROR, <B><FONT COLOR="#BC8F8F">&quot;More than %d seconds passed.. giving up&quot;</FONT></B>,
                    opt-&gt;maxtime);
      <I><FONT COLOR="#B22222">/* cancel mirror smoothly */</FONT></I>
      hts_request_stop(opt, 0);
    }
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> 1;                     <I><FONT COLOR="#B22222">/* Ok, go on */</FONT></I>
}

<I><FONT COLOR="#B22222">// octets transférés + add
</FONT></I>LLint <B><FONT COLOR="#0000FF">back_transferred</FONT></B>(LLint nb, struct_back * sback) {
  lien_back *<B><FONT COLOR="#228B22">const</FONT></B> back = sback-&gt;lnk;
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> back_max = sback-&gt;count;
  <B><FONT COLOR="#228B22">int</FONT></B> i;

  <I><FONT COLOR="#B22222">// ajouter octets en instance
</FONT></I>  <B><FONT COLOR="#A020F0">for</FONT></B>(i = 0; i &lt; back_max; i++)
    <B><FONT COLOR="#A020F0">if</FONT></B> ((back[i].status &gt; 0) &amp;&amp; (back[i].status &lt; 99 || back[i].status &gt;= 1000))
      nb += back[i].r.size;
  <I><FONT COLOR="#B22222">// stored (ready) slots
</FONT></I>  <B><FONT COLOR="#A020F0">if</FONT></B> (sback-&gt;ready != NULL) {
#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">HTS_NO_BACK_ON_DISK</FONT>
    nb += sback-&gt;ready_size_bytes;
#<B><FONT COLOR="#5F9EA0">else</FONT></B>
    struct_coucal_enum e = coucal_enum_new(sback-&gt;ready);
    coucal_item *item;

    <B><FONT COLOR="#A020F0">while</FONT></B>((item = coucal_enum_next(&amp;e))) {
      lien_back *ritem = (lien_back *) item-&gt;value.ptr;

      <B><FONT COLOR="#A020F0">if</FONT></B> ((ritem-&gt;status &gt; 0) &amp;&amp; (ritem-&gt;status &lt; 99 || ritem-&gt;status &gt;= 1000))
        nb += ritem-&gt;r.size;
    }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> nb;
}

<I><FONT COLOR="#B22222">// infos backing
</FONT></I><I><FONT COLOR="#B22222">// j: 1 afficher sockets 2 afficher autres 3 tout afficher
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">back_info</FONT></B>(struct_back * sback, <B><FONT COLOR="#228B22">int</FONT></B> i, <B><FONT COLOR="#228B22">int</FONT></B> j, FILE * fp) {
  lien_back *<B><FONT COLOR="#228B22">const</FONT></B> back = sback-&gt;lnk;
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> back_max = sback-&gt;count;

  assertf(i &gt;= 0 &amp;&amp; i &lt; back_max);
  <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status &gt;= 0) {
    <B><FONT COLOR="#228B22">char</FONT></B> BIGSTK s[HTS_URLMAXSIZE * 2 + 1024];

    s[0] = <B><FONT COLOR="#BC8F8F">'\0'</FONT></B>;
    back_infostr(sback, i, j, s);
    strcatbuff(s, LF);
    fprintf(fp, <B><FONT COLOR="#BC8F8F">&quot;%s&quot;</FONT></B>, s);
  }
}

<I><FONT COLOR="#B22222">// infos backing
</FONT></I><I><FONT COLOR="#B22222">// j: 1 afficher sockets 2 afficher autres 3 tout afficher
</FONT></I><B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">back_infostr</FONT></B>(struct_back * sback, <B><FONT COLOR="#228B22">int</FONT></B> i, <B><FONT COLOR="#228B22">int</FONT></B> j, <B><FONT COLOR="#228B22">char</FONT></B> *s) {
  lien_back *<B><FONT COLOR="#228B22">const</FONT></B> back = sback-&gt;lnk;
  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> back_max = sback-&gt;count;

  assertf(i &gt;= 0 &amp;&amp; i &lt; back_max);
  <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status &gt;= 0) {
    <B><FONT COLOR="#228B22">int</FONT></B> aff = 0;

    <B><FONT COLOR="#A020F0">if</FONT></B> (j &amp; 1) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status == STATUS_CONNECTING) {
        strcatbuff(s, <B><FONT COLOR="#BC8F8F">&quot;CONNECT &quot;</FONT></B>);
      } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status == STATUS_WAIT_HEADERS) {
        strcatbuff(s, <B><FONT COLOR="#BC8F8F">&quot;INFOS &quot;</FONT></B>);
        aff = 1;
      } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status == STATUS_CHUNK_WAIT
                 || back[i].status == STATUS_CHUNK_CR) {
        strcatbuff(s, <B><FONT COLOR="#BC8F8F">&quot;INFOSC&quot;</FONT></B>);        <I><FONT COLOR="#B22222">// infos chunk
</FONT></I>        aff = 1;
      } <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status &gt; 0) {
        strcatbuff(s, <B><FONT COLOR="#BC8F8F">&quot;RECEIVE &quot;</FONT></B>);
        aff = 1;
      }
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (j &amp; 2) {
      <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].status == STATUS_READY) {
        <B><FONT COLOR="#A020F0">switch</FONT></B> (back[i].r.statuscode) {
        <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">200</FONT></B>:
          strcatbuff(s, <B><FONT COLOR="#BC8F8F">&quot;READY &quot;</FONT></B>);
          aff = 1;
          <B><FONT COLOR="#A020F0">break</FONT></B>;
        <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">-1</FONT></B>:
          strcatbuff(s, <B><FONT COLOR="#BC8F8F">&quot;ERROR &quot;</FONT></B>);
          aff = 1;
          <B><FONT COLOR="#A020F0">break</FONT></B>;
        <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">-2</FONT></B>:
          strcatbuff(s, <B><FONT COLOR="#BC8F8F">&quot;TIMEOUT &quot;</FONT></B>);
          aff = 1;
          <B><FONT COLOR="#A020F0">break</FONT></B>;
        <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">-3</FONT></B>:
          strcatbuff(s, <B><FONT COLOR="#BC8F8F">&quot;TOOSLOW &quot;</FONT></B>);
          aff = 1;
          <B><FONT COLOR="#A020F0">break</FONT></B>;
        <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">400</FONT></B>:
          strcatbuff(s, <B><FONT COLOR="#BC8F8F">&quot;BADREQUEST &quot;</FONT></B>);
          aff = 1;
          <B><FONT COLOR="#A020F0">break</FONT></B>;
        <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">401</FONT></B>:
        <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">403</FONT></B>:
          strcatbuff(s, <B><FONT COLOR="#BC8F8F">&quot;FORBIDDEN &quot;</FONT></B>);
          aff = 1;
          <B><FONT COLOR="#A020F0">break</FONT></B>;
        <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">404</FONT></B>:
          strcatbuff(s, <B><FONT COLOR="#BC8F8F">&quot;NOT FOUND &quot;</FONT></B>);
          aff = 1;
          <B><FONT COLOR="#A020F0">break</FONT></B>;
        <B><FONT COLOR="#A020F0">case</FONT></B> <B><FONT COLOR="#5F9EA0">500</FONT></B>:
          strcatbuff(s, <B><FONT COLOR="#BC8F8F">&quot;SERVERROR &quot;</FONT></B>);
          aff = 1;
          <B><FONT COLOR="#A020F0">break</FONT></B>;
        <B><FONT COLOR="#5F9EA0">default</FONT></B>:
          {
            <B><FONT COLOR="#228B22">char</FONT></B> s2[256];

            sprintf(s2, <B><FONT COLOR="#BC8F8F">&quot;ERROR(%d)&quot;</FONT></B>, back[i].r.statuscode);
            strcatbuff(s, s2);
          }
          aff = 1;
        }
      }
    }

    <B><FONT COLOR="#A020F0">if</FONT></B> (aff) {
      {
        <B><FONT COLOR="#228B22">char</FONT></B> BIGSTK s2[HTS_URLMAXSIZE * 2 + 1024];

        sprintf(s2, <B><FONT COLOR="#BC8F8F">&quot;\&quot;%s&quot;</FONT></B>, back[i].url_adr);
        strcatbuff(s, s2);

        <B><FONT COLOR="#A020F0">if</FONT></B> (back[i].url_fil[0] != <B><FONT COLOR="#BC8F8F">'/'</FONT></B>)
          strcatbuff(s, <B><FONT COLOR="#BC8F8F">&quot;/&quot;</FONT></B>);
        sprintf(s2, <B><FONT COLOR="#BC8F8F">&quot;%s\&quot; &quot;</FONT></B>, back[i].url_fil);
        strcatbuff(s, s2);
        sprintf(s, LLintP <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B> LLintP <B><FONT COLOR="#BC8F8F">&quot; &quot;</FONT></B>, (LLint) back[i].r.size,
                (LLint) back[i].r.totalsize);
        strcatbuff(s, s2);
      }
    }
  }
}

<I><FONT COLOR="#B22222">// -- backing --
</FONT></I></PRE>
<HR>
<ADDRESS>Generated by <A HREF="http://www.iki.fi/~mtr/genscript/">GNU Enscript 1.6.5.90</A>.</ADDRESS>
</BODY>

<!-- Mirrored from www.httrack.com/src/htsback.c.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 02 Jan 2023 20:31:10 GMT -->
</HTML>
