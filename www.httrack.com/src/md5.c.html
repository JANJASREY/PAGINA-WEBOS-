<!DOCTYPE html PUBLIC "-//IETF//DTD HTML 2.0//EN">
<HTML>

<!-- Mirrored from www.httrack.com/src/md5.c.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 02 Jan 2023 20:33:30 GMT -->
<HEAD>
<TITLE>./md5.c - HTTrack Website Copier</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#1F00FF" ALINK="#FF0000" VLINK="#9900DD">
<A NAME="top">
<A NAME="file1">
<H1>./md5.c</H1>

<PRE>
<I><FONT COLOR="#B22222">/*
* This code implements the MD5 message-digest algorithm.
* The algorithm is due to Ron Rivest.  This code was
* written by Colin Plumb in 1993, no copyright is claimed.
* This code is in the public domain; do with it what you wish.
*
* Equivalent code is available from RSA Data Security, Inc.
* This code has been tested against that, and is equivalent,
* except that you don't need to include two pages of legalese
* with every copy.
*
* To compute the message digest of a chunk of bytes, declare an
* MD5Context structure, pass it to MD5Init, call MD5Update as
* needed on buffers full of bytes, and then call MD5Final, which
* will fill a supplied 16-byte array with the digest.
*/</FONT></I>

<I><FONT COLOR="#B22222">/* #include &quot;config.h&quot; */</FONT></I>

#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string.h&gt;</FONT></B>             <I><FONT COLOR="#B22222">/* for memcpy() */</FONT></I>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;md5.h&quot;</FONT></B>

<B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">byteReverse</FONT></B>(<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *buf, <B><FONT COLOR="#228B22">unsigned</FONT></B> longs);

<I><FONT COLOR="#B22222">/*
* Note: this code is harmless on little-endian machines.
*/</FONT></I>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">byteSwap</FONT></B>(a, b) do { \
  a ^= b; \
  b ^= a; \
  a ^= b; \
} while(0)
<B><FONT COLOR="#228B22">static</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">byteReverse</FONT></B>(<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *buf, <B><FONT COLOR="#228B22">unsigned</FONT></B> longs) {
  <I><FONT COLOR="#B22222">/*uint32 t; */</FONT></I>
  <B><FONT COLOR="#A020F0">do</FONT></B> {
    <I><FONT COLOR="#B22222">/*
       t = (uint32) ((unsigned) buf[3] &lt;&lt; 8 | buf[2]) &lt;&lt; 16 |
       ((unsigned) buf[1] &lt;&lt; 8 | buf[0]);
       *(uint32 *) buf = t;
     */</FONT></I>
    byteSwap(buf[0], buf[3]);
    byteSwap(buf[1], buf[2]);
    buf += 4;
  } <B><FONT COLOR="#A020F0">while</FONT></B>(--longs);
}

<I><FONT COLOR="#B22222">/*
* Start MD5 accumulation.  Set bit count to 0 and buffer to mysterious
* initialization constants.
*/</FONT></I>
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">MD5Init</FONT></B>(<B><FONT COLOR="#228B22">struct</FONT></B> MD5Context *ctx, <B><FONT COLOR="#228B22">int</FONT></B> brokenEndian) {
  ctx-&gt;buf[0] = 0x67452301;
  ctx-&gt;buf[1] = 0xefcdab89;
  ctx-&gt;buf[2] = 0x98badcfe;
  ctx-&gt;buf[3] = 0x10325476;

  ctx-&gt;bits[0] = 0;
  ctx-&gt;bits[1] = 0;

  <I><FONT COLOR="#B22222">/*#ifdef WORDS_BIGENDIAN */</FONT></I>
  <B><FONT COLOR="#A020F0">if</FONT></B> (brokenEndian) {
    ctx-&gt;doByteReverse = 0;
  } <B><FONT COLOR="#A020F0">else</FONT></B> {
    ctx-&gt;doByteReverse = 1;
  }
  <I><FONT COLOR="#B22222">/*#else
     ctx-&gt;doByteReverse = 0;
     #endif
   */</FONT></I>
}

<I><FONT COLOR="#B22222">/*
* Update context to reflect the concatenation of another buffer full
* of bytes.
*/</FONT></I>
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">MD5Update</FONT></B>(<B><FONT COLOR="#228B22">struct</FONT></B> MD5Context *ctx, <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> <B><FONT COLOR="#228B22">const</FONT></B> *buf, <B><FONT COLOR="#228B22">unsigned</FONT></B> len) {
  uint32 t;

  <I><FONT COLOR="#B22222">/* Update bitcount */</FONT></I>

  t = ctx-&gt;bits[0];
  <B><FONT COLOR="#A020F0">if</FONT></B> ((ctx-&gt;bits[0] = t + ((uint32) len &lt;&lt; 3)) &lt; t)
    ctx-&gt;bits[1]++;             <I><FONT COLOR="#B22222">/* Carry from low to high */</FONT></I>
  ctx-&gt;bits[1] += len &gt;&gt; 29;

  t = (t &gt;&gt; 3) &amp; 0x3f;          <I><FONT COLOR="#B22222">/* Bytes already in shsInfo-&gt;data */</FONT></I>

  <I><FONT COLOR="#B22222">/* Handle any leading odd-sized chunks */</FONT></I>

  <B><FONT COLOR="#A020F0">if</FONT></B> (t) {
    <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *p = ctx-&gt;in.ui8 + t;

    t = 64 - t;
    <B><FONT COLOR="#A020F0">if</FONT></B> (len &lt; t) {
      memcpy(p, buf, len);
      <B><FONT COLOR="#A020F0">return</FONT></B>;
    }
    memcpy(p, buf, t);
    <B><FONT COLOR="#A020F0">if</FONT></B> (ctx-&gt;doByteReverse)
      byteReverse(ctx-&gt;in.ui8, 16);
    MD5Transform(ctx-&gt;buf, ctx-&gt;in.ui32);
    buf += t;
    len -= t;
  }
  <I><FONT COLOR="#B22222">/* Process data in 64-byte chunks */</FONT></I>

  <B><FONT COLOR="#A020F0">while</FONT></B>(len &gt;= 64) {
    memcpy(ctx-&gt;in.ui8, buf, 64);
    <B><FONT COLOR="#A020F0">if</FONT></B> (ctx-&gt;doByteReverse)
      byteReverse(ctx-&gt;in.ui8, 16);
    MD5Transform(ctx-&gt;buf, ctx-&gt;in.ui32);
    buf += 64;
    len -= 64;
  }

  <I><FONT COLOR="#B22222">/* Handle any remaining bytes of data. */</FONT></I>

  memcpy(ctx-&gt;in.ui8, buf, len);
}

<I><FONT COLOR="#B22222">/*
* Final wrapup - pad to 64-byte boundary with the bit pattern 
* 1 0* (64-bit count of bits processed, MSB-first)
*/</FONT></I>
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">MD5Final</FONT></B>(<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> digest[16], <B><FONT COLOR="#228B22">struct</FONT></B> MD5Context *ctx) {
  <B><FONT COLOR="#228B22">unsigned</FONT></B> count;
  <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *p;

  <I><FONT COLOR="#B22222">/* Compute number of bytes mod 64 */</FONT></I>
  count = (ctx-&gt;bits[0] &gt;&gt; 3) &amp; 0x3F;

  <I><FONT COLOR="#B22222">/* Set the first char of padding to 0x80.  This is safe since there is
     always at least one byte free */</FONT></I>
  p = ctx-&gt;in.ui8 + count;
  *p++ = 0x80;

  <I><FONT COLOR="#B22222">/* Bytes of padding needed to make 64 bytes */</FONT></I>
  count = 64 - 1 - count;

  <I><FONT COLOR="#B22222">/* Pad out to 56 mod 64 */</FONT></I>
  <B><FONT COLOR="#A020F0">if</FONT></B> (count &lt; 8) {
    <I><FONT COLOR="#B22222">/* Two lots of padding:  Pad the first block to 64 bytes */</FONT></I>
    memset(p, 0, count);
    <B><FONT COLOR="#A020F0">if</FONT></B> (ctx-&gt;doByteReverse)
      byteReverse(ctx-&gt;in.ui8, 16);
    MD5Transform(ctx-&gt;buf, ctx-&gt;in.ui32);

    <I><FONT COLOR="#B22222">/* Now fill the next block with 56 bytes */</FONT></I>
    memset(ctx-&gt;in.ui8, 0, 56);
  } <B><FONT COLOR="#A020F0">else</FONT></B> {
    <I><FONT COLOR="#B22222">/* Pad block to 56 bytes */</FONT></I>
    memset(p, 0, count - 8);
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (ctx-&gt;doByteReverse)
    byteReverse(ctx-&gt;in.ui8, 14);

  <I><FONT COLOR="#B22222">/* Append length in bits and transform */</FONT></I>
  <I><FONT COLOR="#B22222">/* Note: see patch for PAM from Tomas Mraz */</FONT></I>
  ctx-&gt;in.ui32[14] = ctx-&gt;bits[0];
  ctx-&gt;in.ui32[15] = ctx-&gt;bits[1];
  <I><FONT COLOR="#B22222">/*((uint32 *) ctx-&gt;in)[14] = ctx-&gt;bits[0];
     ((uint32 *) ctx-&gt;in)[15] = ctx-&gt;bits[1];
   */</FONT></I>

  MD5Transform(ctx-&gt;buf, ctx-&gt;in.ui32);
  <B><FONT COLOR="#A020F0">if</FONT></B> (ctx-&gt;doByteReverse)
    byteReverse((<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *) ctx-&gt;buf, 4);
  memcpy(digest, ctx-&gt;buf, 16);
  memset(ctx, 0, <B><FONT COLOR="#A020F0">sizeof</FONT></B>(*ctx));  <I><FONT COLOR="#B22222">/* In case it's sensitive */</FONT></I>
}

<I><FONT COLOR="#B22222">/* The four core functions - F1 is optimized somewhat */</FONT></I>

<I><FONT COLOR="#B22222">/* #define F1(x, y, z) (x &amp; y | ~x &amp; z) */</FONT></I>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">F1</FONT></B>(x, y, z) (z ^ (x &amp; (y ^ z)))
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">F2</FONT></B>(x, y, z) F1(z, x, y)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">F3</FONT></B>(x, y, z) (x ^ y ^ z)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">F4</FONT></B>(x, y, z) (y ^ (x | ~z))

<I><FONT COLOR="#B22222">/* This is the central step in the MD5 algorithm. */</FONT></I>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">MD5STEP</FONT></B>(f, w, x, y, z, data, s) \
( w += f(x, y, z) + data,  w = w&lt;&lt;s | w&gt;&gt;(32-s),  w += x )

<I><FONT COLOR="#B22222">/*
* The core of the MD5 algorithm, this alters an existing MD5 hash to
* reflect the addition of 16 longwords of new data.  MD5Update blocks
* the data and converts bytes into longwords for this routine.
*/</FONT></I>
<B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">MD5Transform</FONT></B>(uint32 buf[4], uint32 <B><FONT COLOR="#228B22">const</FONT></B> in[16]) {
  <B><FONT COLOR="#228B22">register</FONT></B> uint32 a, b, c, d;

  a = buf[0];
  b = buf[1];
  c = buf[2];
  d = buf[3];

  MD5STEP(F1, a, b, c, d, in[0] + 0xd76aa478, 7);
  MD5STEP(F1, d, a, b, c, in[1] + 0xe8c7b756, 12);
  MD5STEP(F1, c, d, a, b, in[2] + 0x242070db, 17);
  MD5STEP(F1, b, c, d, a, in[3] + 0xc1bdceee, 22);
  MD5STEP(F1, a, b, c, d, in[4] + 0xf57c0faf, 7);
  MD5STEP(F1, d, a, b, c, in[5] + 0x4787c62a, 12);
  MD5STEP(F1, c, d, a, b, in[6] + 0xa8304613, 17);
  MD5STEP(F1, b, c, d, a, in[7] + 0xfd469501, 22);
  MD5STEP(F1, a, b, c, d, in[8] + 0x698098d8, 7);
  MD5STEP(F1, d, a, b, c, in[9] + 0x8b44f7af, 12);
  MD5STEP(F1, c, d, a, b, in[10] + 0xffff5bb1, 17);
  MD5STEP(F1, b, c, d, a, in[11] + 0x895cd7be, 22);
  MD5STEP(F1, a, b, c, d, in[12] + 0x6b901122, 7);
  MD5STEP(F1, d, a, b, c, in[13] + 0xfd987193, 12);
  MD5STEP(F1, c, d, a, b, in[14] + 0xa679438e, 17);
  MD5STEP(F1, b, c, d, a, in[15] + 0x49b40821, 22);

  MD5STEP(F2, a, b, c, d, in[1] + 0xf61e2562, 5);
  MD5STEP(F2, d, a, b, c, in[6] + 0xc040b340, 9);
  MD5STEP(F2, c, d, a, b, in[11] + 0x265e5a51, 14);
  MD5STEP(F2, b, c, d, a, in[0] + 0xe9b6c7aa, 20);
  MD5STEP(F2, a, b, c, d, in[5] + 0xd62f105d, 5);
  MD5STEP(F2, d, a, b, c, in[10] + 0x02441453, 9);
  MD5STEP(F2, c, d, a, b, in[15] + 0xd8a1e681, 14);
  MD5STEP(F2, b, c, d, a, in[4] + 0xe7d3fbc8, 20);
  MD5STEP(F2, a, b, c, d, in[9] + 0x21e1cde6, 5);
  MD5STEP(F2, d, a, b, c, in[14] + 0xc33707d6, 9);
  MD5STEP(F2, c, d, a, b, in[3] + 0xf4d50d87, 14);
  MD5STEP(F2, b, c, d, a, in[8] + 0x455a14ed, 20);
  MD5STEP(F2, a, b, c, d, in[13] + 0xa9e3e905, 5);
  MD5STEP(F2, d, a, b, c, in[2] + 0xfcefa3f8, 9);
  MD5STEP(F2, c, d, a, b, in[7] + 0x676f02d9, 14);
  MD5STEP(F2, b, c, d, a, in[12] + 0x8d2a4c8a, 20);

  MD5STEP(F3, a, b, c, d, in[5] + 0xfffa3942, 4);
  MD5STEP(F3, d, a, b, c, in[8] + 0x8771f681, 11);
  MD5STEP(F3, c, d, a, b, in[11] + 0x6d9d6122, 16);
  MD5STEP(F3, b, c, d, a, in[14] + 0xfde5380c, 23);
  MD5STEP(F3, a, b, c, d, in[1] + 0xa4beea44, 4);
  MD5STEP(F3, d, a, b, c, in[4] + 0x4bdecfa9, 11);
  MD5STEP(F3, c, d, a, b, in[7] + 0xf6bb4b60, 16);
  MD5STEP(F3, b, c, d, a, in[10] + 0xbebfbc70, 23);
  MD5STEP(F3, a, b, c, d, in[13] + 0x289b7ec6, 4);
  MD5STEP(F3, d, a, b, c, in[0] + 0xeaa127fa, 11);
  MD5STEP(F3, c, d, a, b, in[3] + 0xd4ef3085, 16);
  MD5STEP(F3, b, c, d, a, in[6] + 0x04881d05, 23);
  MD5STEP(F3, a, b, c, d, in[9] + 0xd9d4d039, 4);
  MD5STEP(F3, d, a, b, c, in[12] + 0xe6db99e5, 11);
  MD5STEP(F3, c, d, a, b, in[15] + 0x1fa27cf8, 16);
  MD5STEP(F3, b, c, d, a, in[2] + 0xc4ac5665, 23);

  MD5STEP(F4, a, b, c, d, in[0] + 0xf4292244, 6);
  MD5STEP(F4, d, a, b, c, in[7] + 0x432aff97, 10);
  MD5STEP(F4, c, d, a, b, in[14] + 0xab9423a7, 15);
  MD5STEP(F4, b, c, d, a, in[5] + 0xfc93a039, 21);
  MD5STEP(F4, a, b, c, d, in[12] + 0x655b59c3, 6);
  MD5STEP(F4, d, a, b, c, in[3] + 0x8f0ccc92, 10);
  MD5STEP(F4, c, d, a, b, in[10] + 0xffeff47d, 15);
  MD5STEP(F4, b, c, d, a, in[1] + 0x85845dd1, 21);
  MD5STEP(F4, a, b, c, d, in[8] + 0x6fa87e4f, 6);
  MD5STEP(F4, d, a, b, c, in[15] + 0xfe2ce6e0, 10);
  MD5STEP(F4, c, d, a, b, in[6] + 0xa3014314, 15);
  MD5STEP(F4, b, c, d, a, in[13] + 0x4e0811a1, 21);
  MD5STEP(F4, a, b, c, d, in[4] + 0xf7537e82, 6);
  MD5STEP(F4, d, a, b, c, in[11] + 0xbd3af235, 10);
  MD5STEP(F4, c, d, a, b, in[2] + 0x2ad7d2bb, 15);
  MD5STEP(F4, b, c, d, a, in[9] + 0xeb86d391, 21);

  buf[0] += a;
  buf[1] += b;
  buf[2] += c;
  buf[3] += d;
}
</PRE>
<HR>
<ADDRESS>Generated by <A HREF="http://www.iki.fi/~mtr/genscript/">GNU Enscript 1.6.5.90</A>.</ADDRESS>
</BODY>

<!-- Mirrored from www.httrack.com/src/md5.c.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 02 Jan 2023 20:33:30 GMT -->
</HTML>
