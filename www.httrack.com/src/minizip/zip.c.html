<!DOCTYPE html PUBLIC "-//IETF//DTD HTML 2.0//EN">
<HTML>

<!-- Mirrored from www.httrack.com/src/minizip/zip.c.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 02 Jan 2023 20:33:58 GMT -->
<HEAD>
<TITLE>./minizip/zip.c - HTTrack Website Copier</TITLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#1F00FF" ALINK="#FF0000" VLINK="#9900DD">
<A NAME="top">
<A NAME="file1">
<H1>./minizip/zip.c</H1>

<PRE>
<I><FONT COLOR="#B22222">/* zip.c -- IO on .zip files using zlib
   Version 1.1, February 14h, 2010
   part of the MiniZip project - ( http://www.winimage.com/zLibDll/minizip.html )

         Copyright (C) 1998-2010 Gilles Vollant (minizip) ( http://www.winimage.com/zLibDll/minizip.html )

         Modifications for Zip64 support
         Copyright (C) 2009-2010 Mathias Svensson ( http://result42.com )

         For more info read MiniZip_info.txt

         Changes
   Oct-2009 - Mathias Svensson - Remove old C style function prototypes
   Oct-2009 - Mathias Svensson - Added Zip64 Support when creating new file archives
   Oct-2009 - Mathias Svensson - Did some code cleanup and refactoring to get better overview of some functions.
   Oct-2009 - Mathias Svensson - Added zipRemoveExtraInfoBlock to strip extra field data from its ZIP64 data
                                 It is used when recreting zip archive with RAW when deleting items from a zip.
                                 ZIP64 data is automaticly added to items that needs it, and existing ZIP64 data need to be removed.
   Oct-2009 - Mathias Svensson - Added support for BZIP2 as compression mode (bzip2 lib is required)
   Jan-2010 - back to unzip and minizip 1.0 name scheme, with compatibility layer

*/</FONT></I>


#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;stdio.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;stdlib.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;time.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;zlib.h&quot;</FONT></B>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;zip.h&quot;</FONT></B>

#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">STDC</FONT>
#  <B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;stddef.h&gt;</FONT></B>
#  <B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;string.h&gt;</FONT></B>
#  <B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;stdlib.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">NO_ERRNO_H</FONT>
    <B><FONT COLOR="#228B22">extern</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> errno;
#<B><FONT COLOR="#5F9EA0">else</FONT></B>
#   <B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&lt;errno.h&gt;</FONT></B>
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>


#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">local</FONT>
#  <B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">local</FONT> static
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
<I><FONT COLOR="#B22222">/* compile with -Dlocal if your debugger can't find static symbols */</FONT></I>

#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">VERSIONMADEBY</FONT>
# <B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">VERSIONMADEBY</FONT>   (0x0) <I><FONT COLOR="#B22222">/* platform depedent */</FONT></I>
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">Z_BUFSIZE</FONT>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">Z_BUFSIZE</FONT> (64*1024) //(16384)
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">Z_MAXFILENAMEINZIP</FONT>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">Z_MAXFILENAMEINZIP</FONT> (256)
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">ALLOC</FONT>
# <B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">ALLOC</FONT></B>(size) (malloc(size))
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">TRYFREE</FONT>
# <B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">TRYFREE</FONT></B>(p) {if (p) free(p);}
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

<I><FONT COLOR="#B22222">/*
#define SIZECENTRALDIRITEM (0x2e)
#define SIZEZIPLOCALHEADER (0x1e)
*/</FONT></I>

<I><FONT COLOR="#B22222">/* I've found an old Unix (a SunOS 4.1.3_U1) without all SEEK_* defined.... */</FONT></I>


<I><FONT COLOR="#B22222">// NOT sure that this work on ALL platform
</FONT></I>#<B><FONT COLOR="#5F9EA0">define</FONT></B> <B><FONT COLOR="#0000FF">MAKEULONG64</FONT></B>(a, b) ((ZPOS64_T)(((unsigned long)(a)) | ((ZPOS64_T)((unsigned long)(b))) &lt;&lt; 32))

#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">SEEK_CUR</FONT>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">SEEK_CUR</FONT>    1
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">SEEK_END</FONT>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">SEEK_END</FONT>    2
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">SEEK_SET</FONT>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">SEEK_SET</FONT>    0
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">DEF_MEM_LEVEL</FONT>
#<B><FONT COLOR="#5F9EA0">if</FONT></B> <FONT COLOR="#B8860B">MAX_MEM_LEVEL</FONT> &gt;= 8
#  <B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">DEF_MEM_LEVEL</FONT> 8
#<B><FONT COLOR="#5F9EA0">else</FONT></B>
#  <B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">DEF_MEM_LEVEL</FONT>  MAX_MEM_LEVEL
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> zip_copyright[] =<B><FONT COLOR="#BC8F8F">&quot; zip 1.01 Copyright 1998-2004 Gilles Vollant - http://www.winimage.com/zLibDll&quot;</FONT></B>;


#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">SIZEDATA_INDATABLOCK</FONT> (4096-(4*4))

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">LOCALHEADERMAGIC</FONT>    (0x04034b50)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">CENTRALHEADERMAGIC</FONT>  (0x02014b50)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">ENDHEADERMAGIC</FONT>      (0x06054b50)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">ZIP64ENDHEADERMAGIC</FONT>      (0x6064b50)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">ZIP64ENDLOCHEADERMAGIC</FONT>   (0x7064b50)

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">FLAG_LOCALHEADER_OFFSET</FONT> (0x06)
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">CRC_LOCALHEADER_OFFSET</FONT>  (0x0e)

#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">SIZECENTRALHEADER</FONT> (0x2e) <I><FONT COLOR="#B22222">/* 46 */</FONT></I>

<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">struct</FONT></B> linkedlist_datablock_internal_s
{
  <B><FONT COLOR="#228B22">struct</FONT></B> linkedlist_datablock_internal_s* next_datablock;
  uLong  avail_in_this_block;
  uLong  filled_in_this_block;
  uLong  unused; <I><FONT COLOR="#B22222">/* for future use and alignement */</FONT></I>
  <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> data[SIZEDATA_INDATABLOCK];
} linkedlist_datablock_internal;

<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">struct</FONT></B> linkedlist_data_s
{
    linkedlist_datablock_internal* first_block;
    linkedlist_datablock_internal* last_block;
} linkedlist_data;


<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">struct</FONT></B>
{
    z_stream stream;            <I><FONT COLOR="#B22222">/* zLib stream structure for inflate */</FONT></I>
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">HAVE_BZIP2</FONT>
    bz_stream bstream;          <I><FONT COLOR="#B22222">/* bzLib stream structure for bziped */</FONT></I>
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

    <B><FONT COLOR="#228B22">int</FONT></B>  stream_initialised;    <I><FONT COLOR="#B22222">/* 1 is stream is initialised */</FONT></I>
    uInt pos_in_buffered_data;  <I><FONT COLOR="#B22222">/* last written byte in buffered_data */</FONT></I>

    ZPOS64_T pos_local_header;     <I><FONT COLOR="#B22222">/* offset of the local header of the file
                                     currenty writing */</FONT></I>
    <B><FONT COLOR="#228B22">char</FONT></B>* central_header;       <I><FONT COLOR="#B22222">/* central header data for the current file */</FONT></I>
    uLong size_centralExtra;
    uLong size_centralheader;   <I><FONT COLOR="#B22222">/* size of the central header for cur file */</FONT></I>
    uLong size_centralExtraFree; <I><FONT COLOR="#B22222">/* Extra bytes allocated to the centralheader but that are not used */</FONT></I>
    uLong flag;                 <I><FONT COLOR="#B22222">/* flag of the file currently writing */</FONT></I>

    <B><FONT COLOR="#228B22">int</FONT></B>  method;                <I><FONT COLOR="#B22222">/* compression method of file currenty wr.*/</FONT></I>
    <B><FONT COLOR="#228B22">int</FONT></B>  raw;                   <I><FONT COLOR="#B22222">/* 1 for directly writing raw data */</FONT></I>
    Byte buffered_data[Z_BUFSIZE];<I><FONT COLOR="#B22222">/* buffer contain compressed data to be writ*/</FONT></I>
    uLong dosDate;
    uLong crc32;
    <B><FONT COLOR="#228B22">int</FONT></B>  encrypt;
    <B><FONT COLOR="#228B22">int</FONT></B>  zip64;               <I><FONT COLOR="#B22222">/* Add ZIP64 extened information in the extra field */</FONT></I>
    ZPOS64_T pos_zip64extrainfo;
    ZPOS64_T totalCompressedData;
    ZPOS64_T totalUncompressedData;
#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">NOCRYPT</FONT>
    <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">long</FONT></B> keys[3];     <I><FONT COLOR="#B22222">/* keys defining the pseudo-random sequence */</FONT></I>
    <B><FONT COLOR="#228B22">const</FONT></B> z_crc_t* pcrc_32_tab;
    <B><FONT COLOR="#228B22">int</FONT></B> crypt_header_size;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
} curfile64_info;

<B><FONT COLOR="#228B22">typedef</FONT></B> <B><FONT COLOR="#228B22">struct</FONT></B>
{
    zlib_filefunc64_32_def z_filefunc;
    voidpf filestream;        <I><FONT COLOR="#B22222">/* io structore of the zipfile */</FONT></I>
    linkedlist_data central_dir;<I><FONT COLOR="#B22222">/* datablock with central dir in construction*/</FONT></I>
    <B><FONT COLOR="#228B22">int</FONT></B>  in_opened_file_inzip;  <I><FONT COLOR="#B22222">/* 1 if a file in the zip is currently writ.*/</FONT></I>
    curfile64_info ci;            <I><FONT COLOR="#B22222">/* info on the file curretly writing */</FONT></I>

    ZPOS64_T begin_pos;            <I><FONT COLOR="#B22222">/* position of the beginning of the zipfile */</FONT></I>
    ZPOS64_T add_position_when_writting_offset;
    ZPOS64_T number_entry;

#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">NO_ADDFILEINEXISTINGZIP</FONT>
    <B><FONT COLOR="#228B22">char</FONT></B> *globalcomment;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

} zip64_internal;


#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">NOCRYPT</FONT>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">INCLUDECRYPTINGCODE_IFCRYPTALLOWED</FONT>
#<B><FONT COLOR="#5F9EA0">include</FONT></B> <B><FONT COLOR="#BC8F8F">&quot;crypt.h&quot;</FONT></B>
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

local linkedlist_datablock_internal* <B><FONT COLOR="#0000FF">allocate_new_datablock</FONT></B>(<B><FONT COLOR="#228B22">void</FONT></B>)
{
    linkedlist_datablock_internal* ldi;
    ldi = (linkedlist_datablock_internal*)
                 ALLOC(<B><FONT COLOR="#A020F0">sizeof</FONT></B>(linkedlist_datablock_internal));
    <B><FONT COLOR="#A020F0">if</FONT></B> (ldi!=NULL)
    {
        ldi-&gt;next_datablock = NULL ;
        ldi-&gt;filled_in_this_block = 0 ;
        ldi-&gt;avail_in_this_block = SIZEDATA_INDATABLOCK ;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> ldi;
}

local <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">free_datablock</FONT></B>(linkedlist_datablock_internal* ldi)
{
    <B><FONT COLOR="#A020F0">while</FONT></B> (ldi!=NULL)
    {
        linkedlist_datablock_internal* ldinext = ldi-&gt;next_datablock;
        TRYFREE(ldi);
        ldi = ldinext;
    }
}

local <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">init_linkedlist</FONT></B>(linkedlist_data* ll)
{
    ll-&gt;first_block = ll-&gt;last_block = NULL;
}

local <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">free_linkedlist</FONT></B>(linkedlist_data* ll)
{
    free_datablock(ll-&gt;first_block);
    ll-&gt;first_block = ll-&gt;last_block = NULL;
}


local <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">add_data_in_datablock</FONT></B>(linkedlist_data* ll, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B>* buf, uLong len)
{
    linkedlist_datablock_internal* ldi;
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>* from_copy;

    <B><FONT COLOR="#A020F0">if</FONT></B> (ll==NULL)
        <B><FONT COLOR="#A020F0">return</FONT></B> ZIP_INTERNALERROR;

    <B><FONT COLOR="#A020F0">if</FONT></B> (ll-&gt;last_block == NULL)
    {
        ll-&gt;first_block = ll-&gt;last_block = allocate_new_datablock();
        <B><FONT COLOR="#A020F0">if</FONT></B> (ll-&gt;first_block == NULL)
            <B><FONT COLOR="#A020F0">return</FONT></B> ZIP_INTERNALERROR;
    }

    ldi = ll-&gt;last_block;
    from_copy = (<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>*)buf;

    <B><FONT COLOR="#A020F0">while</FONT></B> (len&gt;0)
    {
        uInt copy_this;
        uInt i;
        <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>* to_copy;

        <B><FONT COLOR="#A020F0">if</FONT></B> (ldi-&gt;avail_in_this_block==0)
        {
            ldi-&gt;next_datablock = allocate_new_datablock();
            <B><FONT COLOR="#A020F0">if</FONT></B> (ldi-&gt;next_datablock == NULL)
                <B><FONT COLOR="#A020F0">return</FONT></B> ZIP_INTERNALERROR;
            ldi = ldi-&gt;next_datablock ;
            ll-&gt;last_block = ldi;
        }

        <B><FONT COLOR="#A020F0">if</FONT></B> (ldi-&gt;avail_in_this_block &lt; len)
            copy_this = (uInt)ldi-&gt;avail_in_this_block;
        <B><FONT COLOR="#A020F0">else</FONT></B>
            copy_this = (uInt)len;

        to_copy = &amp;(ldi-&gt;data[ldi-&gt;filled_in_this_block]);

        <B><FONT COLOR="#A020F0">for</FONT></B> (i=0;i&lt;copy_this;i++)
            *(to_copy+i)=*(from_copy+i);

        ldi-&gt;filled_in_this_block += copy_this;
        ldi-&gt;avail_in_this_block -= copy_this;
        from_copy += copy_this ;
        len -= copy_this;
    }
    <B><FONT COLOR="#A020F0">return</FONT></B> ZIP_OK;
}



<I><FONT COLOR="#B22222">/****************************************************************************/</FONT></I>

#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">NO_ADDFILEINEXISTINGZIP</FONT>
<I><FONT COLOR="#B22222">/* ===========================================================================
   Inputs a long in LSB order to the given file
   nbByte == 1, 2 ,4 or 8 (byte, short or long, ZPOS64_T)
*/</FONT></I>

local <B><FONT COLOR="#228B22">int</FONT></B> zip64local_putValue <B><FONT COLOR="#0000FF">OF</FONT></B>((<B><FONT COLOR="#228B22">const</FONT></B> zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, ZPOS64_T x, <B><FONT COLOR="#228B22">int</FONT></B> nbByte));
local <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">zip64local_putValue</FONT></B> (<B><FONT COLOR="#228B22">const</FONT></B> zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, ZPOS64_T x, <B><FONT COLOR="#228B22">int</FONT></B> nbByte)
{
    <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> buf[8];
    <B><FONT COLOR="#228B22">int</FONT></B> n;
    <B><FONT COLOR="#A020F0">for</FONT></B> (n = 0; n &lt; nbByte; n++)
    {
        buf[n] = (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>)(x &amp; 0xff);
        x &gt;&gt;= 8;
    }
    <B><FONT COLOR="#A020F0">if</FONT></B> (x != 0)
      {     <I><FONT COLOR="#B22222">/* data overflow - hack for ZIP64 (X Roche) */</FONT></I>
      <B><FONT COLOR="#A020F0">for</FONT></B> (n = 0; n &lt; nbByte; n++)
        {
          buf[n] = 0xff;
        }
      }

    <B><FONT COLOR="#A020F0">if</FONT></B> (ZWRITE64(*pzlib_filefunc_def,filestream,buf,nbByte)!=(uLong)nbByte)
        <B><FONT COLOR="#A020F0">return</FONT></B> ZIP_ERRNO;
    <B><FONT COLOR="#A020F0">else</FONT></B>
        <B><FONT COLOR="#A020F0">return</FONT></B> ZIP_OK;
}

local <B><FONT COLOR="#228B22">void</FONT></B> zip64local_putValue_inmemory <B><FONT COLOR="#0000FF">OF</FONT></B>((<B><FONT COLOR="#228B22">void</FONT></B>* dest, ZPOS64_T x, <B><FONT COLOR="#228B22">int</FONT></B> nbByte));
local <B><FONT COLOR="#228B22">void</FONT></B> <B><FONT COLOR="#0000FF">zip64local_putValue_inmemory</FONT></B> (<B><FONT COLOR="#228B22">void</FONT></B>* dest, ZPOS64_T x, <B><FONT COLOR="#228B22">int</FONT></B> nbByte)
{
    <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>* buf=(<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>*)dest;
    <B><FONT COLOR="#228B22">int</FONT></B> n;
    <B><FONT COLOR="#A020F0">for</FONT></B> (n = 0; n &lt; nbByte; n++) {
        buf[n] = (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>)(x &amp; 0xff);
        x &gt;&gt;= 8;
    }

    <B><FONT COLOR="#A020F0">if</FONT></B> (x != 0)
    {     <I><FONT COLOR="#B22222">/* data overflow - hack for ZIP64 */</FONT></I>
       <B><FONT COLOR="#A020F0">for</FONT></B> (n = 0; n &lt; nbByte; n++)
       {
          buf[n] = 0xff;
       }
    }
}

<I><FONT COLOR="#B22222">/****************************************************************************/</FONT></I>


local uLong <B><FONT COLOR="#0000FF">zip64local_TmzDateToDosDate</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> tm_zip* ptm)
{
    uLong year = (uLong)ptm-&gt;tm_year;
    <B><FONT COLOR="#A020F0">if</FONT></B> (year&gt;=1980)
        year-=1980;
    <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (year&gt;=80)
        year-=80;
    <B><FONT COLOR="#A020F0">return</FONT></B>
      (uLong) (((ptm-&gt;tm_mday) + (32 * (ptm-&gt;tm_mon+1)) + (512 * year)) &lt;&lt; 16) |
        ((ptm-&gt;tm_sec/2) + (32* ptm-&gt;tm_min) + (2048 * (uLong)ptm-&gt;tm_hour));
}


<I><FONT COLOR="#B22222">/****************************************************************************/</FONT></I>

local <B><FONT COLOR="#228B22">int</FONT></B> zip64local_getByte <B><FONT COLOR="#0000FF">OF</FONT></B>((<B><FONT COLOR="#228B22">const</FONT></B> zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, <B><FONT COLOR="#228B22">int</FONT></B> *pi));

local <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">zip64local_getByte</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> zlib_filefunc64_32_def* pzlib_filefunc_def,voidpf filestream,<B><FONT COLOR="#228B22">int</FONT></B>* pi)
{
    <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> c;
    <B><FONT COLOR="#228B22">int</FONT></B> err = (<B><FONT COLOR="#228B22">int</FONT></B>)ZREAD64(*pzlib_filefunc_def,filestream,&amp;c,1);
    <B><FONT COLOR="#A020F0">if</FONT></B> (err==1)
    {
        *pi = (<B><FONT COLOR="#228B22">int</FONT></B>)c;
        <B><FONT COLOR="#A020F0">return</FONT></B> ZIP_OK;
    }
    <B><FONT COLOR="#A020F0">else</FONT></B>
    {
        <B><FONT COLOR="#A020F0">if</FONT></B> (ZERROR64(*pzlib_filefunc_def,filestream))
            <B><FONT COLOR="#A020F0">return</FONT></B> ZIP_ERRNO;
        <B><FONT COLOR="#A020F0">else</FONT></B>
            <B><FONT COLOR="#A020F0">return</FONT></B> ZIP_EOF;
    }
}


<I><FONT COLOR="#B22222">/* ===========================================================================
   Reads a long in LSB order from the given gz_stream. Sets
*/</FONT></I>
local <B><FONT COLOR="#228B22">int</FONT></B> zip64local_getShort <B><FONT COLOR="#0000FF">OF</FONT></B>((<B><FONT COLOR="#228B22">const</FONT></B> zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, uLong *pX));

local <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">zip64local_getShort</FONT></B> (<B><FONT COLOR="#228B22">const</FONT></B> zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, uLong* pX)
{
    uLong x ;
    <B><FONT COLOR="#228B22">int</FONT></B> i = 0;
    <B><FONT COLOR="#228B22">int</FONT></B> err;

    err = zip64local_getByte(pzlib_filefunc_def,filestream,&amp;i);
    x = (uLong)i;

    <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK)
        err = zip64local_getByte(pzlib_filefunc_def,filestream,&amp;i);
    x += ((uLong)i)&lt;&lt;8;

    <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK)
        *pX = x;
    <B><FONT COLOR="#A020F0">else</FONT></B>
        *pX = 0;
    <B><FONT COLOR="#A020F0">return</FONT></B> err;
}

local <B><FONT COLOR="#228B22">int</FONT></B> zip64local_getLong <B><FONT COLOR="#0000FF">OF</FONT></B>((<B><FONT COLOR="#228B22">const</FONT></B> zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, uLong *pX));

local <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">zip64local_getLong</FONT></B> (<B><FONT COLOR="#228B22">const</FONT></B> zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, uLong* pX)
{
    uLong x ;
    <B><FONT COLOR="#228B22">int</FONT></B> i = 0;
    <B><FONT COLOR="#228B22">int</FONT></B> err;

    err = zip64local_getByte(pzlib_filefunc_def,filestream,&amp;i);
    x = (uLong)i;

    <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK)
        err = zip64local_getByte(pzlib_filefunc_def,filestream,&amp;i);
    x += ((uLong)i)&lt;&lt;8;

    <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK)
        err = zip64local_getByte(pzlib_filefunc_def,filestream,&amp;i);
    x += ((uLong)i)&lt;&lt;16;

    <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK)
        err = zip64local_getByte(pzlib_filefunc_def,filestream,&amp;i);
    x += ((uLong)i)&lt;&lt;24;

    <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK)
        *pX = x;
    <B><FONT COLOR="#A020F0">else</FONT></B>
        *pX = 0;
    <B><FONT COLOR="#A020F0">return</FONT></B> err;
}

local <B><FONT COLOR="#228B22">int</FONT></B> zip64local_getLong64 <B><FONT COLOR="#0000FF">OF</FONT></B>((<B><FONT COLOR="#228B22">const</FONT></B> zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, ZPOS64_T *pX));


local <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">zip64local_getLong64</FONT></B> (<B><FONT COLOR="#228B22">const</FONT></B> zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream, ZPOS64_T *pX)
{
  ZPOS64_T x;
  <B><FONT COLOR="#228B22">int</FONT></B> i = 0;
  <B><FONT COLOR="#228B22">int</FONT></B> err;

  err = zip64local_getByte(pzlib_filefunc_def,filestream,&amp;i);
  x = (ZPOS64_T)i;

  <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK)
    err = zip64local_getByte(pzlib_filefunc_def,filestream,&amp;i);
  x += ((ZPOS64_T)i)&lt;&lt;8;

  <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK)
    err = zip64local_getByte(pzlib_filefunc_def,filestream,&amp;i);
  x += ((ZPOS64_T)i)&lt;&lt;16;

  <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK)
    err = zip64local_getByte(pzlib_filefunc_def,filestream,&amp;i);
  x += ((ZPOS64_T)i)&lt;&lt;24;

  <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK)
    err = zip64local_getByte(pzlib_filefunc_def,filestream,&amp;i);
  x += ((ZPOS64_T)i)&lt;&lt;32;

  <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK)
    err = zip64local_getByte(pzlib_filefunc_def,filestream,&amp;i);
  x += ((ZPOS64_T)i)&lt;&lt;40;

  <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK)
    err = zip64local_getByte(pzlib_filefunc_def,filestream,&amp;i);
  x += ((ZPOS64_T)i)&lt;&lt;48;

  <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK)
    err = zip64local_getByte(pzlib_filefunc_def,filestream,&amp;i);
  x += ((ZPOS64_T)i)&lt;&lt;56;

  <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK)
    *pX = x;
  <B><FONT COLOR="#A020F0">else</FONT></B>
    *pX = 0;

  <B><FONT COLOR="#A020F0">return</FONT></B> err;
}

#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">BUFREADCOMMENT</FONT>
#<B><FONT COLOR="#5F9EA0">define</FONT></B> <FONT COLOR="#B8860B">BUFREADCOMMENT</FONT> (0x400)
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
<I><FONT COLOR="#B22222">/*
  Locate the Central directory of a zipfile (at the end, just before
    the global comment)
*/</FONT></I>
local ZPOS64_T zip64local_SearchCentralDir <B><FONT COLOR="#0000FF">OF</FONT></B>((<B><FONT COLOR="#228B22">const</FONT></B> zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream));

local ZPOS64_T <B><FONT COLOR="#0000FF">zip64local_SearchCentralDir</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream)
{
  <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>* buf;
  ZPOS64_T uSizeFile;
  ZPOS64_T uBackRead;
  ZPOS64_T uMaxBack=0xffff; <I><FONT COLOR="#B22222">/* maximum size of global comment */</FONT></I>
  ZPOS64_T uPosFound=0;

  <B><FONT COLOR="#A020F0">if</FONT></B> (ZSEEK64(*pzlib_filefunc_def,filestream,0,ZLIB_FILEFUNC_SEEK_END) != 0)
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;


  uSizeFile = ZTELL64(*pzlib_filefunc_def,filestream);

  <B><FONT COLOR="#A020F0">if</FONT></B> (uMaxBack&gt;uSizeFile)
    uMaxBack = uSizeFile;

  buf = (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>*)ALLOC(BUFREADCOMMENT+4);
  <B><FONT COLOR="#A020F0">if</FONT></B> (buf==NULL)
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;

  uBackRead = 4;
  <B><FONT COLOR="#A020F0">while</FONT></B> (uBackRead&lt;uMaxBack)
  {
    uLong uReadSize;
    ZPOS64_T uReadPos ;
    <B><FONT COLOR="#228B22">int</FONT></B> i;
    <B><FONT COLOR="#A020F0">if</FONT></B> (uBackRead+BUFREADCOMMENT&gt;uMaxBack)
      uBackRead = uMaxBack;
    <B><FONT COLOR="#A020F0">else</FONT></B>
      uBackRead+=BUFREADCOMMENT;
    uReadPos = uSizeFile-uBackRead ;

    uReadSize = ((BUFREADCOMMENT+4) &lt; (uSizeFile-uReadPos)) ?
      (BUFREADCOMMENT+4) : (uLong)(uSizeFile-uReadPos);
    <B><FONT COLOR="#A020F0">if</FONT></B> (ZSEEK64(*pzlib_filefunc_def,filestream,uReadPos,ZLIB_FILEFUNC_SEEK_SET)!=0)
      <B><FONT COLOR="#A020F0">break</FONT></B>;

    <B><FONT COLOR="#A020F0">if</FONT></B> (ZREAD64(*pzlib_filefunc_def,filestream,buf,uReadSize)!=uReadSize)
      <B><FONT COLOR="#A020F0">break</FONT></B>;

    <B><FONT COLOR="#A020F0">for</FONT></B> (i=(<B><FONT COLOR="#228B22">int</FONT></B>)uReadSize-3; (i--)&gt;0;)
      <B><FONT COLOR="#A020F0">if</FONT></B> (((*(buf+i))==0x50) &amp;&amp; ((*(buf+i+1))==0x4b) &amp;&amp;
        ((*(buf+i+2))==0x05) &amp;&amp; ((*(buf+i+3))==0x06))
      {
        uPosFound = uReadPos+i;
        <B><FONT COLOR="#A020F0">break</FONT></B>;
      }

      <B><FONT COLOR="#A020F0">if</FONT></B> (uPosFound!=0)
        <B><FONT COLOR="#A020F0">break</FONT></B>;
  }
  TRYFREE(buf);
  <B><FONT COLOR="#A020F0">return</FONT></B> uPosFound;
}

<I><FONT COLOR="#B22222">/*
Locate the End of Zip64 Central directory locator and from there find the CD of a zipfile (at the end, just before
the global comment)
*/</FONT></I>
local ZPOS64_T zip64local_SearchCentralDir64 <B><FONT COLOR="#0000FF">OF</FONT></B>((<B><FONT COLOR="#228B22">const</FONT></B> zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream));

local ZPOS64_T <B><FONT COLOR="#0000FF">zip64local_SearchCentralDir64</FONT></B>(<B><FONT COLOR="#228B22">const</FONT></B> zlib_filefunc64_32_def* pzlib_filefunc_def, voidpf filestream)
{
  <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>* buf;
  ZPOS64_T uSizeFile;
  ZPOS64_T uBackRead;
  ZPOS64_T uMaxBack=0xffff; <I><FONT COLOR="#B22222">/* maximum size of global comment */</FONT></I>
  ZPOS64_T uPosFound=0;
  uLong uL;
  ZPOS64_T relativeOffset;

  <B><FONT COLOR="#A020F0">if</FONT></B> (ZSEEK64(*pzlib_filefunc_def,filestream,0,ZLIB_FILEFUNC_SEEK_END) != 0)
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;

  uSizeFile = ZTELL64(*pzlib_filefunc_def,filestream);

  <B><FONT COLOR="#A020F0">if</FONT></B> (uMaxBack&gt;uSizeFile)
    uMaxBack = uSizeFile;

  buf = (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>*)ALLOC(BUFREADCOMMENT+4);
  <B><FONT COLOR="#A020F0">if</FONT></B> (buf==NULL)
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;

  uBackRead = 4;
  <B><FONT COLOR="#A020F0">while</FONT></B> (uBackRead&lt;uMaxBack)
  {
    uLong uReadSize;
    ZPOS64_T uReadPos;
    <B><FONT COLOR="#228B22">int</FONT></B> i;
    <B><FONT COLOR="#A020F0">if</FONT></B> (uBackRead+BUFREADCOMMENT&gt;uMaxBack)
      uBackRead = uMaxBack;
    <B><FONT COLOR="#A020F0">else</FONT></B>
      uBackRead+=BUFREADCOMMENT;
    uReadPos = uSizeFile-uBackRead ;

    uReadSize = ((BUFREADCOMMENT+4) &lt; (uSizeFile-uReadPos)) ?
      (BUFREADCOMMENT+4) : (uLong)(uSizeFile-uReadPos);
    <B><FONT COLOR="#A020F0">if</FONT></B> (ZSEEK64(*pzlib_filefunc_def,filestream,uReadPos,ZLIB_FILEFUNC_SEEK_SET)!=0)
      <B><FONT COLOR="#A020F0">break</FONT></B>;

    <B><FONT COLOR="#A020F0">if</FONT></B> (ZREAD64(*pzlib_filefunc_def,filestream,buf,uReadSize)!=uReadSize)
      <B><FONT COLOR="#A020F0">break</FONT></B>;

    <B><FONT COLOR="#A020F0">for</FONT></B> (i=(<B><FONT COLOR="#228B22">int</FONT></B>)uReadSize-3; (i--)&gt;0;)
    {
      <I><FONT COLOR="#B22222">// Signature &quot;0x07064b50&quot; Zip64 end of central directory locater
</FONT></I>      <B><FONT COLOR="#A020F0">if</FONT></B> (((*(buf+i))==0x50) &amp;&amp; ((*(buf+i+1))==0x4b) &amp;&amp; ((*(buf+i+2))==0x06) &amp;&amp; ((*(buf+i+3))==0x07))
      {
        uPosFound = uReadPos+i;
        <B><FONT COLOR="#A020F0">break</FONT></B>;
      }
    }

      <B><FONT COLOR="#A020F0">if</FONT></B> (uPosFound!=0)
        <B><FONT COLOR="#A020F0">break</FONT></B>;
  }

  TRYFREE(buf);
  <B><FONT COLOR="#A020F0">if</FONT></B> (uPosFound == 0)
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;

  <I><FONT COLOR="#B22222">/* Zip64 end of central directory locator */</FONT></I>
  <B><FONT COLOR="#A020F0">if</FONT></B> (ZSEEK64(*pzlib_filefunc_def,filestream, uPosFound,ZLIB_FILEFUNC_SEEK_SET)!=0)
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;

  <I><FONT COLOR="#B22222">/* the signature, already checked */</FONT></I>
  <B><FONT COLOR="#A020F0">if</FONT></B> (zip64local_getLong(pzlib_filefunc_def,filestream,&amp;uL)!=ZIP_OK)
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;

  <I><FONT COLOR="#B22222">/* number of the disk with the start of the zip64 end of  central directory */</FONT></I>
  <B><FONT COLOR="#A020F0">if</FONT></B> (zip64local_getLong(pzlib_filefunc_def,filestream,&amp;uL)!=ZIP_OK)
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
  <B><FONT COLOR="#A020F0">if</FONT></B> (uL != 0)
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;

  <I><FONT COLOR="#B22222">/* relative offset of the zip64 end of central directory record */</FONT></I>
  <B><FONT COLOR="#A020F0">if</FONT></B> (zip64local_getLong64(pzlib_filefunc_def,filestream,&amp;relativeOffset)!=ZIP_OK)
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;

  <I><FONT COLOR="#B22222">/* total number of disks */</FONT></I>
  <B><FONT COLOR="#A020F0">if</FONT></B> (zip64local_getLong(pzlib_filefunc_def,filestream,&amp;uL)!=ZIP_OK)
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
  <B><FONT COLOR="#A020F0">if</FONT></B> (uL != 1)
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;

  <I><FONT COLOR="#B22222">/* Goto Zip64 end of central directory record */</FONT></I>
  <B><FONT COLOR="#A020F0">if</FONT></B> (ZSEEK64(*pzlib_filefunc_def,filestream, relativeOffset,ZLIB_FILEFUNC_SEEK_SET)!=0)
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;

  <I><FONT COLOR="#B22222">/* the signature */</FONT></I>
  <B><FONT COLOR="#A020F0">if</FONT></B> (zip64local_getLong(pzlib_filefunc_def,filestream,&amp;uL)!=ZIP_OK)
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;

  <B><FONT COLOR="#A020F0">if</FONT></B> (uL != 0x06064b50) <I><FONT COLOR="#B22222">// signature of 'Zip64 end of central directory'
</FONT></I>    <B><FONT COLOR="#A020F0">return</FONT></B> 0;

  <B><FONT COLOR="#A020F0">return</FONT></B> relativeOffset;
}

local <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">LoadCentralDirectoryRecord</FONT></B>(zip64_internal* pziinit)
{
  <B><FONT COLOR="#228B22">int</FONT></B> err=ZIP_OK;
  ZPOS64_T byte_before_the_zipfile;<I><FONT COLOR="#B22222">/* byte before the zipfile, (&gt;0 for sfx)*/</FONT></I>

  ZPOS64_T size_central_dir;     <I><FONT COLOR="#B22222">/* size of the central directory  */</FONT></I>
  ZPOS64_T offset_central_dir;   <I><FONT COLOR="#B22222">/* offset of start of central directory */</FONT></I>
  ZPOS64_T central_pos;
  uLong uL;

  uLong number_disk;          <I><FONT COLOR="#B22222">/* number of the current dist, used for
                              spaning ZIP, unsupported, always 0*/</FONT></I>
  uLong number_disk_with_CD;  <I><FONT COLOR="#B22222">/* number the the disk with central dir, used
                              for spaning ZIP, unsupported, always 0*/</FONT></I>
  ZPOS64_T number_entry;
  ZPOS64_T number_entry_CD;      <I><FONT COLOR="#B22222">/* total number of entries in
                                the central dir
                                (same than number_entry on nospan) */</FONT></I>
  uLong VersionMadeBy;
  uLong VersionNeeded;
  uLong size_comment;

  <B><FONT COLOR="#228B22">int</FONT></B> hasZIP64Record = 0;

  <I><FONT COLOR="#B22222">// check first if we find a ZIP64 record
</FONT></I>  central_pos = zip64local_SearchCentralDir64(&amp;pziinit-&gt;z_filefunc,pziinit-&gt;filestream);
  <B><FONT COLOR="#A020F0">if</FONT></B>(central_pos &gt; 0)
  {
    hasZIP64Record = 1;
  }
  <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(central_pos == 0)
  {
    central_pos = zip64local_SearchCentralDir(&amp;pziinit-&gt;z_filefunc,pziinit-&gt;filestream);
  }

<I><FONT COLOR="#B22222">/* disable to allow appending to empty ZIP archive
        if (central_pos==0)
            err=ZIP_ERRNO;
*/</FONT></I>

  <B><FONT COLOR="#A020F0">if</FONT></B>(hasZIP64Record)
  {
    ZPOS64_T sizeEndOfCentralDirectory;
    <B><FONT COLOR="#A020F0">if</FONT></B> (ZSEEK64(pziinit-&gt;z_filefunc, pziinit-&gt;filestream, central_pos, ZLIB_FILEFUNC_SEEK_SET) != 0)
      err=ZIP_ERRNO;

    <I><FONT COLOR="#B22222">/* the signature, already checked */</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B> (zip64local_getLong(&amp;pziinit-&gt;z_filefunc, pziinit-&gt;filestream,&amp;uL)!=ZIP_OK)
      err=ZIP_ERRNO;

    <I><FONT COLOR="#B22222">/* size of zip64 end of central directory record */</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B> (zip64local_getLong64(&amp;pziinit-&gt;z_filefunc, pziinit-&gt;filestream, &amp;sizeEndOfCentralDirectory)!=ZIP_OK)
      err=ZIP_ERRNO;

    <I><FONT COLOR="#B22222">/* version made by */</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B> (zip64local_getShort(&amp;pziinit-&gt;z_filefunc, pziinit-&gt;filestream, &amp;VersionMadeBy)!=ZIP_OK)
      err=ZIP_ERRNO;

    <I><FONT COLOR="#B22222">/* version needed to extract */</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B> (zip64local_getShort(&amp;pziinit-&gt;z_filefunc, pziinit-&gt;filestream, &amp;VersionNeeded)!=ZIP_OK)
      err=ZIP_ERRNO;

    <I><FONT COLOR="#B22222">/* number of this disk */</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B> (zip64local_getLong(&amp;pziinit-&gt;z_filefunc, pziinit-&gt;filestream,&amp;number_disk)!=ZIP_OK)
      err=ZIP_ERRNO;

    <I><FONT COLOR="#B22222">/* number of the disk with the start of the central directory */</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B> (zip64local_getLong(&amp;pziinit-&gt;z_filefunc, pziinit-&gt;filestream,&amp;number_disk_with_CD)!=ZIP_OK)
      err=ZIP_ERRNO;

    <I><FONT COLOR="#B22222">/* total number of entries in the central directory on this disk */</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B> (zip64local_getLong64(&amp;pziinit-&gt;z_filefunc, pziinit-&gt;filestream, &amp;number_entry)!=ZIP_OK)
      err=ZIP_ERRNO;

    <I><FONT COLOR="#B22222">/* total number of entries in the central directory */</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B> (zip64local_getLong64(&amp;pziinit-&gt;z_filefunc, pziinit-&gt;filestream,&amp;number_entry_CD)!=ZIP_OK)
      err=ZIP_ERRNO;

    <B><FONT COLOR="#A020F0">if</FONT></B> ((number_entry_CD!=number_entry) || (number_disk_with_CD!=0) || (number_disk!=0))
      err=ZIP_BADZIPFILE;

    <I><FONT COLOR="#B22222">/* size of the central directory */</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B> (zip64local_getLong64(&amp;pziinit-&gt;z_filefunc, pziinit-&gt;filestream,&amp;size_central_dir)!=ZIP_OK)
      err=ZIP_ERRNO;

    <I><FONT COLOR="#B22222">/* offset of start of central directory with respect to the
    starting disk number */</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B> (zip64local_getLong64(&amp;pziinit-&gt;z_filefunc, pziinit-&gt;filestream,&amp;offset_central_dir)!=ZIP_OK)
      err=ZIP_ERRNO;

    <I><FONT COLOR="#B22222">// TODO..
</FONT></I>    <I><FONT COLOR="#B22222">// read the comment from the standard central header.
</FONT></I>    size_comment = 0;
  }
  <B><FONT COLOR="#A020F0">else</FONT></B>
  {
    <I><FONT COLOR="#B22222">// Read End of central Directory info
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B> (ZSEEK64(pziinit-&gt;z_filefunc, pziinit-&gt;filestream, central_pos,ZLIB_FILEFUNC_SEEK_SET)!=0)
      err=ZIP_ERRNO;

    <I><FONT COLOR="#B22222">/* the signature, already checked */</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B> (zip64local_getLong(&amp;pziinit-&gt;z_filefunc, pziinit-&gt;filestream,&amp;uL)!=ZIP_OK)
      err=ZIP_ERRNO;

    <I><FONT COLOR="#B22222">/* number of this disk */</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B> (zip64local_getShort(&amp;pziinit-&gt;z_filefunc, pziinit-&gt;filestream,&amp;number_disk)!=ZIP_OK)
      err=ZIP_ERRNO;

    <I><FONT COLOR="#B22222">/* number of the disk with the start of the central directory */</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B> (zip64local_getShort(&amp;pziinit-&gt;z_filefunc, pziinit-&gt;filestream,&amp;number_disk_with_CD)!=ZIP_OK)
      err=ZIP_ERRNO;

    <I><FONT COLOR="#B22222">/* total number of entries in the central dir on this disk */</FONT></I>
    number_entry = 0;
    <B><FONT COLOR="#A020F0">if</FONT></B> (zip64local_getShort(&amp;pziinit-&gt;z_filefunc, pziinit-&gt;filestream, &amp;uL)!=ZIP_OK)
      err=ZIP_ERRNO;
    <B><FONT COLOR="#A020F0">else</FONT></B>
      number_entry = uL;

    <I><FONT COLOR="#B22222">/* total number of entries in the central dir */</FONT></I>
    number_entry_CD = 0;
    <B><FONT COLOR="#A020F0">if</FONT></B> (zip64local_getShort(&amp;pziinit-&gt;z_filefunc, pziinit-&gt;filestream, &amp;uL)!=ZIP_OK)
      err=ZIP_ERRNO;
    <B><FONT COLOR="#A020F0">else</FONT></B>
      number_entry_CD = uL;

    <B><FONT COLOR="#A020F0">if</FONT></B> ((number_entry_CD!=number_entry) || (number_disk_with_CD!=0) || (number_disk!=0))
      err=ZIP_BADZIPFILE;

    <I><FONT COLOR="#B22222">/* size of the central directory */</FONT></I>
    size_central_dir = 0;
    <B><FONT COLOR="#A020F0">if</FONT></B> (zip64local_getLong(&amp;pziinit-&gt;z_filefunc, pziinit-&gt;filestream, &amp;uL)!=ZIP_OK)
      err=ZIP_ERRNO;
    <B><FONT COLOR="#A020F0">else</FONT></B>
      size_central_dir = uL;

    <I><FONT COLOR="#B22222">/* offset of start of central directory with respect to the starting disk number */</FONT></I>
    offset_central_dir = 0;
    <B><FONT COLOR="#A020F0">if</FONT></B> (zip64local_getLong(&amp;pziinit-&gt;z_filefunc, pziinit-&gt;filestream, &amp;uL)!=ZIP_OK)
      err=ZIP_ERRNO;
    <B><FONT COLOR="#A020F0">else</FONT></B>
      offset_central_dir = uL;


    <I><FONT COLOR="#B22222">/* zipfile global comment length */</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B> (zip64local_getShort(&amp;pziinit-&gt;z_filefunc, pziinit-&gt;filestream, &amp;size_comment)!=ZIP_OK)
      err=ZIP_ERRNO;
  }

  <B><FONT COLOR="#A020F0">if</FONT></B> ((central_pos&lt;offset_central_dir+size_central_dir) &amp;&amp;
    (err==ZIP_OK))
    err=ZIP_BADZIPFILE;

  <B><FONT COLOR="#A020F0">if</FONT></B> (err!=ZIP_OK)
  {
    ZCLOSE64(pziinit-&gt;z_filefunc, pziinit-&gt;filestream);
    <B><FONT COLOR="#A020F0">return</FONT></B> ZIP_ERRNO;
  }

  <B><FONT COLOR="#A020F0">if</FONT></B> (size_comment&gt;0)
  {
    pziinit-&gt;globalcomment = (<B><FONT COLOR="#228B22">char</FONT></B>*)ALLOC(size_comment+1);
    <B><FONT COLOR="#A020F0">if</FONT></B> (pziinit-&gt;globalcomment)
    {
      size_comment = ZREAD64(pziinit-&gt;z_filefunc, pziinit-&gt;filestream, pziinit-&gt;globalcomment,size_comment);
      pziinit-&gt;globalcomment[size_comment]=0;
    }
  }

  byte_before_the_zipfile = central_pos - (offset_central_dir+size_central_dir);
  pziinit-&gt;add_position_when_writting_offset = byte_before_the_zipfile;

  {
    ZPOS64_T size_central_dir_to_read = size_central_dir;
    size_t buf_size = SIZEDATA_INDATABLOCK;
    <B><FONT COLOR="#228B22">void</FONT></B>* buf_read = (<B><FONT COLOR="#228B22">void</FONT></B>*)ALLOC(buf_size);
    <B><FONT COLOR="#A020F0">if</FONT></B> (ZSEEK64(pziinit-&gt;z_filefunc, pziinit-&gt;filestream, offset_central_dir + byte_before_the_zipfile, ZLIB_FILEFUNC_SEEK_SET) != 0)
      err=ZIP_ERRNO;

    <B><FONT COLOR="#A020F0">while</FONT></B> ((size_central_dir_to_read&gt;0) &amp;&amp; (err==ZIP_OK))
    {
      ZPOS64_T read_this = SIZEDATA_INDATABLOCK;
      <B><FONT COLOR="#A020F0">if</FONT></B> (read_this &gt; size_central_dir_to_read)
        read_this = size_central_dir_to_read;

      <B><FONT COLOR="#A020F0">if</FONT></B> (ZREAD64(pziinit-&gt;z_filefunc, pziinit-&gt;filestream,buf_read,(uLong)read_this) != read_this)
        err=ZIP_ERRNO;

      <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK)
        err = add_data_in_datablock(&amp;pziinit-&gt;central_dir,buf_read, (uLong)read_this);

      size_central_dir_to_read-=read_this;
    }
    TRYFREE(buf_read);
  }
  pziinit-&gt;begin_pos = byte_before_the_zipfile;
  pziinit-&gt;number_entry = number_entry_CD;

  <B><FONT COLOR="#A020F0">if</FONT></B> (ZSEEK64(pziinit-&gt;z_filefunc, pziinit-&gt;filestream, offset_central_dir+byte_before_the_zipfile,ZLIB_FILEFUNC_SEEK_SET) != 0)
    err=ZIP_ERRNO;

  <B><FONT COLOR="#A020F0">return</FONT></B> err;
}


#<B><FONT COLOR="#5F9EA0">endif</FONT></B> <I><FONT COLOR="#B22222">/* !NO_ADDFILEINEXISTINGZIP*/</FONT></I>


<I><FONT COLOR="#B22222">/************************************************************/</FONT></I>
<B><FONT COLOR="#228B22">extern</FONT></B> zipFile ZEXPORT <B><FONT COLOR="#0000FF">zipOpen3</FONT></B> (<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> *pathname, <B><FONT COLOR="#228B22">int</FONT></B> append, zipcharpc* globalcomment, zlib_filefunc64_32_def* pzlib_filefunc64_32_def)
{
    zip64_internal ziinit;
    zip64_internal* zi;
    <B><FONT COLOR="#228B22">int</FONT></B> err=ZIP_OK;

    ziinit.z_filefunc.zseek32_file = NULL;
    ziinit.z_filefunc.ztell32_file = NULL;
    <B><FONT COLOR="#A020F0">if</FONT></B> (pzlib_filefunc64_32_def==NULL)
        fill_fopen64_filefunc(&amp;ziinit.z_filefunc.zfile_func64);
    <B><FONT COLOR="#A020F0">else</FONT></B>
        ziinit.z_filefunc = *pzlib_filefunc64_32_def;

    ziinit.filestream = ZOPEN64(ziinit.z_filefunc,
                  pathname,
                  (append == APPEND_STATUS_CREATE) ?
                  (ZLIB_FILEFUNC_MODE_READ | ZLIB_FILEFUNC_MODE_WRITE | ZLIB_FILEFUNC_MODE_CREATE) :
                    (ZLIB_FILEFUNC_MODE_READ | ZLIB_FILEFUNC_MODE_WRITE | ZLIB_FILEFUNC_MODE_EXISTING));

    <B><FONT COLOR="#A020F0">if</FONT></B> (ziinit.filestream == NULL)
        <B><FONT COLOR="#A020F0">return</FONT></B> NULL;

    <B><FONT COLOR="#A020F0">if</FONT></B> (append == APPEND_STATUS_CREATEAFTER)
        ZSEEK64(ziinit.z_filefunc,ziinit.filestream,0,SEEK_END);

    ziinit.begin_pos = ZTELL64(ziinit.z_filefunc,ziinit.filestream);
    ziinit.in_opened_file_inzip = 0;
    ziinit.ci.stream_initialised = 0;
    ziinit.number_entry = 0;
    ziinit.add_position_when_writting_offset = 0;
    init_linkedlist(&amp;(ziinit.central_dir));



    zi = (zip64_internal*)ALLOC(<B><FONT COLOR="#A020F0">sizeof</FONT></B>(zip64_internal));
    <B><FONT COLOR="#A020F0">if</FONT></B> (zi==NULL)
    {
        ZCLOSE64(ziinit.z_filefunc,ziinit.filestream);
        <B><FONT COLOR="#A020F0">return</FONT></B> NULL;
    }

    <I><FONT COLOR="#B22222">/* now we add file in a zipfile */</FONT></I>
#    <B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">NO_ADDFILEINEXISTINGZIP</FONT>
    ziinit.globalcomment = NULL;
    <B><FONT COLOR="#A020F0">if</FONT></B> (append == APPEND_STATUS_ADDINZIP)
    {
      <I><FONT COLOR="#B22222">// Read and Cache Central Directory Records
</FONT></I>      err = LoadCentralDirectoryRecord(&amp;ziinit);
    }

    <B><FONT COLOR="#A020F0">if</FONT></B> (globalcomment)
    {
      *globalcomment = ziinit.globalcomment;
    }
#    <B><FONT COLOR="#5F9EA0">endif</FONT></B> <I><FONT COLOR="#B22222">/* !NO_ADDFILEINEXISTINGZIP*/</FONT></I>

    <B><FONT COLOR="#A020F0">if</FONT></B> (err != ZIP_OK)
    {
#    <B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">NO_ADDFILEINEXISTINGZIP</FONT>
        TRYFREE(ziinit.globalcomment);
#    <B><FONT COLOR="#5F9EA0">endif</FONT></B> <I><FONT COLOR="#B22222">/* !NO_ADDFILEINEXISTINGZIP*/</FONT></I>
        TRYFREE(zi);
        <B><FONT COLOR="#A020F0">return</FONT></B> NULL;
    }
    <B><FONT COLOR="#A020F0">else</FONT></B>
    {
        *zi = ziinit;
        <B><FONT COLOR="#A020F0">return</FONT></B> (zipFile)zi;
    }
}

<B><FONT COLOR="#228B22">extern</FONT></B> zipFile ZEXPORT <B><FONT COLOR="#0000FF">zipOpen2</FONT></B> (<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> *pathname, <B><FONT COLOR="#228B22">int</FONT></B> append, zipcharpc* globalcomment, zlib_filefunc_def* pzlib_filefunc32_def)
{
    <B><FONT COLOR="#A020F0">if</FONT></B> (pzlib_filefunc32_def != NULL)
    {
        zlib_filefunc64_32_def zlib_filefunc64_32_def_fill;
        fill_zlib_filefunc64_32_def_from_filefunc32(&amp;zlib_filefunc64_32_def_fill,pzlib_filefunc32_def);
        <B><FONT COLOR="#A020F0">return</FONT></B> zipOpen3(pathname, append, globalcomment, &amp;zlib_filefunc64_32_def_fill);
    }
    <B><FONT COLOR="#A020F0">else</FONT></B>
        <B><FONT COLOR="#A020F0">return</FONT></B> zipOpen3(pathname, append, globalcomment, NULL);
}

<B><FONT COLOR="#228B22">extern</FONT></B> zipFile ZEXPORT <B><FONT COLOR="#0000FF">zipOpen2_64</FONT></B> (<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> *pathname, <B><FONT COLOR="#228B22">int</FONT></B> append, zipcharpc* globalcomment, zlib_filefunc64_def* pzlib_filefunc_def)
{
    <B><FONT COLOR="#A020F0">if</FONT></B> (pzlib_filefunc_def != NULL)
    {
        zlib_filefunc64_32_def zlib_filefunc64_32_def_fill;
        zlib_filefunc64_32_def_fill.zfile_func64 = *pzlib_filefunc_def;
        zlib_filefunc64_32_def_fill.ztell32_file = NULL;
        zlib_filefunc64_32_def_fill.zseek32_file = NULL;
        <B><FONT COLOR="#A020F0">return</FONT></B> zipOpen3(pathname, append, globalcomment, &amp;zlib_filefunc64_32_def_fill);
    }
    <B><FONT COLOR="#A020F0">else</FONT></B>
        <B><FONT COLOR="#A020F0">return</FONT></B> zipOpen3(pathname, append, globalcomment, NULL);
}



<B><FONT COLOR="#228B22">extern</FONT></B> zipFile ZEXPORT <B><FONT COLOR="#0000FF">zipOpen</FONT></B> (<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>* pathname, <B><FONT COLOR="#228B22">int</FONT></B> append)
{
    <B><FONT COLOR="#A020F0">return</FONT></B> zipOpen3((<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B>*)pathname,append,NULL,NULL);
}

<B><FONT COLOR="#228B22">extern</FONT></B> zipFile ZEXPORT <B><FONT COLOR="#0000FF">zipOpen64</FONT></B> (<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B>* pathname, <B><FONT COLOR="#228B22">int</FONT></B> append)
{
    <B><FONT COLOR="#A020F0">return</FONT></B> zipOpen3(pathname,append,NULL,NULL);
}

local <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">Write_LocalFileHeader</FONT></B>(zip64_internal* zi, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>* filename, uInt size_extrafield_local, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B>* extrafield_local)
{
  <I><FONT COLOR="#B22222">/* write the local header */</FONT></I>
  <B><FONT COLOR="#228B22">int</FONT></B> err;
  uInt size_filename = (uInt)strlen(filename);
  uInt size_extrafield = size_extrafield_local;

  err = zip64local_putValue(&amp;zi-&gt;z_filefunc,zi-&gt;filestream,(uLong)LOCALHEADERMAGIC, 4);

  <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK)
  {
    <B><FONT COLOR="#A020F0">if</FONT></B>(zi-&gt;ci.zip64)
      err = zip64local_putValue(&amp;zi-&gt;z_filefunc,zi-&gt;filestream,(uLong)45,2);<I><FONT COLOR="#B22222">/* version needed to extract */</FONT></I>
    <B><FONT COLOR="#A020F0">else</FONT></B>
      err = zip64local_putValue(&amp;zi-&gt;z_filefunc,zi-&gt;filestream,(uLong)20,2);<I><FONT COLOR="#B22222">/* version needed to extract */</FONT></I>
  }

  <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK)
    err = zip64local_putValue(&amp;zi-&gt;z_filefunc,zi-&gt;filestream,(uLong)zi-&gt;ci.flag,2);

  <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK)
    err = zip64local_putValue(&amp;zi-&gt;z_filefunc,zi-&gt;filestream,(uLong)zi-&gt;ci.method,2);

  <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK)
    err = zip64local_putValue(&amp;zi-&gt;z_filefunc,zi-&gt;filestream,(uLong)zi-&gt;ci.dosDate,4);

  <I><FONT COLOR="#B22222">// CRC / Compressed size / Uncompressed size will be filled in later and rewritten later
</FONT></I>  <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK)
    err = zip64local_putValue(&amp;zi-&gt;z_filefunc,zi-&gt;filestream,(uLong)0,4); <I><FONT COLOR="#B22222">/* crc 32, unknown */</FONT></I>
  <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK)
  {
    <B><FONT COLOR="#A020F0">if</FONT></B>(zi-&gt;ci.zip64)
      err = zip64local_putValue(&amp;zi-&gt;z_filefunc,zi-&gt;filestream,(uLong)0xFFFFFFFF,4); <I><FONT COLOR="#B22222">/* compressed size, unknown */</FONT></I>
    <B><FONT COLOR="#A020F0">else</FONT></B>
      err = zip64local_putValue(&amp;zi-&gt;z_filefunc,zi-&gt;filestream,(uLong)0,4); <I><FONT COLOR="#B22222">/* compressed size, unknown */</FONT></I>
  }
  <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK)
  {
    <B><FONT COLOR="#A020F0">if</FONT></B>(zi-&gt;ci.zip64)
      err = zip64local_putValue(&amp;zi-&gt;z_filefunc,zi-&gt;filestream,(uLong)0xFFFFFFFF,4); <I><FONT COLOR="#B22222">/* uncompressed size, unknown */</FONT></I>
    <B><FONT COLOR="#A020F0">else</FONT></B>
      err = zip64local_putValue(&amp;zi-&gt;z_filefunc,zi-&gt;filestream,(uLong)0,4); <I><FONT COLOR="#B22222">/* uncompressed size, unknown */</FONT></I>
  }

  <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK)
    err = zip64local_putValue(&amp;zi-&gt;z_filefunc,zi-&gt;filestream,(uLong)size_filename,2);

  <B><FONT COLOR="#A020F0">if</FONT></B>(zi-&gt;ci.zip64)
  {
    size_extrafield += 20;
  }

  <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK)
    err = zip64local_putValue(&amp;zi-&gt;z_filefunc,zi-&gt;filestream,(uLong)size_extrafield,2);

  <B><FONT COLOR="#A020F0">if</FONT></B> ((err==ZIP_OK) &amp;&amp; (size_filename &gt; 0))
  {
    <B><FONT COLOR="#A020F0">if</FONT></B> (ZWRITE64(zi-&gt;z_filefunc,zi-&gt;filestream,filename,size_filename)!=size_filename)
      err = ZIP_ERRNO;
  }

  <B><FONT COLOR="#A020F0">if</FONT></B> ((err==ZIP_OK) &amp;&amp; (size_extrafield_local &gt; 0))
  {
    <B><FONT COLOR="#A020F0">if</FONT></B> (ZWRITE64(zi-&gt;z_filefunc, zi-&gt;filestream, extrafield_local, size_extrafield_local) != size_extrafield_local)
      err = ZIP_ERRNO;
  }


  <B><FONT COLOR="#A020F0">if</FONT></B> ((err==ZIP_OK) &amp;&amp; (zi-&gt;ci.zip64))
  {
      <I><FONT COLOR="#B22222">// write the Zip64 extended info
</FONT></I>      <B><FONT COLOR="#228B22">short</FONT></B> HeaderID = 1;
      <B><FONT COLOR="#228B22">short</FONT></B> DataSize = 16;
      ZPOS64_T CompressedSize = 0;
      ZPOS64_T UncompressedSize = 0;

      <I><FONT COLOR="#B22222">// Remember position of Zip64 extended info for the local file header. (needed when we update size after done with file)
</FONT></I>      zi-&gt;ci.pos_zip64extrainfo = ZTELL64(zi-&gt;z_filefunc,zi-&gt;filestream);

      err = zip64local_putValue(&amp;zi-&gt;z_filefunc, zi-&gt;filestream, (<B><FONT COLOR="#228B22">short</FONT></B>)HeaderID,2);
      err = zip64local_putValue(&amp;zi-&gt;z_filefunc, zi-&gt;filestream, (<B><FONT COLOR="#228B22">short</FONT></B>)DataSize,2);

      err = zip64local_putValue(&amp;zi-&gt;z_filefunc, zi-&gt;filestream, (ZPOS64_T)UncompressedSize,8);
      err = zip64local_putValue(&amp;zi-&gt;z_filefunc, zi-&gt;filestream, (ZPOS64_T)CompressedSize,8);
  }

  <B><FONT COLOR="#A020F0">return</FONT></B> err;
}

<I><FONT COLOR="#B22222">/*
 NOTE.
 When writing RAW the ZIP64 extended information in extrafield_local and extrafield_global needs to be stripped
 before calling this function it can be done with zipRemoveExtraInfoBlock

 It is not done here because then we need to realloc a new buffer since parameters are 'const' and I want to minimize
 unnecessary allocations.
 */</FONT></I>
<B><FONT COLOR="#228B22">extern</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> ZEXPORT <B><FONT COLOR="#0000FF">zipOpenNewFileInZip4_64</FONT></B> (zipFile file, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>* filename, <B><FONT COLOR="#228B22">const</FONT></B> zip_fileinfo* zipfi,
                                         <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B>* extrafield_local, uInt size_extrafield_local,
                                         <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B>* extrafield_global, uInt size_extrafield_global,
                                         <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>* comment, <B><FONT COLOR="#228B22">int</FONT></B> method, <B><FONT COLOR="#228B22">int</FONT></B> level, <B><FONT COLOR="#228B22">int</FONT></B> raw,
                                         <B><FONT COLOR="#228B22">int</FONT></B> windowBits,<B><FONT COLOR="#228B22">int</FONT></B> memLevel, <B><FONT COLOR="#228B22">int</FONT></B> strategy,
                                         <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>* password, uLong crcForCrypting,
                                         uLong versionMadeBy, uLong flagBase, <B><FONT COLOR="#228B22">int</FONT></B> zip64)
{
    zip64_internal* zi;
    uInt size_filename;
    uInt size_comment;
    uInt i;
    <B><FONT COLOR="#228B22">int</FONT></B> err = ZIP_OK;

#    <B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">NOCRYPT</FONT>
    (crcForCrypting);
    <B><FONT COLOR="#A020F0">if</FONT></B> (password != NULL)
        <B><FONT COLOR="#A020F0">return</FONT></B> ZIP_PARAMERROR;
#    <B><FONT COLOR="#5F9EA0">endif</FONT></B>

    <B><FONT COLOR="#A020F0">if</FONT></B> (file == NULL)
        <B><FONT COLOR="#A020F0">return</FONT></B> ZIP_PARAMERROR;

#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">HAVE_BZIP2</FONT>
    <B><FONT COLOR="#A020F0">if</FONT></B> ((method!=0) &amp;&amp; (method!=Z_DEFLATED) &amp;&amp; (method!=Z_BZIP2ED))
      <B><FONT COLOR="#A020F0">return</FONT></B> ZIP_PARAMERROR;
#<B><FONT COLOR="#5F9EA0">else</FONT></B>
    <B><FONT COLOR="#A020F0">if</FONT></B> ((method!=0) &amp;&amp; (method!=Z_DEFLATED))
      <B><FONT COLOR="#A020F0">return</FONT></B> ZIP_PARAMERROR;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

    zi = (zip64_internal*)file;

    <B><FONT COLOR="#A020F0">if</FONT></B> (zi-&gt;in_opened_file_inzip == 1)
    {
        err = zipCloseFileInZip (file);
        <B><FONT COLOR="#A020F0">if</FONT></B> (err != ZIP_OK)
            <B><FONT COLOR="#A020F0">return</FONT></B> err;
    }

    <B><FONT COLOR="#A020F0">if</FONT></B> (filename==NULL)
        filename=<B><FONT COLOR="#BC8F8F">&quot;-&quot;</FONT></B>;

    <B><FONT COLOR="#A020F0">if</FONT></B> (comment==NULL)
        size_comment = 0;
    <B><FONT COLOR="#A020F0">else</FONT></B>
        size_comment = (uInt)strlen(comment);

    size_filename = (uInt)strlen(filename);

    <B><FONT COLOR="#A020F0">if</FONT></B> (zipfi == NULL)
        zi-&gt;ci.dosDate = 0;
    <B><FONT COLOR="#A020F0">else</FONT></B>
    {
        <B><FONT COLOR="#A020F0">if</FONT></B> (zipfi-&gt;dosDate != 0)
            zi-&gt;ci.dosDate = zipfi-&gt;dosDate;
        <B><FONT COLOR="#A020F0">else</FONT></B>
          zi-&gt;ci.dosDate = zip64local_TmzDateToDosDate(&amp;zipfi-&gt;tmz_date);
    }

    zi-&gt;ci.flag = flagBase;
    <B><FONT COLOR="#A020F0">if</FONT></B> ((level==8) || (level==9))
      zi-&gt;ci.flag |= 2;
    <B><FONT COLOR="#A020F0">if</FONT></B> (level==2)
      zi-&gt;ci.flag |= 4;
    <B><FONT COLOR="#A020F0">if</FONT></B> (level==1)
      zi-&gt;ci.flag |= 6;
    <B><FONT COLOR="#A020F0">if</FONT></B> (password != NULL)
      zi-&gt;ci.flag |= 1;

    zi-&gt;ci.crc32 = 0;
    zi-&gt;ci.method = method;
    zi-&gt;ci.encrypt = 0;
    zi-&gt;ci.stream_initialised = 0;
    zi-&gt;ci.pos_in_buffered_data = 0;
    zi-&gt;ci.raw = raw;
    zi-&gt;ci.pos_local_header = ZTELL64(zi-&gt;z_filefunc,zi-&gt;filestream);

    zi-&gt;ci.size_centralheader = SIZECENTRALHEADER + size_filename + size_extrafield_global + size_comment;
    zi-&gt;ci.size_centralExtraFree = 32; <I><FONT COLOR="#B22222">// Extra space we have reserved in case we need to add ZIP64 extra info data
</FONT></I>
    zi-&gt;ci.central_header = (<B><FONT COLOR="#228B22">char</FONT></B>*)ALLOC((uInt)zi-&gt;ci.size_centralheader + zi-&gt;ci.size_centralExtraFree);

    zi-&gt;ci.size_centralExtra = size_extrafield_global;
    zip64local_putValue_inmemory(zi-&gt;ci.central_header,(uLong)CENTRALHEADERMAGIC,4);
    <I><FONT COLOR="#B22222">/* version info */</FONT></I>
    zip64local_putValue_inmemory(zi-&gt;ci.central_header+4,(uLong)versionMadeBy,2);
    zip64local_putValue_inmemory(zi-&gt;ci.central_header+6,(uLong)20,2);
    zip64local_putValue_inmemory(zi-&gt;ci.central_header+8,(uLong)zi-&gt;ci.flag,2);
    zip64local_putValue_inmemory(zi-&gt;ci.central_header+10,(uLong)zi-&gt;ci.method,2);
    zip64local_putValue_inmemory(zi-&gt;ci.central_header+12,(uLong)zi-&gt;ci.dosDate,4);
    zip64local_putValue_inmemory(zi-&gt;ci.central_header+16,(uLong)0,4); <I><FONT COLOR="#B22222">/*crc*/</FONT></I>
    zip64local_putValue_inmemory(zi-&gt;ci.central_header+20,(uLong)0,4); <I><FONT COLOR="#B22222">/*compr size*/</FONT></I>
    zip64local_putValue_inmemory(zi-&gt;ci.central_header+24,(uLong)0,4); <I><FONT COLOR="#B22222">/*uncompr size*/</FONT></I>
    zip64local_putValue_inmemory(zi-&gt;ci.central_header+28,(uLong)size_filename,2);
    zip64local_putValue_inmemory(zi-&gt;ci.central_header+30,(uLong)size_extrafield_global,2);
    zip64local_putValue_inmemory(zi-&gt;ci.central_header+32,(uLong)size_comment,2);
    zip64local_putValue_inmemory(zi-&gt;ci.central_header+34,(uLong)0,2); <I><FONT COLOR="#B22222">/*disk nm start*/</FONT></I>

    <B><FONT COLOR="#A020F0">if</FONT></B> (zipfi==NULL)
        zip64local_putValue_inmemory(zi-&gt;ci.central_header+36,(uLong)0,2);
    <B><FONT COLOR="#A020F0">else</FONT></B>
        zip64local_putValue_inmemory(zi-&gt;ci.central_header+36,(uLong)zipfi-&gt;internal_fa,2);

    <B><FONT COLOR="#A020F0">if</FONT></B> (zipfi==NULL)
        zip64local_putValue_inmemory(zi-&gt;ci.central_header+38,(uLong)0,4);
    <B><FONT COLOR="#A020F0">else</FONT></B>
        zip64local_putValue_inmemory(zi-&gt;ci.central_header+38,(uLong)zipfi-&gt;external_fa,4);

    <B><FONT COLOR="#A020F0">if</FONT></B>(zi-&gt;ci.pos_local_header &gt;= 0xffffffff)
      zip64local_putValue_inmemory(zi-&gt;ci.central_header+42,(uLong)0xffffffff,4);
    <B><FONT COLOR="#A020F0">else</FONT></B>
      zip64local_putValue_inmemory(zi-&gt;ci.central_header+42,(uLong)zi-&gt;ci.pos_local_header - zi-&gt;add_position_when_writting_offset,4);

    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0;i&lt;size_filename;i++)
        *(zi-&gt;ci.central_header+SIZECENTRALHEADER+i) = *(filename+i);

    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0;i&lt;size_extrafield_global;i++)
        *(zi-&gt;ci.central_header+SIZECENTRALHEADER+size_filename+i) =
              *(((<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>*)extrafield_global)+i);

    <B><FONT COLOR="#A020F0">for</FONT></B> (i=0;i&lt;size_comment;i++)
        *(zi-&gt;ci.central_header+SIZECENTRALHEADER+size_filename+
              size_extrafield_global+i) = *(comment+i);
    <B><FONT COLOR="#A020F0">if</FONT></B> (zi-&gt;ci.central_header == NULL)
        <B><FONT COLOR="#A020F0">return</FONT></B> ZIP_INTERNALERROR;

    zi-&gt;ci.zip64 = zip64;
    zi-&gt;ci.totalCompressedData = 0;
    zi-&gt;ci.totalUncompressedData = 0;
    zi-&gt;ci.pos_zip64extrainfo = 0;

    err = Write_LocalFileHeader(zi, filename, size_extrafield_local, extrafield_local);

#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">HAVE_BZIP2</FONT>
    zi-&gt;ci.bstream.avail_in = (uInt)0;
    zi-&gt;ci.bstream.avail_out = (uInt)Z_BUFSIZE;
    zi-&gt;ci.bstream.next_out = (<B><FONT COLOR="#228B22">char</FONT></B>*)zi-&gt;ci.buffered_data;
    zi-&gt;ci.bstream.total_in_hi32 = 0;
    zi-&gt;ci.bstream.total_in_lo32 = 0;
    zi-&gt;ci.bstream.total_out_hi32 = 0;
    zi-&gt;ci.bstream.total_out_lo32 = 0;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

    zi-&gt;ci.stream.avail_in = (uInt)0;
    zi-&gt;ci.stream.avail_out = (uInt)Z_BUFSIZE;
    zi-&gt;ci.stream.next_out = zi-&gt;ci.buffered_data;
    zi-&gt;ci.stream.total_in = 0;
    zi-&gt;ci.stream.total_out = 0;
    zi-&gt;ci.stream.data_type = Z_BINARY;

#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">HAVE_BZIP2</FONT>
    <B><FONT COLOR="#A020F0">if</FONT></B> ((err==ZIP_OK) &amp;&amp; (zi-&gt;ci.method == Z_DEFLATED || zi-&gt;ci.method == Z_BZIP2ED) &amp;&amp; (!zi-&gt;ci.raw))
#<B><FONT COLOR="#5F9EA0">else</FONT></B>
    <B><FONT COLOR="#A020F0">if</FONT></B> ((err==ZIP_OK) &amp;&amp; (zi-&gt;ci.method == Z_DEFLATED) &amp;&amp; (!zi-&gt;ci.raw))
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    {
        <B><FONT COLOR="#A020F0">if</FONT></B>(zi-&gt;ci.method == Z_DEFLATED)
        {
          zi-&gt;ci.stream.zalloc = (alloc_func)0;
          zi-&gt;ci.stream.zfree = (free_func)0;
          zi-&gt;ci.stream.opaque = (voidpf)0;

          <B><FONT COLOR="#A020F0">if</FONT></B> (windowBits&gt;0)
              windowBits = -windowBits;

          err = deflateInit2(&amp;zi-&gt;ci.stream, level, Z_DEFLATED, windowBits, memLevel, strategy);

          <B><FONT COLOR="#A020F0">if</FONT></B> (err==Z_OK)
              zi-&gt;ci.stream_initialised = Z_DEFLATED;
        }
        <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>(zi-&gt;ci.method == Z_BZIP2ED)
        {
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">HAVE_BZIP2</FONT>
            <I><FONT COLOR="#B22222">// Init BZip stuff here
</FONT></I>          zi-&gt;ci.bstream.bzalloc = 0;
          zi-&gt;ci.bstream.bzfree = 0;
          zi-&gt;ci.bstream.opaque = (voidpf)0;

          err = BZ2_bzCompressInit(&amp;zi-&gt;ci.bstream, level, 0,35);
          <B><FONT COLOR="#A020F0">if</FONT></B>(err == BZ_OK)
            zi-&gt;ci.stream_initialised = Z_BZIP2ED;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
        }

    }

#    <B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">NOCRYPT</FONT>
    zi-&gt;ci.crypt_header_size = 0;
    <B><FONT COLOR="#A020F0">if</FONT></B> ((err==Z_OK) &amp;&amp; (password != NULL))
    {
        <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> bufHead[RAND_HEAD_LEN];
        <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> sizeHead;
        zi-&gt;ci.encrypt = 1;
        zi-&gt;ci.pcrc_32_tab = get_crc_table();
        <I><FONT COLOR="#B22222">/*init_keys(password,zi-&gt;ci.keys,zi-&gt;ci.pcrc_32_tab);*/</FONT></I>

        sizeHead=crypthead(password,bufHead,RAND_HEAD_LEN,zi-&gt;ci.keys,zi-&gt;ci.pcrc_32_tab,crcForCrypting);
        zi-&gt;ci.crypt_header_size = sizeHead;

        <B><FONT COLOR="#A020F0">if</FONT></B> (ZWRITE64(zi-&gt;z_filefunc,zi-&gt;filestream,bufHead,sizeHead) != sizeHead)
                err = ZIP_ERRNO;
    }
#    <B><FONT COLOR="#5F9EA0">endif</FONT></B>

    <B><FONT COLOR="#A020F0">if</FONT></B> (err==Z_OK)
        zi-&gt;in_opened_file_inzip = 1;
    <B><FONT COLOR="#A020F0">return</FONT></B> err;
}

<B><FONT COLOR="#228B22">extern</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> ZEXPORT <B><FONT COLOR="#0000FF">zipOpenNewFileInZip4</FONT></B> (zipFile file, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>* filename, <B><FONT COLOR="#228B22">const</FONT></B> zip_fileinfo* zipfi,
                                         <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B>* extrafield_local, uInt size_extrafield_local,
                                         <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B>* extrafield_global, uInt size_extrafield_global,
                                         <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>* comment, <B><FONT COLOR="#228B22">int</FONT></B> method, <B><FONT COLOR="#228B22">int</FONT></B> level, <B><FONT COLOR="#228B22">int</FONT></B> raw,
                                         <B><FONT COLOR="#228B22">int</FONT></B> windowBits,<B><FONT COLOR="#228B22">int</FONT></B> memLevel, <B><FONT COLOR="#228B22">int</FONT></B> strategy,
                                         <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>* password, uLong crcForCrypting,
                                         uLong versionMadeBy, uLong flagBase)
{
    <B><FONT COLOR="#A020F0">return</FONT></B> zipOpenNewFileInZip4_64 (file, filename, zipfi,
                                 extrafield_local, size_extrafield_local,
                                 extrafield_global, size_extrafield_global,
                                 comment, method, level, raw,
                                 windowBits, memLevel, strategy,
                                 password, crcForCrypting, versionMadeBy, flagBase, 0);
}

<B><FONT COLOR="#228B22">extern</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> ZEXPORT <B><FONT COLOR="#0000FF">zipOpenNewFileInZip3</FONT></B> (zipFile file, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>* filename, <B><FONT COLOR="#228B22">const</FONT></B> zip_fileinfo* zipfi,
                                         <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B>* extrafield_local, uInt size_extrafield_local,
                                         <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B>* extrafield_global, uInt size_extrafield_global,
                                         <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>* comment, <B><FONT COLOR="#228B22">int</FONT></B> method, <B><FONT COLOR="#228B22">int</FONT></B> level, <B><FONT COLOR="#228B22">int</FONT></B> raw,
                                         <B><FONT COLOR="#228B22">int</FONT></B> windowBits,<B><FONT COLOR="#228B22">int</FONT></B> memLevel, <B><FONT COLOR="#228B22">int</FONT></B> strategy,
                                         <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>* password, uLong crcForCrypting)
{
    <B><FONT COLOR="#A020F0">return</FONT></B> zipOpenNewFileInZip4_64 (file, filename, zipfi,
                                 extrafield_local, size_extrafield_local,
                                 extrafield_global, size_extrafield_global,
                                 comment, method, level, raw,
                                 windowBits, memLevel, strategy,
                                 password, crcForCrypting, VERSIONMADEBY, 0, 0);
}

<B><FONT COLOR="#228B22">extern</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> ZEXPORT <B><FONT COLOR="#0000FF">zipOpenNewFileInZip3_64</FONT></B>(zipFile file, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>* filename, <B><FONT COLOR="#228B22">const</FONT></B> zip_fileinfo* zipfi,
                                         <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B>* extrafield_local, uInt size_extrafield_local,
                                         <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B>* extrafield_global, uInt size_extrafield_global,
                                         <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>* comment, <B><FONT COLOR="#228B22">int</FONT></B> method, <B><FONT COLOR="#228B22">int</FONT></B> level, <B><FONT COLOR="#228B22">int</FONT></B> raw,
                                         <B><FONT COLOR="#228B22">int</FONT></B> windowBits,<B><FONT COLOR="#228B22">int</FONT></B> memLevel, <B><FONT COLOR="#228B22">int</FONT></B> strategy,
                                         <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>* password, uLong crcForCrypting, <B><FONT COLOR="#228B22">int</FONT></B> zip64)
{
    <B><FONT COLOR="#A020F0">return</FONT></B> zipOpenNewFileInZip4_64 (file, filename, zipfi,
                                 extrafield_local, size_extrafield_local,
                                 extrafield_global, size_extrafield_global,
                                 comment, method, level, raw,
                                 windowBits, memLevel, strategy,
                                 password, crcForCrypting, VERSIONMADEBY, 0, zip64);
}

<B><FONT COLOR="#228B22">extern</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> ZEXPORT <B><FONT COLOR="#0000FF">zipOpenNewFileInZip2</FONT></B>(zipFile file, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>* filename, <B><FONT COLOR="#228B22">const</FONT></B> zip_fileinfo* zipfi,
                                        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B>* extrafield_local, uInt size_extrafield_local,
                                        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B>* extrafield_global, uInt size_extrafield_global,
                                        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>* comment, <B><FONT COLOR="#228B22">int</FONT></B> method, <B><FONT COLOR="#228B22">int</FONT></B> level, <B><FONT COLOR="#228B22">int</FONT></B> raw)
{
    <B><FONT COLOR="#A020F0">return</FONT></B> zipOpenNewFileInZip4_64 (file, filename, zipfi,
                                 extrafield_local, size_extrafield_local,
                                 extrafield_global, size_extrafield_global,
                                 comment, method, level, raw,
                                 -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,
                                 NULL, 0, VERSIONMADEBY, 0, 0);
}

<B><FONT COLOR="#228B22">extern</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> ZEXPORT <B><FONT COLOR="#0000FF">zipOpenNewFileInZip2_64</FONT></B>(zipFile file, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>* filename, <B><FONT COLOR="#228B22">const</FONT></B> zip_fileinfo* zipfi,
                                        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B>* extrafield_local, uInt size_extrafield_local,
                                        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B>* extrafield_global, uInt size_extrafield_global,
                                        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>* comment, <B><FONT COLOR="#228B22">int</FONT></B> method, <B><FONT COLOR="#228B22">int</FONT></B> level, <B><FONT COLOR="#228B22">int</FONT></B> raw, <B><FONT COLOR="#228B22">int</FONT></B> zip64)
{
    <B><FONT COLOR="#A020F0">return</FONT></B> zipOpenNewFileInZip4_64 (file, filename, zipfi,
                                 extrafield_local, size_extrafield_local,
                                 extrafield_global, size_extrafield_global,
                                 comment, method, level, raw,
                                 -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,
                                 NULL, 0, VERSIONMADEBY, 0, zip64);
}

<B><FONT COLOR="#228B22">extern</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> ZEXPORT <B><FONT COLOR="#0000FF">zipOpenNewFileInZip64</FONT></B> (zipFile file, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>* filename, <B><FONT COLOR="#228B22">const</FONT></B> zip_fileinfo* zipfi,
                                        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B>* extrafield_local, uInt size_extrafield_local,
                                        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B>*extrafield_global, uInt size_extrafield_global,
                                        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>* comment, <B><FONT COLOR="#228B22">int</FONT></B> method, <B><FONT COLOR="#228B22">int</FONT></B> level, <B><FONT COLOR="#228B22">int</FONT></B> zip64)
{
    <B><FONT COLOR="#A020F0">return</FONT></B> zipOpenNewFileInZip4_64 (file, filename, zipfi,
                                 extrafield_local, size_extrafield_local,
                                 extrafield_global, size_extrafield_global,
                                 comment, method, level, 0,
                                 -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,
                                 NULL, 0, VERSIONMADEBY, 0, zip64);
}

<B><FONT COLOR="#228B22">extern</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> ZEXPORT <B><FONT COLOR="#0000FF">zipOpenNewFileInZip</FONT></B> (zipFile file, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>* filename, <B><FONT COLOR="#228B22">const</FONT></B> zip_fileinfo* zipfi,
                                        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B>* extrafield_local, uInt size_extrafield_local,
                                        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B>*extrafield_global, uInt size_extrafield_global,
                                        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>* comment, <B><FONT COLOR="#228B22">int</FONT></B> method, <B><FONT COLOR="#228B22">int</FONT></B> level)
{
    <B><FONT COLOR="#A020F0">return</FONT></B> zipOpenNewFileInZip4_64 (file, filename, zipfi,
                                 extrafield_local, size_extrafield_local,
                                 extrafield_global, size_extrafield_global,
                                 comment, method, level, 0,
                                 -MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY,
                                 NULL, 0, VERSIONMADEBY, 0, 0);
}

local <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">zip64FlushWriteBuffer</FONT></B>(zip64_internal* zi)
{
    <B><FONT COLOR="#228B22">int</FONT></B> err=ZIP_OK;

    <B><FONT COLOR="#A020F0">if</FONT></B> (zi-&gt;ci.encrypt != 0)
    {
#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">NOCRYPT</FONT>
        uInt i;
        <B><FONT COLOR="#228B22">int</FONT></B> t;
        <B><FONT COLOR="#A020F0">for</FONT></B> (i=0;i&lt;zi-&gt;ci.pos_in_buffered_data;i++)
            zi-&gt;ci.buffered_data[i] = zencode(zi-&gt;ci.keys, zi-&gt;ci.pcrc_32_tab, zi-&gt;ci.buffered_data[i],t);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    }

    <B><FONT COLOR="#A020F0">if</FONT></B> (ZWRITE64(zi-&gt;z_filefunc,zi-&gt;filestream,zi-&gt;ci.buffered_data,zi-&gt;ci.pos_in_buffered_data) != zi-&gt;ci.pos_in_buffered_data)
      err = ZIP_ERRNO;

    zi-&gt;ci.totalCompressedData += zi-&gt;ci.pos_in_buffered_data;

#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">HAVE_BZIP2</FONT>
    <B><FONT COLOR="#A020F0">if</FONT></B>(zi-&gt;ci.method == Z_BZIP2ED)
    {
      zi-&gt;ci.totalUncompressedData += zi-&gt;ci.bstream.total_in_lo32;
      zi-&gt;ci.bstream.total_in_lo32 = 0;
      zi-&gt;ci.bstream.total_in_hi32 = 0;
    }
    <B><FONT COLOR="#A020F0">else</FONT></B>
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    {
      zi-&gt;ci.totalUncompressedData += zi-&gt;ci.stream.total_in;
      zi-&gt;ci.stream.total_in = 0;
    }


    zi-&gt;ci.pos_in_buffered_data = 0;

    <B><FONT COLOR="#A020F0">return</FONT></B> err;
}

<B><FONT COLOR="#228B22">extern</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> ZEXPORT <B><FONT COLOR="#0000FF">zipWriteInFileInZip</FONT></B> (zipFile file,<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B>* buf,<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> len)
{
    zip64_internal* zi;
    <B><FONT COLOR="#228B22">int</FONT></B> err=ZIP_OK;

    <B><FONT COLOR="#A020F0">if</FONT></B> (file == NULL)
        <B><FONT COLOR="#A020F0">return</FONT></B> ZIP_PARAMERROR;
    zi = (zip64_internal*)file;

    <B><FONT COLOR="#A020F0">if</FONT></B> (zi-&gt;in_opened_file_inzip == 0)
        <B><FONT COLOR="#A020F0">return</FONT></B> ZIP_PARAMERROR;

    zi-&gt;ci.crc32 = crc32(zi-&gt;ci.crc32,buf,(uInt)len);

#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">HAVE_BZIP2</FONT>
    <B><FONT COLOR="#A020F0">if</FONT></B>(zi-&gt;ci.method == Z_BZIP2ED &amp;&amp; (!zi-&gt;ci.raw))
    {
      zi-&gt;ci.bstream.next_in = buf;
      zi-&gt;ci.bstream.avail_in = len;
      err = BZ_RUN_OK;

      <B><FONT COLOR="#A020F0">while</FONT></B> ((err==BZ_RUN_OK) &amp;&amp; (zi-&gt;ci.bstream.avail_in&gt;0))
      {
        <B><FONT COLOR="#A020F0">if</FONT></B> (zi-&gt;ci.bstream.avail_out == 0)
        {
          <B><FONT COLOR="#A020F0">if</FONT></B> (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)
            err = ZIP_ERRNO;
          zi-&gt;ci.bstream.avail_out = (uInt)Z_BUFSIZE;
          zi-&gt;ci.bstream.next_out = (<B><FONT COLOR="#228B22">char</FONT></B>*)zi-&gt;ci.buffered_data;
        }


        <B><FONT COLOR="#A020F0">if</FONT></B>(err != BZ_RUN_OK)
          <B><FONT COLOR="#A020F0">break</FONT></B>;

        <B><FONT COLOR="#A020F0">if</FONT></B> ((zi-&gt;ci.method == Z_BZIP2ED) &amp;&amp; (!zi-&gt;ci.raw))
        {
          uLong uTotalOutBefore_lo = zi-&gt;ci.bstream.total_out_lo32;
<I><FONT COLOR="#B22222">//          uLong uTotalOutBefore_hi = zi-&gt;ci.bstream.total_out_hi32;
</FONT></I>          err=BZ2_bzCompress(&amp;zi-&gt;ci.bstream,  BZ_RUN);

          zi-&gt;ci.pos_in_buffered_data += (uInt)(zi-&gt;ci.bstream.total_out_lo32 - uTotalOutBefore_lo) ;
        }
      }

      <B><FONT COLOR="#A020F0">if</FONT></B>(err == BZ_RUN_OK)
        err = ZIP_OK;
    }
    <B><FONT COLOR="#A020F0">else</FONT></B>
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    {
      zi-&gt;ci.stream.next_in = buf;
      zi-&gt;ci.stream.avail_in = len;

      <B><FONT COLOR="#A020F0">while</FONT></B> ((err==ZIP_OK) &amp;&amp; (zi-&gt;ci.stream.avail_in&gt;0))
      {
          <B><FONT COLOR="#A020F0">if</FONT></B> (zi-&gt;ci.stream.avail_out == 0)
          {
              <B><FONT COLOR="#A020F0">if</FONT></B> (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)
                  err = ZIP_ERRNO;
              zi-&gt;ci.stream.avail_out = (uInt)Z_BUFSIZE;
              zi-&gt;ci.stream.next_out = zi-&gt;ci.buffered_data;
          }


          <B><FONT COLOR="#A020F0">if</FONT></B>(err != ZIP_OK)
              <B><FONT COLOR="#A020F0">break</FONT></B>;

          <B><FONT COLOR="#A020F0">if</FONT></B> ((zi-&gt;ci.method == Z_DEFLATED) &amp;&amp; (!zi-&gt;ci.raw))
          {
              uLong uTotalOutBefore = zi-&gt;ci.stream.total_out;
              err=deflate(&amp;zi-&gt;ci.stream,  Z_NO_FLUSH);
              <B><FONT COLOR="#A020F0">if</FONT></B>(uTotalOutBefore &gt; zi-&gt;ci.stream.total_out)
              {
                <B><FONT COLOR="#228B22">int</FONT></B> bBreak = 0;
                bBreak++;
              }

              zi-&gt;ci.pos_in_buffered_data += (uInt)(zi-&gt;ci.stream.total_out - uTotalOutBefore) ;
          }
          <B><FONT COLOR="#A020F0">else</FONT></B>
          {
              uInt copy_this,i;
              <B><FONT COLOR="#A020F0">if</FONT></B> (zi-&gt;ci.stream.avail_in &lt; zi-&gt;ci.stream.avail_out)
                  copy_this = zi-&gt;ci.stream.avail_in;
              <B><FONT COLOR="#A020F0">else</FONT></B>
                  copy_this = zi-&gt;ci.stream.avail_out;

              <B><FONT COLOR="#A020F0">for</FONT></B> (i = 0; i &lt; copy_this; i++)
                  *(((<B><FONT COLOR="#228B22">char</FONT></B>*)zi-&gt;ci.stream.next_out)+i) =
                      *(((<B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>*)zi-&gt;ci.stream.next_in)+i);
              {
                  zi-&gt;ci.stream.avail_in -= copy_this;
                  zi-&gt;ci.stream.avail_out-= copy_this;
                  zi-&gt;ci.stream.next_in+= copy_this;
                  zi-&gt;ci.stream.next_out+= copy_this;
                  zi-&gt;ci.stream.total_in+= copy_this;
                  zi-&gt;ci.stream.total_out+= copy_this;
                  zi-&gt;ci.pos_in_buffered_data += copy_this;
              }
          }
      }<I><FONT COLOR="#B22222">// while(...)
</FONT></I>    }

    <B><FONT COLOR="#A020F0">return</FONT></B> err;
}

<B><FONT COLOR="#228B22">extern</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> ZEXPORT <B><FONT COLOR="#0000FF">zipCloseFileInZipRaw</FONT></B> (zipFile file, uLong uncompressed_size, uLong crc32)
{
    <B><FONT COLOR="#A020F0">return</FONT></B> zipCloseFileInZipRaw64 (file, uncompressed_size, crc32);
}

<B><FONT COLOR="#228B22">extern</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> ZEXPORT <B><FONT COLOR="#0000FF">zipCloseFileInZipRaw64</FONT></B> (zipFile file, ZPOS64_T uncompressed_size, uLong crc32)
{
    zip64_internal* zi;
    ZPOS64_T compressed_size;
    uLong invalidValue = 0xffffffff;
    <B><FONT COLOR="#228B22">short</FONT></B> datasize = 0;
    <B><FONT COLOR="#228B22">int</FONT></B> err=ZIP_OK;

    <B><FONT COLOR="#A020F0">if</FONT></B> (file == NULL)
        <B><FONT COLOR="#A020F0">return</FONT></B> ZIP_PARAMERROR;
    zi = (zip64_internal*)file;

    <B><FONT COLOR="#A020F0">if</FONT></B> (zi-&gt;in_opened_file_inzip == 0)
        <B><FONT COLOR="#A020F0">return</FONT></B> ZIP_PARAMERROR;
    zi-&gt;ci.stream.avail_in = 0;

    <B><FONT COLOR="#A020F0">if</FONT></B> ((zi-&gt;ci.method == Z_DEFLATED) &amp;&amp; (!zi-&gt;ci.raw))
                {
                        <B><FONT COLOR="#A020F0">while</FONT></B> (err==ZIP_OK)
                        {
                                uLong uTotalOutBefore;
                                <B><FONT COLOR="#A020F0">if</FONT></B> (zi-&gt;ci.stream.avail_out == 0)
                                {
                                        <B><FONT COLOR="#A020F0">if</FONT></B> (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)
                                                err = ZIP_ERRNO;
                                        zi-&gt;ci.stream.avail_out = (uInt)Z_BUFSIZE;
                                        zi-&gt;ci.stream.next_out = zi-&gt;ci.buffered_data;
                                }
                                uTotalOutBefore = zi-&gt;ci.stream.total_out;
                                err=deflate(&amp;zi-&gt;ci.stream,  Z_FINISH);
                                zi-&gt;ci.pos_in_buffered_data += (uInt)(zi-&gt;ci.stream.total_out - uTotalOutBefore) ;
                        }
                }
    <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> ((zi-&gt;ci.method == Z_BZIP2ED) &amp;&amp; (!zi-&gt;ci.raw))
    {
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">HAVE_BZIP2</FONT>
      err = BZ_FINISH_OK;
      <B><FONT COLOR="#A020F0">while</FONT></B> (err==BZ_FINISH_OK)
      {
        uLong uTotalOutBefore;
        <B><FONT COLOR="#A020F0">if</FONT></B> (zi-&gt;ci.bstream.avail_out == 0)
        {
          <B><FONT COLOR="#A020F0">if</FONT></B> (zip64FlushWriteBuffer(zi) == ZIP_ERRNO)
            err = ZIP_ERRNO;
          zi-&gt;ci.bstream.avail_out = (uInt)Z_BUFSIZE;
          zi-&gt;ci.bstream.next_out = (<B><FONT COLOR="#228B22">char</FONT></B>*)zi-&gt;ci.buffered_data;
        }
        uTotalOutBefore = zi-&gt;ci.bstream.total_out_lo32;
        err=BZ2_bzCompress(&amp;zi-&gt;ci.bstream,  BZ_FINISH);
        <B><FONT COLOR="#A020F0">if</FONT></B>(err == BZ_STREAM_END)
          err = Z_STREAM_END;

        zi-&gt;ci.pos_in_buffered_data += (uInt)(zi-&gt;ci.bstream.total_out_lo32 - uTotalOutBefore);
      }

      <B><FONT COLOR="#A020F0">if</FONT></B>(err == BZ_FINISH_OK)
        err = ZIP_OK;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    }

    <B><FONT COLOR="#A020F0">if</FONT></B> (err==Z_STREAM_END)
        err=ZIP_OK; <I><FONT COLOR="#B22222">/* this is normal */</FONT></I>

    <B><FONT COLOR="#A020F0">if</FONT></B> ((zi-&gt;ci.pos_in_buffered_data&gt;0) &amp;&amp; (err==ZIP_OK))
                {
        <B><FONT COLOR="#A020F0">if</FONT></B> (zip64FlushWriteBuffer(zi)==ZIP_ERRNO)
            err = ZIP_ERRNO;
                }

    <B><FONT COLOR="#A020F0">if</FONT></B> ((zi-&gt;ci.method == Z_DEFLATED) &amp;&amp; (!zi-&gt;ci.raw))
    {
        <B><FONT COLOR="#228B22">int</FONT></B> tmp_err = deflateEnd(&amp;zi-&gt;ci.stream);
        <B><FONT COLOR="#A020F0">if</FONT></B> (err == ZIP_OK)
            err = tmp_err;
        zi-&gt;ci.stream_initialised = 0;
    }
#<B><FONT COLOR="#5F9EA0">ifdef</FONT></B> <FONT COLOR="#B8860B">HAVE_BZIP2</FONT>
    <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B>((zi-&gt;ci.method == Z_BZIP2ED) &amp;&amp; (!zi-&gt;ci.raw))
    {
      <B><FONT COLOR="#228B22">int</FONT></B> tmperr = BZ2_bzCompressEnd(&amp;zi-&gt;ci.bstream);
                        <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK)
                                err = tmperr;
                        zi-&gt;ci.stream_initialised = 0;
    }
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

    <B><FONT COLOR="#A020F0">if</FONT></B> (!zi-&gt;ci.raw)
    {
        crc32 = (uLong)zi-&gt;ci.crc32;
        uncompressed_size = zi-&gt;ci.totalUncompressedData;
    }
    compressed_size = zi-&gt;ci.totalCompressedData;

#    <B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">NOCRYPT</FONT>
    compressed_size += zi-&gt;ci.crypt_header_size;
#    <B><FONT COLOR="#5F9EA0">endif</FONT></B>

    <I><FONT COLOR="#B22222">// update Current Item crc and sizes,
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(compressed_size &gt;= 0xffffffff || uncompressed_size &gt;= 0xffffffff || zi-&gt;ci.pos_local_header &gt;= 0xffffffff)
    {
      <I><FONT COLOR="#B22222">/*version Made by*/</FONT></I>
      zip64local_putValue_inmemory(zi-&gt;ci.central_header+4,(uLong)45,2);
      <I><FONT COLOR="#B22222">/*version needed*/</FONT></I>
      zip64local_putValue_inmemory(zi-&gt;ci.central_header+6,(uLong)45,2);

    }

    zip64local_putValue_inmemory(zi-&gt;ci.central_header+16,crc32,4); <I><FONT COLOR="#B22222">/*crc*/</FONT></I>


    <B><FONT COLOR="#A020F0">if</FONT></B>(compressed_size &gt;= 0xffffffff)
      zip64local_putValue_inmemory(zi-&gt;ci.central_header+20, invalidValue,4); <I><FONT COLOR="#B22222">/*compr size*/</FONT></I>
    <B><FONT COLOR="#A020F0">else</FONT></B>
      zip64local_putValue_inmemory(zi-&gt;ci.central_header+20, compressed_size,4); <I><FONT COLOR="#B22222">/*compr size*/</FONT></I>

    <I><FONT COLOR="#B22222">/// set internal file attributes field
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B> (zi-&gt;ci.stream.data_type == Z_ASCII)
        zip64local_putValue_inmemory(zi-&gt;ci.central_header+36,(uLong)Z_ASCII,2);

    <B><FONT COLOR="#A020F0">if</FONT></B>(uncompressed_size &gt;= 0xffffffff)
      zip64local_putValue_inmemory(zi-&gt;ci.central_header+24, invalidValue,4); <I><FONT COLOR="#B22222">/*uncompr size*/</FONT></I>
    <B><FONT COLOR="#A020F0">else</FONT></B>
      zip64local_putValue_inmemory(zi-&gt;ci.central_header+24, uncompressed_size,4); <I><FONT COLOR="#B22222">/*uncompr size*/</FONT></I>

    <I><FONT COLOR="#B22222">// Add ZIP64 extra info field for uncompressed size
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(uncompressed_size &gt;= 0xffffffff)
      datasize += 8;

    <I><FONT COLOR="#B22222">// Add ZIP64 extra info field for compressed size
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(compressed_size &gt;= 0xffffffff)
      datasize += 8;

    <I><FONT COLOR="#B22222">// Add ZIP64 extra info field for relative offset to local file header of current file
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(zi-&gt;ci.pos_local_header &gt;= 0xffffffff)
      datasize += 8;

    <B><FONT COLOR="#A020F0">if</FONT></B>(datasize &gt; 0)
    {
      <B><FONT COLOR="#228B22">char</FONT></B>* p = NULL;

      <B><FONT COLOR="#A020F0">if</FONT></B>((uLong)(datasize + 4) &gt; zi-&gt;ci.size_centralExtraFree)
      {
        <I><FONT COLOR="#B22222">// we can not write more data to the buffer that we have room for.
</FONT></I>        <B><FONT COLOR="#A020F0">return</FONT></B> ZIP_BADZIPFILE;
      }

      p = zi-&gt;ci.central_header + zi-&gt;ci.size_centralheader;

      <I><FONT COLOR="#B22222">// Add Extra Information Header for 'ZIP64 information'
</FONT></I>      zip64local_putValue_inmemory(p, 0x0001, 2); <I><FONT COLOR="#B22222">// HeaderID
</FONT></I>      p += 2;
      zip64local_putValue_inmemory(p, datasize, 2); <I><FONT COLOR="#B22222">// DataSize
</FONT></I>      p += 2;

      <B><FONT COLOR="#A020F0">if</FONT></B>(uncompressed_size &gt;= 0xffffffff)
      {
        zip64local_putValue_inmemory(p, uncompressed_size, 8);
        p += 8;
      }

      <B><FONT COLOR="#A020F0">if</FONT></B>(compressed_size &gt;= 0xffffffff)
      {
        zip64local_putValue_inmemory(p, compressed_size, 8);
        p += 8;
      }

      <B><FONT COLOR="#A020F0">if</FONT></B>(zi-&gt;ci.pos_local_header &gt;= 0xffffffff)
      {
        zip64local_putValue_inmemory(p, zi-&gt;ci.pos_local_header, 8);
        p += 8;
      }

      <I><FONT COLOR="#B22222">// Update how much extra free space we got in the memory buffer
</FONT></I>      <I><FONT COLOR="#B22222">// and increase the centralheader size so the new ZIP64 fields are included
</FONT></I>      <I><FONT COLOR="#B22222">// ( 4 below is the size of HeaderID and DataSize field )
</FONT></I>      zi-&gt;ci.size_centralExtraFree -= datasize + 4;
      zi-&gt;ci.size_centralheader += datasize + 4;

      <I><FONT COLOR="#B22222">// Update the extra info size field
</FONT></I>      zi-&gt;ci.size_centralExtra += datasize + 4;
      zip64local_putValue_inmemory(zi-&gt;ci.central_header+30,(uLong)zi-&gt;ci.size_centralExtra,2);
    }

    <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK)
        err = add_data_in_datablock(&amp;zi-&gt;central_dir, zi-&gt;ci.central_header, (uLong)zi-&gt;ci.size_centralheader);

    free(zi-&gt;ci.central_header);

    <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK)
    {
        <I><FONT COLOR="#B22222">// Update the LocalFileHeader with the new values.
</FONT></I>
        ZPOS64_T cur_pos_inzip = ZTELL64(zi-&gt;z_filefunc,zi-&gt;filestream);

        <B><FONT COLOR="#A020F0">if</FONT></B> (ZSEEK64(zi-&gt;z_filefunc,zi-&gt;filestream, zi-&gt;ci.pos_local_header + 14,ZLIB_FILEFUNC_SEEK_SET)!=0)
            err = ZIP_ERRNO;

        <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK)
            err = zip64local_putValue(&amp;zi-&gt;z_filefunc,zi-&gt;filestream,crc32,4); <I><FONT COLOR="#B22222">/* crc 32, unknown */</FONT></I>

        <B><FONT COLOR="#A020F0">if</FONT></B>(uncompressed_size &gt;= 0xffffffff || compressed_size &gt;= 0xffffffff )
        {
          <B><FONT COLOR="#A020F0">if</FONT></B>(zi-&gt;ci.pos_zip64extrainfo &gt; 0)
          {
            <I><FONT COLOR="#B22222">// Update the size in the ZIP64 extended field.
</FONT></I>            <B><FONT COLOR="#A020F0">if</FONT></B> (ZSEEK64(zi-&gt;z_filefunc,zi-&gt;filestream, zi-&gt;ci.pos_zip64extrainfo + 4,ZLIB_FILEFUNC_SEEK_SET)!=0)
              err = ZIP_ERRNO;

            <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK) <I><FONT COLOR="#B22222">/* compressed size, unknown */</FONT></I>
              err = zip64local_putValue(&amp;zi-&gt;z_filefunc, zi-&gt;filestream, uncompressed_size, 8);

            <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK) <I><FONT COLOR="#B22222">/* uncompressed size, unknown */</FONT></I>
              err = zip64local_putValue(&amp;zi-&gt;z_filefunc, zi-&gt;filestream, compressed_size, 8);
          }
          <B><FONT COLOR="#A020F0">else</FONT></B>
              err = ZIP_BADZIPFILE; <I><FONT COLOR="#B22222">// Caller passed zip64 = 0, so no room for zip64 info -&gt; fatal
</FONT></I>        }
        <B><FONT COLOR="#A020F0">else</FONT></B>
        {
          <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK) <I><FONT COLOR="#B22222">/* compressed size, unknown */</FONT></I>
              err = zip64local_putValue(&amp;zi-&gt;z_filefunc,zi-&gt;filestream,compressed_size,4);

          <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK) <I><FONT COLOR="#B22222">/* uncompressed size, unknown */</FONT></I>
              err = zip64local_putValue(&amp;zi-&gt;z_filefunc,zi-&gt;filestream,uncompressed_size,4);
        }

        <B><FONT COLOR="#A020F0">if</FONT></B> (ZSEEK64(zi-&gt;z_filefunc,zi-&gt;filestream, cur_pos_inzip,ZLIB_FILEFUNC_SEEK_SET)!=0)
            err = ZIP_ERRNO;
    }

    zi-&gt;number_entry ++;
    zi-&gt;in_opened_file_inzip = 0;

    <B><FONT COLOR="#A020F0">return</FONT></B> err;
}

<B><FONT COLOR="#228B22">extern</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> ZEXPORT <B><FONT COLOR="#0000FF">zipCloseFileInZip</FONT></B> (zipFile file)
{
    <B><FONT COLOR="#A020F0">return</FONT></B> zipCloseFileInZipRaw (file,0,0);
}

local <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">Write_Zip64EndOfCentralDirectoryLocator</FONT></B>(zip64_internal* zi, ZPOS64_T zip64eocd_pos_inzip)
{
  <B><FONT COLOR="#228B22">int</FONT></B> err = ZIP_OK;
  ZPOS64_T pos = zip64eocd_pos_inzip - zi-&gt;add_position_when_writting_offset;

  err = zip64local_putValue(&amp;zi-&gt;z_filefunc,zi-&gt;filestream,(uLong)ZIP64ENDLOCHEADERMAGIC,4);

  <I><FONT COLOR="#B22222">/*num disks*/</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK) <I><FONT COLOR="#B22222">/* number of the disk with the start of the central directory */</FONT></I>
      err = zip64local_putValue(&amp;zi-&gt;z_filefunc,zi-&gt;filestream,(uLong)0,4);

  <I><FONT COLOR="#B22222">/*relative offset*/</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK) <I><FONT COLOR="#B22222">/* Relative offset to the Zip64EndOfCentralDirectory */</FONT></I>
      err = zip64local_putValue(&amp;zi-&gt;z_filefunc,zi-&gt;filestream, pos,8);

  <I><FONT COLOR="#B22222">/*total disks*/</FONT></I> <I><FONT COLOR="#B22222">/* Do not support spawning of disk so always say 1 here*/</FONT></I>
    <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK) <I><FONT COLOR="#B22222">/* number of the disk with the start of the central directory */</FONT></I>
      err = zip64local_putValue(&amp;zi-&gt;z_filefunc,zi-&gt;filestream,(uLong)1,4);

    <B><FONT COLOR="#A020F0">return</FONT></B> err;
}

local <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">Write_Zip64EndOfCentralDirectoryRecord</FONT></B>(zip64_internal* zi, uLong size_centraldir, ZPOS64_T centraldir_pos_inzip)
{
  <B><FONT COLOR="#228B22">int</FONT></B> err = ZIP_OK;

  uLong Zip64DataSize = 44;

  err = zip64local_putValue(&amp;zi-&gt;z_filefunc,zi-&gt;filestream,(uLong)ZIP64ENDHEADERMAGIC,4);

  <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK) <I><FONT COLOR="#B22222">/* size of this 'zip64 end of central directory' */</FONT></I>
    err = zip64local_putValue(&amp;zi-&gt;z_filefunc,zi-&gt;filestream,(ZPOS64_T)Zip64DataSize,8); <I><FONT COLOR="#B22222">// why ZPOS64_T of this ?
</FONT></I>
  <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK) <I><FONT COLOR="#B22222">/* version made by */</FONT></I>
    err = zip64local_putValue(&amp;zi-&gt;z_filefunc,zi-&gt;filestream,(uLong)45,2);

  <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK) <I><FONT COLOR="#B22222">/* version needed */</FONT></I>
    err = zip64local_putValue(&amp;zi-&gt;z_filefunc,zi-&gt;filestream,(uLong)45,2);

  <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK) <I><FONT COLOR="#B22222">/* number of this disk */</FONT></I>
    err = zip64local_putValue(&amp;zi-&gt;z_filefunc,zi-&gt;filestream,(uLong)0,4);

  <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK) <I><FONT COLOR="#B22222">/* number of the disk with the start of the central directory */</FONT></I>
    err = zip64local_putValue(&amp;zi-&gt;z_filefunc,zi-&gt;filestream,(uLong)0,4);

  <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK) <I><FONT COLOR="#B22222">/* total number of entries in the central dir on this disk */</FONT></I>
    err = zip64local_putValue(&amp;zi-&gt;z_filefunc, zi-&gt;filestream, zi-&gt;number_entry, 8);

  <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK) <I><FONT COLOR="#B22222">/* total number of entries in the central dir */</FONT></I>
    err = zip64local_putValue(&amp;zi-&gt;z_filefunc, zi-&gt;filestream, zi-&gt;number_entry, 8);

  <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK) <I><FONT COLOR="#B22222">/* size of the central directory */</FONT></I>
    err = zip64local_putValue(&amp;zi-&gt;z_filefunc,zi-&gt;filestream,(ZPOS64_T)size_centraldir,8);

  <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK) <I><FONT COLOR="#B22222">/* offset of start of central directory with respect to the starting disk number */</FONT></I>
  {
    ZPOS64_T pos = centraldir_pos_inzip - zi-&gt;add_position_when_writting_offset;
    err = zip64local_putValue(&amp;zi-&gt;z_filefunc,zi-&gt;filestream, (ZPOS64_T)pos,8);
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> err;
}

local <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">Write_EndOfCentralDirectoryRecord</FONT></B>(zip64_internal* zi, uLong size_centraldir, ZPOS64_T centraldir_pos_inzip)
{
  <B><FONT COLOR="#228B22">int</FONT></B> err = ZIP_OK;

  <I><FONT COLOR="#B22222">/*signature*/</FONT></I>
  err = zip64local_putValue(&amp;zi-&gt;z_filefunc,zi-&gt;filestream,(uLong)ENDHEADERMAGIC,4);

  <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK) <I><FONT COLOR="#B22222">/* number of this disk */</FONT></I>
    err = zip64local_putValue(&amp;zi-&gt;z_filefunc,zi-&gt;filestream,(uLong)0,2);

  <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK) <I><FONT COLOR="#B22222">/* number of the disk with the start of the central directory */</FONT></I>
    err = zip64local_putValue(&amp;zi-&gt;z_filefunc,zi-&gt;filestream,(uLong)0,2);

  <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK) <I><FONT COLOR="#B22222">/* total number of entries in the central dir on this disk */</FONT></I>
  {
    {
      <B><FONT COLOR="#A020F0">if</FONT></B>(zi-&gt;number_entry &gt;= 0xFFFF)
        err = zip64local_putValue(&amp;zi-&gt;z_filefunc,zi-&gt;filestream,(uLong)0xffff,2); <I><FONT COLOR="#B22222">// use value in ZIP64 record
</FONT></I>      <B><FONT COLOR="#A020F0">else</FONT></B>
        err = zip64local_putValue(&amp;zi-&gt;z_filefunc,zi-&gt;filestream,(uLong)zi-&gt;number_entry,2);
    }
  }

  <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK) <I><FONT COLOR="#B22222">/* total number of entries in the central dir */</FONT></I>
  {
    <B><FONT COLOR="#A020F0">if</FONT></B>(zi-&gt;number_entry &gt;= 0xFFFF)
      err = zip64local_putValue(&amp;zi-&gt;z_filefunc,zi-&gt;filestream,(uLong)0xffff,2); <I><FONT COLOR="#B22222">// use value in ZIP64 record
</FONT></I>    <B><FONT COLOR="#A020F0">else</FONT></B>
      err = zip64local_putValue(&amp;zi-&gt;z_filefunc,zi-&gt;filestream,(uLong)zi-&gt;number_entry,2);
  }

  <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK) <I><FONT COLOR="#B22222">/* size of the central directory */</FONT></I>
    err = zip64local_putValue(&amp;zi-&gt;z_filefunc,zi-&gt;filestream,(uLong)size_centraldir,4);

  <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK) <I><FONT COLOR="#B22222">/* offset of start of central directory with respect to the starting disk number */</FONT></I>
  {
    ZPOS64_T pos = centraldir_pos_inzip - zi-&gt;add_position_when_writting_offset;
    <B><FONT COLOR="#A020F0">if</FONT></B>(pos &gt;= 0xffffffff)
    {
      err = zip64local_putValue(&amp;zi-&gt;z_filefunc,zi-&gt;filestream, (uLong)0xffffffff,4);
    }
    <B><FONT COLOR="#A020F0">else</FONT></B>
      err = zip64local_putValue(&amp;zi-&gt;z_filefunc,zi-&gt;filestream, (uLong)(centraldir_pos_inzip - zi-&gt;add_position_when_writting_offset),4);
  }

   <B><FONT COLOR="#A020F0">return</FONT></B> err;
}

local <B><FONT COLOR="#228B22">int</FONT></B> <B><FONT COLOR="#0000FF">Write_GlobalComment</FONT></B>(zip64_internal* zi, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>* global_comment)
{
  <B><FONT COLOR="#228B22">int</FONT></B> err = ZIP_OK;
  uInt size_global_comment = 0;

  <B><FONT COLOR="#A020F0">if</FONT></B>(global_comment != NULL)
    size_global_comment = (uInt)strlen(global_comment);

  err = zip64local_putValue(&amp;zi-&gt;z_filefunc,zi-&gt;filestream,(uLong)size_global_comment,2);

  <B><FONT COLOR="#A020F0">if</FONT></B> (err == ZIP_OK &amp;&amp; size_global_comment &gt; 0)
  {
    <B><FONT COLOR="#A020F0">if</FONT></B> (ZWRITE64(zi-&gt;z_filefunc,zi-&gt;filestream, global_comment, size_global_comment) != size_global_comment)
      err = ZIP_ERRNO;
  }
  <B><FONT COLOR="#A020F0">return</FONT></B> err;
}

<B><FONT COLOR="#228B22">extern</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> ZEXPORT <B><FONT COLOR="#0000FF">zipFlush</FONT></B> (zipFile file)
{
    zip64_internal* zi;

    <B><FONT COLOR="#A020F0">if</FONT></B> (file == NULL)
        <B><FONT COLOR="#A020F0">return</FONT></B> ZIP_PARAMERROR;

    zi = (zip64_internal*)file;

    <B><FONT COLOR="#A020F0">return</FONT></B> ZFLUSH64(zi-&gt;z_filefunc,zi-&gt;filestream);
}

<B><FONT COLOR="#228B22">extern</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> ZEXPORT <B><FONT COLOR="#0000FF">zipClose</FONT></B> (zipFile file, <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>* global_comment)
{
    zip64_internal* zi;
    <B><FONT COLOR="#228B22">int</FONT></B> err = 0;
    uLong size_centraldir = 0;
    ZPOS64_T centraldir_pos_inzip;
    ZPOS64_T pos;

    <B><FONT COLOR="#A020F0">if</FONT></B> (file == NULL)
        <B><FONT COLOR="#A020F0">return</FONT></B> ZIP_PARAMERROR;

    zi = (zip64_internal*)file;

    <B><FONT COLOR="#A020F0">if</FONT></B> (zi-&gt;in_opened_file_inzip == 1)
    {
        err = zipCloseFileInZip (file);
    }

#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">NO_ADDFILEINEXISTINGZIP</FONT>
    <B><FONT COLOR="#A020F0">if</FONT></B> (global_comment==NULL)
        global_comment = zi-&gt;globalcomment;
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>

    centraldir_pos_inzip = ZTELL64(zi-&gt;z_filefunc,zi-&gt;filestream);

    <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK)
    {
        linkedlist_datablock_internal* ldi = zi-&gt;central_dir.first_block;
        <B><FONT COLOR="#A020F0">while</FONT></B> (ldi!=NULL)
        {
            <B><FONT COLOR="#A020F0">if</FONT></B> ((err==ZIP_OK) &amp;&amp; (ldi-&gt;filled_in_this_block&gt;0))
            {
                <B><FONT COLOR="#A020F0">if</FONT></B> (ZWRITE64(zi-&gt;z_filefunc,zi-&gt;filestream, ldi-&gt;data, ldi-&gt;filled_in_this_block) != ldi-&gt;filled_in_this_block)
                    err = ZIP_ERRNO;
            }

            size_centraldir += ldi-&gt;filled_in_this_block;
            ldi = ldi-&gt;next_datablock;
        }
    }
    free_linkedlist(&amp;(zi-&gt;central_dir));

    pos = centraldir_pos_inzip - zi-&gt;add_position_when_writting_offset;
    <B><FONT COLOR="#A020F0">if</FONT></B>(pos &gt;= 0xffffffff || zi-&gt;number_entry &gt; 0xFFFF)
    {
      ZPOS64_T Zip64EOCDpos = ZTELL64(zi-&gt;z_filefunc,zi-&gt;filestream);
      Write_Zip64EndOfCentralDirectoryRecord(zi, size_centraldir, centraldir_pos_inzip);

      Write_Zip64EndOfCentralDirectoryLocator(zi, Zip64EOCDpos);
    }

    <B><FONT COLOR="#A020F0">if</FONT></B> (err==ZIP_OK)
      err = Write_EndOfCentralDirectoryRecord(zi, size_centraldir, centraldir_pos_inzip);

    <B><FONT COLOR="#A020F0">if</FONT></B>(err == ZIP_OK)
      err = Write_GlobalComment(zi, global_comment);

    <B><FONT COLOR="#A020F0">if</FONT></B> (ZCLOSE64(zi-&gt;z_filefunc,zi-&gt;filestream) != 0)
        <B><FONT COLOR="#A020F0">if</FONT></B> (err == ZIP_OK)
            err = ZIP_ERRNO;

#<B><FONT COLOR="#5F9EA0">ifndef</FONT></B> <FONT COLOR="#B8860B">NO_ADDFILEINEXISTINGZIP</FONT>
    TRYFREE(zi-&gt;globalcomment);
#<B><FONT COLOR="#5F9EA0">endif</FONT></B>
    TRYFREE(zi);

    <B><FONT COLOR="#A020F0">return</FONT></B> err;
}

<B><FONT COLOR="#228B22">extern</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> ZEXPORT <B><FONT COLOR="#0000FF">zipRemoveExtraInfoBlock</FONT></B> (<B><FONT COLOR="#228B22">char</FONT></B>* pData, <B><FONT COLOR="#228B22">int</FONT></B>* dataLen, <B><FONT COLOR="#228B22">short</FONT></B> sHeader)
{
  <B><FONT COLOR="#228B22">char</FONT></B>* p = pData;
  <B><FONT COLOR="#228B22">int</FONT></B> size = 0;
  <B><FONT COLOR="#228B22">char</FONT></B>* pNewHeader;
  <B><FONT COLOR="#228B22">char</FONT></B>* pTmp;
  <B><FONT COLOR="#228B22">short</FONT></B> header;
  <B><FONT COLOR="#228B22">short</FONT></B> dataSize;

  <B><FONT COLOR="#228B22">int</FONT></B> retVal = ZIP_OK;

  <B><FONT COLOR="#A020F0">if</FONT></B>(pData == NULL || *dataLen &lt; 4)
    <B><FONT COLOR="#A020F0">return</FONT></B> ZIP_PARAMERROR;

  pNewHeader = (<B><FONT COLOR="#228B22">char</FONT></B>*)ALLOC(*dataLen);
  pTmp = pNewHeader;

  <B><FONT COLOR="#A020F0">while</FONT></B>(p &lt; (pData + *dataLen))
  {
    header = *(<B><FONT COLOR="#228B22">short</FONT></B>*)p;
    dataSize = *(((<B><FONT COLOR="#228B22">short</FONT></B>*)p)+1);

    <B><FONT COLOR="#A020F0">if</FONT></B>( header == sHeader ) <I><FONT COLOR="#B22222">// Header found.
</FONT></I>    {
      p += dataSize + 4; <I><FONT COLOR="#B22222">// skip it. do not copy to temp buffer
</FONT></I>    }
    <B><FONT COLOR="#A020F0">else</FONT></B>
    {
      <I><FONT COLOR="#B22222">// Extra Info block should not be removed, So copy it to the temp buffer.
</FONT></I>      memcpy(pTmp, p, dataSize + 4);
      p += dataSize + 4;
      size += dataSize + 4;
    }

  }

  <B><FONT COLOR="#A020F0">if</FONT></B>(size &lt; *dataLen)
  {
    <I><FONT COLOR="#B22222">// clean old extra info block.
</FONT></I>    memset(pData,0, *dataLen);

    <I><FONT COLOR="#B22222">// copy the new extra info block over the old
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B>(size &gt; 0)
      memcpy(pData, pNewHeader, size);

    <I><FONT COLOR="#B22222">// set the new extra info size
</FONT></I>    *dataLen = size;

    retVal = ZIP_OK;
  }
  <B><FONT COLOR="#A020F0">else</FONT></B>
    retVal = ZIP_ERRNO;

  TRYFREE(pNewHeader);

  <B><FONT COLOR="#A020F0">return</FONT></B> retVal;
}
</PRE>
<HR>
<ADDRESS>Generated by <A HREF="http://www.iki.fi/~mtr/genscript/">GNU Enscript 1.6.5.90</A>.</ADDRESS>
</BODY>

<!-- Mirrored from www.httrack.com/src/minizip/zip.c.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 02 Jan 2023 20:33:58 GMT -->
</HTML>
